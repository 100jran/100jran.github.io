<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- 웹폰트 -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Song+Myung&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo&display=swap" rel="stylesheet">
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="" />
    <link rel="shortcut icon" href="https://100jran.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://100jran.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="100'Log" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="" />
    <meta property="og:url" content="https://100jran.github.io/search" />
    <meta property="og:image" content="https://100jran.github.io/assets/built/images/back.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="https://100jran.github.io/" />
    <meta name="twitter:image" content="https://100jran.github.io/assets/built/images/back.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="100'Log" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "100'Log",
        "logo": "https://100jran.github.io/"
    },
    "url": "https://100jran.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://100jran.github.io/assets/built/images/back.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://100jran.github.io/search"
    },
    "description": ""
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://100jran.github.io/">100'Log</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!-- about
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    -->
    <!--
    <li class="nav-jekyll" role="menuitem"><a href="/tag/java/">java</a></li>
    -->
    <!-- javascript
    <li class="nav-python" role="menuitem"><a href="/tag/javaScript/">javaScript</a></li>
    -->
    <!--
    <li class="nav-python" role="menuitem"><a href="/tag/java practice/">java practice</a></li>
    -->
    <!-- til
    <li class="nav-python" role="menuitem"><a href="/tag/til/">til</a></li>
    -->
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag</a>
    </li>
  </ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "10cornerstonejava5": {
        "title": "Ch10-13~16. SimpleDateFormat",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter10. 날짜와 시간 &amp; 형식화  Ch10 - 13. SimpleDateFormat  Ch10 - 14. SimpleDateFormat 예제1  Ch10 - 15. SimpleDateFormat 예제2  Ch10 - 16. SimpleDateFormat 예제3Ch10 - 13. SimpleDateFormat▶ SimpleDateFormat이란?▷ 날짜와 시간을 다양한 형식으로 출력 가능  날짜와 시간 → 다양한 형식 : format()▷ 특정 형식으로 되어있는 문자열에서 날짜와 시간 출력 가능  특정 형식 문자열 → 날짜와 시간 : parse()▷ 날짜 관련 기호▷ 시간 관련 기호Ch10 - 14. SimpleDateFormat 예제1▶ yyyy-mm-dd hh:mm:ss 요일▷ Date → 문자열 : format()Date today = new Date();SimpleDateFormat sdf;sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss E요일\");System.out.println(sdf.format(today));// console2021-07-28 15:05:48 수요일▶ 2021 --D-→ 2022▷ Date → 문자열 : format()Date today = new Date();SimpleDateFormat sdf;sdf = new SimpleDateFormat(\"2021 --D-→ 2022\");System.out.println(sdf.format(today));// console2021 --209-→ 2022Ch10 - 15. SimpleDateFormat 예제2▶ 날짜와 시간 → 다양한 형식 : format()▷ yyyy-MM-dd▷ Date → format() → yyyy-MM-ddDate today = new Date();SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");String result = df.format(today);System.out.println(result);// console2021-07-28Ch10 - 16. SimpleDateFormat 예제3▶ 특정 형식 문자열 → 날짜와 시간 : parse()▷ yyyy년 MM월 dd일 → yyyy/MM/dd▷ yyyy년 MM월 dd일 → parse() → Date → format() → yyyy/MM/ddDateFormat df = new SimpleDateFormat(\"yyyy년 MM월 dd일\");DateFormat df2 = new SimpleDateFormat(\"yyyy/MM/dd\");Date today = df.parse(\"2021년 7월 28일\");String result = df2.format(today);System.out.println(result);// console2021/07/28",
        "url": "/10cornerstoneJava5"
    }
    ,
    
    "10cornerstonejava4": {
        "title": "Ch10-9~12. DecimalFormat",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter10. 날짜와 시간 &amp; 형식화  Ch10 - 9. 형식화 클래스  Ch10 - 10. DecimalFormat  Ch10 - 11. DecimalFormat 예제1  Ch10 - 12. DecimalFormat 예제2Ch10 - 9. 형식화 클래스▶ 형식화 클래스란?▷ java.text 패키지의 DecimalFormat, SimpleDateFormat  Decimal : 숫자(10진수)  Date : 날짜▷ 숫자와 날짜를 원하는 형식으로 쉽게 출력 가능  숫자 → 형식 문자열  날짜 → 형식 문자열▷ double → Stringdouble num = 1234567.89;DecimalFormat df = new DecimalFormat(\"#.#E0\"); // 형식 문자열String result = df.format(num);\"1.2E6\"  1.2E6 = 1.2 × 106▷ String → doubleDecimalFormat df = new DecimalFormat(\"#,###.##\"); // 형식 문자열Number num = df.parse(\"1,234,567.89\");double d = num.doubleValue();1234567.89Ch10 - 10. DecimalFormat▶ DecimalFormat이란?▷ 숫자(10진수)를 형식화 할 때 사용▷ 숫자(10진수) → 형식 문자열▷ 특정 형식의 문자열을 숫자로 변환 할 때도 사용  형식 문자열 → 숫자(10진수)      DecimalFormat df = new DecimalFormat(\"#,###.##\"); // 형식 문자열  Number num = df.parse(\"1,234,567.89\"); // Number : 모든 숫자 래퍼 클래스의 최고 조상   double d = num.doubleValue();          1234567.89        Integer.parseInt()는 콤마(,)가 포함 된 문자열을 숫자로 변환 못함Ch10 - 11. DecimalFormat 예제1▶ 패턴 출력▷ 숫자 → 형식 문자열 : df.format(number)▷ 형식 문자열 → 숫자 : df.parse(number)public static void main(String[] args) throws Exception {  double number  = 1234567.89;    String[] pattern = {    \"0\",    \"#\",    \"0.0\",    \"#.#\",    \"0000000000.0000\",    \"##########.####\",    \"#.#-\",    \"-#.#\",    \"#,###.##\",    \"#,####.##\",    \"#E0\",    \"0E0\",    \"##E0\",    \"00E0\",    \"####E0\",    \"0000E0\",    \"#.#E0\",    \"0.0E0\",    \"0.000000000E0\",    \"00.00000000E0\",    \"000.0000000E0\",    \"#.#########E0\",    \"##.########E0\",    \"###.#######E0\",    \"#,###.##+;#,###.##-\",    \"#.#%\",    \"#.#\\u2030\",    \"\\u00A4 #,###\",    \"'#'#,###\",    \"''#,###\",  };  for(int i=0; i &lt; pattern.length; i++) {    DecimalFormat df = new DecimalFormat(pattern[i]);    System.out.printf(\"%19s : %s\\n\",pattern[i], df.format(number));    }  }}// console                  0 : 1234568                  # : 1234568                0.0 : 1234567.9                #.# : 1234567.9    0000000000.0000 : 0001234567.8900    ##########.#### : 1234567.89               #.#- : 1234567.9-               -#.# : -1234567.9           #,###.## : 1,234,567.89          #,####.## : 123,4567.89                #E0 : .1E7                0E0 : 1E6               ##E0 : 1.2E6               00E0 : 12E5             ####E0 : 123.5E4             0000E0 : 1235E3              #.#E0 : 1.2E6              0.0E0 : 1.2E6      0.000000000E0 : 1.234567890E6      00.00000000E0 : 12.34567890E5      000.0000000E0 : 123.4567890E4      #.#########E0 : 1.23456789E6      ##.########E0 : 1.23456789E6      ###.#######E0 : 1.23456789E6#,###.##+;#,###.##- : 1,234,567.89+               #.#% : 123456789%               #.#‰ : 1234567890‰            ¤ #,### : ? 1,234,568           '#'#,### : #1,234,568            ''#,### : '1,234,568Ch10 - 12. DecimalFormat 예제2▶ 형식 문자열 → 숫자 → 형식 문자열▷ 형식 문자열 → 숫자  df.parse(number)▷ 숫자 → 형식 문자열  df.format(number)▷ 형식 문자열 → 숫자 → 형식 문자열  df.parse(number) → df.format(number) → df.parse(number)public static void main(String[] args) {        DecimalFormat df  = new DecimalFormat(\"#,###.##\");        DecimalFormat df2 = new DecimalFormat(\"#.###E0\");                try {            Number num = df.parse(\"1,234,567.89\");            System.out.print(\"1,234,567.89\" + \" → \");                        double d = num.doubleValue();             System.out.print(d + \" → \");                        System.out.println(df2.format(num));    } catch(Exception e) {        }}// console// 형식 문자열 → 숫자(double) → 형식 문자열\"1,234,567.89\" → 1234567.89 → \"1.235E6\"",
        "url": "/10cornerstoneJava4"
    }
    ,
    
    "10cornerstonejava3": {
        "title": "Ch10-6~8. Calendar 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter10. 날짜와 시간 &amp; 형식화  Ch10 - 6. Calendar 클래스 예제4  Ch10 - 7. Calendar 클래스 예제5  Ch10 - 8. Date와 Calendar간의 변환Ch10 - 6. Calendar 클래스 예제4▶ add()란?▷ add()는 특정 필드의 값을 증가 또는 감소▷ 다른 필드에 영향有Calendar date = Calendar.getInstance();date.clear();date.set(2021, 6, 31); // 2021.07.31System.out.println(new Date(date.getTimeInMillis()));date.add(Calendar.DATE, 1);System.out.println(new Date(date.getTimeInMillis()));date.add(Calendar.MONTH, -8);System.out.println(new Date(date.getTimeInMillis()));// console//[set 2021.07.31] Sat Jul 31 00:00:00 KST 2021//[add.Date+1 2021.07.31 → 2021.08.01] Sun Aug 01 00:00:00 KST 2021//[add.Month-8 2021.08.01 → 2020.12.01]Tue Dec 01 00:00:00 KST 2020▶ roll()란?▷ roll() ≒ add()▷ 특정 필드의 값을 증가 또는 감소▷ 단, 다른 필드에 영향無Calendar date = Calendar.getInstance();date.clear();date.set(2021, 6, 31); // 2021.07.31System.out.println(new Date(date.getTimeInMillis()));date.roll(Calendar.DATE, 1);System.out.println(new Date(date.getTimeInMillis()));date.roll(Calendar.MONTH, -8);System.out.println(new Date(date.getTimeInMillis()));//set 2021.07.31] Sat Jul 31 00:00:00 KST 2021//[roll.Date+1 2021.07.31 → 2021.07.01] Thu Jul 01 00:00:00 KST 2021//[roll.Month-8 2021.07.01 → 2020.11.01]Mon Nov 01 00:00:00 KST 2021다른 필드에 영향을 미치지 않음add() 7/31 → Date +1 → 8/1 : 일 변경 → 월 변경roll() 7/31 → Date +1 → 7/1 : 일 변경 → 월 변경X▶ 실습▷ 현재 2021.07.31public static String toString(Calendar c) {    return c.get(Calendar.YEAR) + \":\" +            (c.get(Calendar.MONTH) + 1) + \":\" +            (c.get(Calendar.DATE));}Calendar cal = Calendar.getInstance();cal.set(2021, 6, 31);System.out.println(toString(cal));// console2021:7:31▷ 1일 후  add()      cal.add(Calendar.DATE, 1);      System.out.println(toString(cal));      // console  2021:8:1        roll()      cal.roll(Calendar.DATE, 1);      System.out.println(toString(cal));      // console  2021:7:1      ▷ 10년 후  add()      cal.add(Calendar.YEAR, 1);      System.out.println(toString(cal));      // console  2022:8:1        roll()      cal.roll(Calendar.YEAR, 1);      System.out.println(toString(cal));      // console  2022:7:1      ▷ 7달 후  add()      cal.add(Calendar.MONTH, 7);      System.out.println(toString(cal));      // console  2023:3:1        roll()      cal.roll(Calendar.MONTH, 7);      System.out.println(toString(cal));      // console  2022:2:1      Ch10 - 7. Calendar 클래스 예제5▶ 달력 출력▷ args[] 매개변수에 년도, 월을 입력 받음public static void main(String[] args) {    if (args.length != 2) {        System.out.println(\"INPUT! : year month\");        return;}// consoleINPUT : year month // args에 아무것도 입력 안해서 그럼Run → Run Configurations → Arguments → 입력ex) 2021 7▷ String으로 받은 args[]를 int로 변경int year = Integer.parseInt(args[0]);int month = Integer.parseInt(args[1]);▷ 1일 설정▷ sDay.set(year, month - 1, 1)Calendar sDay = Calendar.getInstance();sDay.set(year, month - 1, 1);6/1 // 6월이라 나와도 요일이나 일수는 7월 거로 나옴▷ 말일 설정 : 30 or 31▷ eDay.set(year, month, 1)의 전날 = month의 말일Calendar eDay = Calendar.getInstance();eDay.set(year, month, 1);eDay.add(Calendar.DATE, -1);Run → Run Configurations → Arguments → 2021 7 → 7월은 31일까지6/31 // 6월이라 나와도 요일이나 일수는 7월 거로 나옴, 6월은 30일까지▷ 1일의 요일 구하기int START_DAY_OF_WEEK = 0;START_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);5 // 일-1, 월-2, 화-3, 수-4, 목-5, 금-6, 토-7▷ 0 &lt; 1일의 요일 : 공백 만들어 주기for (int i = 1; i &lt; START_DAY_OF_WEEK; i++) {\t\t\tSystem.out.print(\"   \"); }▷ 1일의 요일부터 말일까지 날짜 찍어주기▷ 7의 배수일 때 줄 바꿈 : 7의 배수 = 7로 나누었을 때 나머지가 0for (int j = 1, n = START_DAY_OF_WEEK; j &lt;= END_DAY; j++, n++) {    System.out.printf(\" %2d\", j);    if (n%7 == 0) System.out.println();}  1일 ~ END_DAY(말일)    __START__DAY__OF__WEEK__  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31        START_DAY_OF_WEEK 부터 1씩 증가          7의 배수가 될 때 나머지가 0n%7 == 0      줄 바꿈if (n%7 == 0) System.out.println();      ▷ 전체package baek;import java.time.DayOfWeek;import java.util.Calendar;public class BaeksCal {\tpublic static void main(String[] args) {\t\tif (args.length != 2) {\t\t\tSystem.out.println(\"INPUT! : year month\");\t\t\treturn;\t\t}\t\t\t\tint year = Integer.parseInt(args[0]);\t\tint month = Integer.parseInt(args[1]);\t\t\t\tint END_DAY = 0;\t\t\t\tCalendar eDay = Calendar.getInstance();\t\teDay.clear();\t\t\t\teDay.set(year, month, 1);\t\teDay.add(Calendar.DATE, -1);\t\t\t\tint START_DAY_OF_WEEK = 0;\t\t\t\tCalendar sDay = Calendar.getInstance();\t\tsDay.clear();\t\t\t\tsDay.set(year, month - 1, 1);\t\t\t\tSystem.out.println(\" \" + args[0] + \".\" + args[1]);\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\t\t\tSTART_DAY_OF_WEEK = sDay.get(Calendar.DAY_OF_WEEK);\t\tEND_DAY = eDay.get(Calendar.DATE);\t\tfor (int i = 1; i &lt; START_DAY_OF_WEEK; i++) {\t\t\tSystem.out.print(\"   \"); \t\t}\t\tfor (int j = 1, n = START_DAY_OF_WEEK; j &lt;= END_DAY; j++, n++) {\t\t\tSystem.out.printf(\" %2d\", j);\t\t\tif (n%7 == 0) System.out.println();\t\t}\t}}달력 point! 말일 구하기 + 1일 요일 구하기!!Ch10 - 8. Date와 Calendar간의 변환▶ Date와 Calendar간의 변환이란?▷ Date의 메서드는 대부분 deprecated 되었지만 여전히 사용  deprecated : 사용하지 않을 것을 권장▷ Date의 메서드 : JDK1.0부터 사용▷ 하위 호환성을 중시하는 java Date의 메서드를 사용할 수 있도록 함  Calendar → Date    Calendar cal = Calendar.getInstance();...Date d = new Date(cal.getTimeInMillis());        Date → Calendar    Date d = new Date();...Calendar cal = Calendar.getInstance();cal.setTime(d)      ",
        "url": "/10cornerstoneJava3"
    }
    ,
    
    "10cornerstonejava2": {
        "title": "Ch10-4~5. Calendar 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter10. 날짜와 시간 &amp; 형식화  Ch10 - 1. Calendar 클래스 예제2  Ch10 - 2. Calendar 클래스 예제3Ch10 - 4. Calendar 클래스 예제2▶ set()으로 날짜와 시간 지정 가능▷ 특정 필드만 지정void set(int field, int value)▷ 년, 월, 일 지정void set(int year, int month, int date)  한 번에 년, 월, 일 설정      Calendar cal = Calendar.getInstance();    cal.set(2021, 6, 23); // 2021년 7월 23일        하나 씩 년, 월, 일 설정      Calendar cal = Calendar.getInstance();    cal.set(Calendar.YEAR, 2021); // 2021년  cal.set(Calendar.MONTH, 6); // 7월  cal.set(Calendar.DATE, 23); // 23일        월(MONTH) 지정 시, 0부터 시작한다는 점에 주의(해당 월 -1로 입력)  ▷ 년, 월, 일, 시, 분, 초 지정void set(int year, int month, int date, int hourOfDay, int minute, int second)  Calendar time = Calendar.getInstance();            time.set(Calendar.HOUR_OF_DAY, 10); // 10시  time.set(Calendar.MINUTE, 20); // 20분  time.set(Calendar.SECOND, 30); // 30초▶ 실습1▷ 2021년 7월 31일public static void main(String[] args) {  Calendar time = Calendar.getInstance();    time.set(2021, 6, 31);    System.out.println(time.get(Calendar.YEAR));  System.out.println(time.get(Calendar.MONTH) + 1);  System.out.println(time.get(Calendar.DATE));}// console2021731▷ 토요일 1 : ‘7’로 출력System.out.println(time.get(Calendar.DAY_OF_WEEK));// console7▷ 토요일 2 : “토”로 출력final String[] DAY_OF_WEEK = {\"\", \"일\", \"월\", \"화\", \"수\", \"목\", \"금\", \"토\"};System.out.println(DAY_OF_WEEK[time.get(Calendar.DAY_OF_WEEK)]);// console토  2021년 7월 31일 토    final String[] DAY_OF_WEEK = {\"\", \"일\", \"월\", \"화\", \"수\", \"목\", \"금\", \"토\"};  public static String when(Calendar t) {  return t.get(Calendar.YEAR) + \"년 \" + (t.get(Calendar.MONTH) + 1) + \"월 \" + (t.get(Calendar.DATE)) + \"일 \";}  public static void main(String[] args) {  C c = new C();      Calendar time = Calendar.getInstance();      time.set(2021, 6, 31);      System.out.println(when(time) + c.DAY_OF_WEEK[time.get(Calendar.DAY_OF_WEEK)]);}  // console2021년 7월 31일 토      ▷ 1월 1일 부터 지금까지 몇일이 지났는가? 1 : 초(second)단위  7월 31일 - 1월 1일  For 기계 : 초(second)단위로 환산해서 뺄셈          getTimeInMillis() = 1/1000초      getTimeInMillis()/1000 = 1초        atTime.set(2021, 0, 1);            long secondDifference = (time.getTimeInMillis() - atTime.getTimeInMillis()) / 1000;    System.out.println(secondDiffrence);    // console18230399 // (second)time - (second)atTime                    ▷ 1월 1일 부터 지금까지 몇일이 지났는가? 2 : 일(day)단위  For 사람 : 일(day)단위로 환산해서 출력  시간 환산 ≒ 거스름 돈  ex) 3790원 동전으로 다 주기          500원3790 ÷ 500 = 73790 – 3500 = 290      100원290 ÷ 100 = 2290 – 200 = 90      50원90 ÷ 50 = 190 – 50 = 40      10원40 ÷ 10 = 4        시간 환산          1 × 60 = 60초 = 1분      1분 × 60 = 1시간      1시간 × 24 = 1일        atTime.set(2021, 1, 1);    long secondDifference = (time.getTimeInMillis() - atTime.getTimeInMillis()) / 1000;long dayDifference = secondDiffrence / (24 * 60 * 60);    System.out.println(secondDifference);System.out.println(dayDifference);    // console15551999 // (second)time - (second)atTime210 // (day)time - (day)atTime                    ▷ 전체package baek;import java.util.Calendar;class C {\tC() { }\t\tfinal String[] DAY_OF_WEEK = {\"\", \"일\", \"월\", \"화\", \"수\", \"목\", \"금\", \"토\"};\t\tpublic static String when(Calendar t) {\t\treturn t.get(Calendar.YEAR) + \"년 \" +\t\t\t\t(t.get(Calendar.MONTH) + 1) + \"월 \" + \t\t\t\t(t.get(Calendar.DATE)) + \"일 \";\t}\t\tpublic static void main(String[] args) {\t\tC c = new C();\t\t\t\tCalendar time = Calendar.getInstance();\t\tCalendar atTime = Calendar.getInstance();\t\tCalendar lastTime = Calendar.getInstance();\t\t\t\ttime.set(2021, 6, 31);\t\tatTime.set(2021, 0, 1);\t\tlastTime.set(2022, 0, 1);\t\t\t\tlong secondDifference = (time.getTimeInMillis() - atTime.getTimeInMillis()) / 1000;\t\tlong hourDifference = secondDifference / (60 * 60);\t\tlong dayDifference = secondDifference / (24 * 60 * 60);\t\t\t\tlong remainSecondDifference = (lastTime.getTimeInMillis() - time.getTimeInMillis()) / 1000;\t\tlong remainHourDifference = remainSecondDifference / (60 * 60);\t\tlong remainDayDifference = remainSecondDifference / (24 * 60 * 60);\t\t\t\tSystem.out.println(when(time) + c.DAY_OF_WEEK[time.get(Calendar.DAY_OF_WEEK)]);\t\tSystem.out.println();\t\tSystem.out.println(when(atTime) + \"-d-o-n-e→ \" + when(time));\t\tSystem.out.println(when(atTime) + \"-\" + hourDifference + \"시간→ \" + when(time));\t\tSystem.out.println(when(atTime) + \"-\" + dayDifference + \"일→ \" + when(time));\t\tSystem.out.println();\t\tSystem.out.println((time.get(Calendar.YEAR) + 1) + \"년 까지 남은 시간은?\");\t\tSystem.out.println(when(time) + \"-re-m-a-i-n→ \" + when(lastTime));\t\tSystem.out.println(when(time) + \"-\" + remainHourDifference + \"시간→ \" + when(lastTime));\t\tSystem.out.println(when(time) + \"-\" + remainDayDifference + \"일→ \" + when(lastTime));\t}}// console2021년 7월 31일 토2021년 1월 1일 -d-o-n-e→ 2021년 7월 31일 2021년 1월 1일 -5063시간→ 2021년 7월 31일 2021년 1월 1일 -210일→ 2021년 7월 31일 2022년 까지 남은 시간은?2021년 7월 31일 -re-m-a-i-n→ 2022년 1월 1일 2021년 7월 31일 -3696시간→ 2022년 1월 1일 2021년 7월 31일 -154일→ 2022년 1월 1일 ▶ 실습2▷ timeOne 20시 20분 30초▷ timeTwo 10시 20분 30초public static String bedTime(Calendar n) {  return n.get(Calendar.HOUR_OF_DAY) + \":\" + n.get(Calendar.MINUTE) + \":\" + n.get(Calendar.SECOND); }public static void main(String[] args) {  Calendar timeOne = Calendar.getInstance();  Calendar timeTwo = Calendar.getInstance();    timeOne.set(Calendar.HOUR_OF_DAY, 20);  timeOne.set(Calendar.MINUTE, 20);  timeOne.set(Calendar.SECOND, 30);    timeTwo.set(Calendar.HOUR_OF_DAY, 10);  timeTwo.set(Calendar.MINUTE, 20);  timeTwo.set(Calendar.SECOND, 30);    System.out.println(\"[TimeOne] \" + time(timeOne));  System.out.println(\"[TimeTwo] \" + time(timeTwo));}// console[TimeOne] 20:20:30[TimeTwo] 10:20:30▷ timeOne 20:20:30■■■■■■■■■■■■■■■■■■■■□□□□ ▷ timeOne 10:20:30■■■■■■■■■■□□□□□□□□□□□□□□ ▷ TimeOne - TimeTwo 구하기■■■■■■■■■■■■■■■■■■■■□□□□- ■■■■■■■■■■□□□□□□□□□□□□□□  초(second) 단위로 환산 후 뺄셈TimeOne.getTimeInMillis()/1000 - TimeTwo.getTimeInMillis()/1000  n시간, n분, n초 단위로 환산초/1 = 초초/60 = 분(1초 × 60)초/60 * 60 = 시간(1분 × 60)      final int[] TIME_UNIT = {3600, 60, 1};  final String[] TIME_UNIT_NAME = {\"시간 \", \"분 \", \"초\"};      long difference = (timeOne.getTimeInMillis() - timeTwo.getTimeInMillis())/1000;      String tmp = \"\";  for (int i = 0; i &lt; TIME_UNIT.length; i++) {    tmp += difference/TIME_UNIT[i] + TIME_UNIT_NAME[i];    difference %= TIME_UNIT[i];  }  System.out.println(\"timeOne - timeTwo = \" + tmp);      // console  timeOne - timeTwo = 9시간 59분 59초      ▷ 전체class SleepTime {\tSleepTime() { }\t\tpublic static String time(Calendar t) {\t\treturn t.get(Calendar.HOUR_OF_DAY) + \":\" + \t\t\t\tt.get(Calendar.MINUTE) + \":\" + \t\t\t\tt.get(Calendar.SECOND); \t}\tpublic static void main(String[] args) {\t\t\t\tCalendar timeOne = Calendar.getInstance(); \t\tCalendar timeTwo = Calendar.getInstance(); \t\t\t\ttimeOne.set(Calendar.HOUR_OF_DAY, 20);\t\ttimeOne.set(Calendar.MINUTE, 20);\t\ttimeOne.set(Calendar.SECOND, 30);\t\ttimeTwo.set(Calendar.HOUR_OF_DAY, 10);\t\ttimeTwo.set(Calendar.MINUTE, 20);\t\ttimeTwo.set(Calendar.SECOND, 30);\t\t\t\tSystem.out.println(\"[TimeOne] \" + time(timeOne));\t\tSystem.out.println(\"[TimeTwo] \" + time(timeTwo));\t\t\t\tfinal int[] TIME_UNIT = {3600, 60, 1};\t\tfinal String[] TIME_UNIT_NAME = {\"시간 \", \"분 \", \"초\"};\t\tlong difference = (timeOne.getTimeInMillis() - timeTwo.getTimeInMillis())/1000;\t\t\t\tString tmp = \"\";\t\tfor (int i = 0; i &lt; TIME_UNIT.length; i++) {\t\t\ttmp += difference/TIME_UNIT[i] + TIME_UNIT_NAME[i];\t\t\tdifference %= TIME_UNIT[i];\t\t}\t\tSystem.out.println(\"timeOne - timeTwo = \" + tmp);\t}}// console[TimeOne] 20:20:30[TimeTwo] 10:20:30timeOne - timeTwo = 9시간 59분 59초Ch10 - 5. Calendar 클래스 예제3▶ clear()란?▷ clear()는 Calendar 객체의 모든 필드를 초기화▷ Epoch Time : 1970년 1월 1일 00:00:00로 초기화Epoch Time 참고Calendar cal = Calendar.getInstance(); // 현재 시간으로System.out.println(new Date(cal.getTimeInMillis()));// consoleSat Jul 24 17:58:20 KST 2021cal.clear(); // Epoch Time으로 초기화 됨System.out.println(new Date(cal.getTimeInMillis()));// consoleThu Jan 01 00:00:00 KST 1970▷ clear(int field)는 Calendar 객체의 특정 필드를 초기화Calendar cal = Calendar.getInstance();cal.clear(Calendar.SECOND); // 초를 초기화 : 0초cal.clear(Calendar.MINUTE); // 분을 초기화 : 0분cal.clear(Calendar.HOUR_OF_DAY); // 시간을 초기화 : 0시간cal.clear(Calendar.HOUR); // 시간을 초기화 : 0시간System.out.println(new Date(cal.getTimeInMillis()));// consoleMon Jul 26 00:00:00 KST 2021▶ 객체 생성 → clear → set : 이렇게 해야 계산이 정확▷ yyyymmdd1 - yyyymmdd220200103 - 20200101 = 2일  static int getDayDiff(String yyyymmdd1, String yyyymmdd2) {        int diff = 0;    try {    int year1 = Integer.parseInt(yyyymmdd1.substring(0, 4));    int month1 = Integer.parseInt(yyyymmdd1.substring(4, 6)) - 1;    int day1 = Integer.parseInt(yyyymmdd1.substring(6, 8));    int year2 = Integer.parseInt(yyyymmdd2.substring(0, 4));    int month2 = Integer.parseInt(yyyymmdd2.substring(4, 6)) - 1;    int day2 = Integer.parseInt(yyyymmdd2.substring(6, 8));        Calendar date1 = Calendar.getInstance();    Calendar date2 = Calendar.getInstance();        date1.set(year1, month1, day1);    date2.set(year2, month2, day2);        diff = (int)(date1.getTimeInMillis() - date2.getTimeInMillis())/(24 * 60 * 60 * 1000);  } catch (Exception e) {    diff = 0;  }  return diff;  }    public static void main(String[] args) {      System.out.println(getDayDiff(\"20200103\", \"20200101\"));  }  // console  120200103 - 20200101 = 2일1일?  Calendar date1 = Calendar.getInstance();  Calendar date2 = Calendar.getInstance();    date1.set(year1, month1, day1);  date2.set(year2, month2, day2);    System.out.println((date1.getTimeInMillis() - date2.getTimeInMillis()) / (24 * 60 * 60 * 1000f));      // console  1.9999998yyyymmdd1과 yyyymmdd2의 차이는 2에서 0.00000002 부족왜?date1과 date2 객체 생성 시 차이가 발생그래서 clear()가 필요!Calendar date1 = Calendar.getInstance();Calendar date2 = Calendar.getInstance();date1.clear();date2.clear();date1.set(year1, month1, day1);date2.set(year2, month2, day2);System.out.println((date1.getTimeInMillis() - date2.getTimeInMillis()) / (24 * 60 * 60 * 1000f));// console2.0clear() 생성 후date1과 date2 객체 생성 시 차이X",
        "url": "/10cornerstoneJava2"
    }
    ,
    
    "10cornerstonejava1": {
        "title": "Ch10-1~3. Calendar 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter10. 날짜와 시간 &amp; 형식화  Ch10 - 1. 날짜와 시간  Ch10 - 2. Calendar 클래스  Ch10 - 3. Calendar 클래스 예제1Ch10 - 1. 날짜와 시간▶ java.util.Date 클래스란?▷ 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0)▷ Date의 메서드는 거의 deprecated 되었지만, 여전히 사용▶ java.util.Calendar 클래스란?▷ Date 클래스를 개선한 새로운 클래스(JDK1.1)▷ 그러나 여전히 단점 존재▶ java.time 패키지란?▷ Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8 = java8)▷ Date와 Calendar의 단점 : 날짜와 시간을 같이 다룸▷ java.time 패키지 : 날짜와 시간을 구분  날짜만 사용 - LocalDate 클래스  시간만 사용 - LocalTime 클래스  날짜 + 시간 둘 다 사용 - LocalCateTime 클래스Ch10 - 2. Calendar 클래스▶ Calendar 클래스란?▷ 추상 클래스▷ getInsance()를 통해 구현 된 객체를 얻어야 함  Calendar cal = new Calendar(); // ERROR! 추상 클래스 객체 생성 불가  Calendar cal = Calendar.getInstance();          이렇게 호출하면 Calendar 클래스를 구현한 클래스의 인스턴스를 반환      우리는 ① 서양력 ② 불교력 ③ 일본력 中 ① 서양력을 사용      그래서 getInsance()로 호출하면 GregorianCalendar 클래스의 인스턴스 반환        Calendar cal new GregorianCalendar(); 이렇게 호출하지 않는 이유          특정 Calendar 클래스를 지정해서 호출하면,      사용자가 다른 Calendar를 사용하게 될 때, 호출한 부분을 수정해야 함      그래서 Calendar cal = Calendar.getInstance();와 같이      상황에 따라 알맞는 Calendar를 반환 하는 코드가 좋은 것      Ch10 - 3. Calendar 클래스 예제1▶ get()는?▷ get()로 날짜와 시간 필드 가져올 수 있음int get(int field)▷ set()로 날짜와 시간 필드를 변경할 수 있음▶ 실습▷ getInstance()Calendar cal = Calendar.getInstance();현재 날짜와 시간으로 세팅▷ 올해의 년도?int thisYear = cal.get(Calendar.YEAR);// console2021▷ 이 달의 마지막 날?int lastDayOfMonth = cal.getActualMaximum(Calendar.DATE);// console31▶ Calendar에 정의 된 필드1 : 날짜 관련▷ YEAR : 년도int thisYear = cal.get(Calendar.YEAR);// console2021▷ MONTH : 월(0부터 시작) → ‘0’이 있기 때문에 -1 해 주어야 함(7월 = 6월)int thisMonth = cal.get(Calendar.MONTH);// console6▷ WEEK_OF_MONTH : 그 달의 1일 부터 현재까지가 몇 번째 주인지int thisWeekOfMonth = cal.get(Calendar.WEEK_OF_MONTH);// console4▷ WEEK_OF_YEAR : 1월 1일 부터 현재까지가 몇 번째 주인지int thisWeekOfYear = cal.get(Calendar.WEEK_OF_YEAR);// console30▷ DATE : 일int thisDate = cal.get(Calendar.DATE);// console22▷ DAY_OF_MONTH : 그 달의 몇 번째 일인지int thisDayOfMonth = cal.get(Calendar.DAY_OF_MONTH);// console22▷ DAY_OF_YEAR : 그 해의 몇 번째 일인지int thisDayOfYear = cal.get(Calendar.DAY_OF_YEAR);// console203▷ DAY_OF_WEEK : 요일(1-일, 2-월, 3-화, 4-수, 5-목, 6-금, 7-토)int thisDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);// console5▷ DAY_OF_WEEK_IN_MONTH : 그 달의 몇 번째 요일인지int thisDayOfWeekInMonth = cal.get(Calendar.DAY_OF_WEEK_IN_MONTH);// console4▶ Calendar에 정의 된 필드2 : 시간 관련▷ HOUR : 시간(0~11)int thisHour = cal.get(Calendar.HOUR);// console8▷ HOUR_OF_DAY : 시간(0~23)int thisHourOfDay = cal.get(Calendar.HOUR_OF_DAY);// console20▷ MINUTE : 분int thisMinute = cal.get(Calendar.MINUTE);// console50▷ SECOND : 초int thisSecond = cal.get(Calendar.SECOND);// console12▷ MILLISECOND : 1/1000초int thisMilliSecond = cal.get(Calendar.MILLISECOND);// console181▷ ZONE_OFFSET : GMT기준 시차(1/1000초 단위) - 한국은 GMT + 9int thisZoneOffset = cal.get(Calendar.ZONE_OFFSET);// console32400000▷ AM_PM : 오전_오후int thisAmPm = cal.get(Calendar.AM_PM);// console1",
        "url": "/10cornerstoneJava1"
    }
    ,
    
    "9cornerstonejava10": {
        "title": "Ch9-28~31. 문자열 → 숫자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 28. 문자열을 숫자로 변환하기  Ch9 - 29. 문자열을 숫자로 변환하기 예제  Ch9 - 30. 오토박싱 &amp; 언박싱  Ch9 - 31. 오토박싱 &amp; 언박싱 예제Ch9 - 28. 문자열을 숫자로 변환하기▶ 문자열 → 숫자 변환하는 다양한 방법▷ Integer → int  int i1 = new Integer(\"100\").intValue();  int i2 = Integer.parseInt(\"100\");  Integer i3 = Integer.valueOf(\"100\");▶ 문자열 → 기본형 &amp; 문자열 → 래퍼 클래스 변환하는 다양한 방법Ch9 - 29. 문자열을 숫자로 변환하기 예제▶ n진법 문자열 → 숫자 변환▷ 2진수, 8진수, 10진수, 16진수 다양한 방법으로 변환int i = Integer.parseInt(\"100\");int i1 = Integer.parseInt(\"100\", 2);int i2 = Integer.parseInt(\"100\", 8);int i3 = Integer.parseInt(\"100\", 16);int i4 = Integer.parseInt(\"FF\", 16);int i5 = Integer.parseInt(\"FF\");// console100 // i 10진수, 아무것도 적지 않으면 10진수4   // i1 2진수64  // i2 8진수256 // i3 16진수255 // i4 16진수에서 FF = 255NumberFormatException 발생 // i5 10진수에 FF없음Ch9 - 30. 오토박싱 &amp; 언박싱▶ 오토박싱(AutoBboxing)이란?▷ int → Integer▷ 즉 기본형 → 래퍼 클래스 변환하는 것▷ jdk1.5 이전에는 기본형과 참조형 간의 연산이 불가능  jdk1.5 이전      int i = 5;  Integer iObj = new Integer(7);      int sum = i + iObj; // ERROR! 기본형 + 참조형 덧셈 불가        jdk1.5 이후  기본형-참조형 연산 : 컴파일 자동 형변환      int i = 5;  Integer iObj = new Integer(7);      int sum = i + iObj.intValue(); // 오토박싱, 기본형을 Integer로 감싸줌      ▶ 언박싱이란?▷ int ← Integer▷ 즉 기본형 ← 래퍼 클래스 변환하는 것  jdk1.5 이후      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // Integer만 들어갈 수 있는 배열  List.add(10); // Integer만 들어갈 수 있는데? → 오토박싱 → list.add(new Integer(10));      int value = list.get(0); // Integer를 int로 받고싶다고 바로 int value라고 작성 → 언박싱 → Integer intValue() 해 줌          Ch9 - 31. 오토박싱 &amp; 언박싱 예제▶ 기본형과 참조형 간의 자동 변환▷ 컴파일 전int i = 10;Integer intg = (Integer)i; Object obj = (Object)i;Long lng = 100L;int i2 = intg + 10;long l = intg + lng;▷ 컴파일 후int i = 10;Integer intg = Integer.valueOf(i); // int → Integer 오토박싱Object obj = (Object)Integer.valueOf(i); // int → Object 오토박싱Long lng = new Long(100L); // Long → long 언박싱int i2 = intg + 10; // Integer + intlong l = intg + lng; // Integer + long",
        "url": "/9cornerstoneJava10"
    }
    ,
    
    "9cornerstonejava9": {
        "title": "Ch9-25~27. wrapper 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 25. 래퍼(wrapper) 클래스  Ch9 - 26. 래퍼(wrapper) 클래스 예제  Ch9 - 27. Number 클래스Ch9 - 25. 래퍼(wrapper) 클래스▶ 래퍼(wrapper) 클래스란?▷ 기본형 값을 감싸는 클래스▷ 8개의 기본형을 객체로 다뤄야 할 때 사용하는 클래스  Integer code      public final class Integer extends Number implements Comparable {      ...      private int value; // Integer가 int(기본형)를 감싸고 있음      ...  }      ▶ 기본형이 나오게 된 배경▷ 객체지향언어 : 모두 객체가 되는 걸 지향▷ 근데 기본형은 객체가 아님▷ 왜? 성능 문제 때문▶ boolean 래퍼 클래스▷ Boolean  Boolean(boolean value)  Boolean(String s)      Boolean b1 = new Boolean(true)  Boolean b2 = new Boolean(\"true\")          ▶ char 래퍼 클래스▷ Character  Character(char value)      Character c = new Character('a')          ▶ byte 래퍼 클래스▷ Byte  Byte(byte value)  Byte(String s)    Byte b1 = new Byte(10)Byte b2 = new Byte(\"10\")          ▶ short 래퍼 클래스▷ Short  Short(boolean value)  Short(String s)    Short b1 = new Short(10)Short b2 = new Short(\"10\")          ▶ int 래퍼 클래스▷ Integer  Integer(int value)  Integer(String s)    Integer i1 = new Integer(100)Integer b2 = new Integer(\"100\")          ▶ long 래퍼 클래스▷ Long  Long(long value)  Long(String s)    Long b1 = new Long(100)Long b2 = new Long(\"100\")          ▶ float 래퍼 클래스▷ Float  Float(double value)  Float(float value)  Float(String s)    Float f1 = new Float(1.0)Float f2 = new Float(1.0f)Float f2 = new Float(\"1.0f\")          ▶ double 래퍼 클래스▷ Double  Double(double value)  Double(String s)    Double b1 = new Double(1.0)Double b2 = new Double(\"1.0\")          Ch9 - 26. 래퍼(wrapper) 클래스 예제▶ Integer i  = new Integer();▷ ==Integer i1  = new Integer(100);Integer i2 = new Integer(100);System.out.println(i1==i2);// consolefalsei1@0x100 → 100i2@0x200 → 1000x100 ≠ 0x200▷ equals()Integer i1  = new Integer(100);Integer i2 = new Integer(100);System.out.println(i1.equals(i2));// consoletruei1@0x100 → 100i2@0x200 → 100100 ≠ 100▷ equals()Integer i1  = new Integer(100);Integer i2 = new Integer(100);System.out.println(i1.equals(i2));// consoletruei1@0x100 → 100i2@0x200 → 100100 = 100▷ compareTo()Integer i1  = new Integer(100);Integer i2 = new Integer(100);System.out.println(i1.compareTo(i2));// console0i1@0x100 → 100i2@0x200 → 100100 = 100  compareTo()          i1 = i2 → 0      i1 &gt; i2 → + 양수      i1 &lt; i2 → - 음수      ▷ toString()Integer i1  = new Integer(100);Integer i2 = new Integer(100);System.out.println(i1.toString(i2));// console\"100\"int 100 -to→ String \"100\"▷ …System.out.println(\"MAX_VALUE : \" + Integer.MAX_VALUE);System.out.println(\"MIN_VALUE : \" + Integer.MIN_VALUE);System.out.println(\"SIZE : \" + Integer.SIZE + \" bits\");System.out.println(\"BYTES : \" + Integer.BYTES + \" bytes\");System.out.println(\"TYPE : \" + Integer.TYPE);// consoleMAX_VALUE : 2147483647MIN_VALUE : -2147483648SIZE : 32 bitsBYTES : 4 bytesTYPE : intCh9 - 27. Number 클래스▶ Number 클래스란?▷ 모든 숫자 래퍼 클래스의 조상  Numer class code    public abstract class Number implements java.io.Serializable { // 추상 클래스public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() {  return (byte)intValue();}public short shortValue() {  return (short)intValue();}}        래퍼 객체 → 기본형 역할을 하는 메서드를 가진 Number 클래스  ex) new Integer(100) → int 100?    intValue() 사용",
        "url": "/9cornerstoneJava9"
    }
    ,
    
    "9cornerstonejava8": {
        "title": "Ch9-21~24. Math",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 21. StringBuilder  Ch9 - 22. Math 클래스  Ch9 - 23. Math의 메서드  Ch9 - 24. Math의 메서드 예제Ch9 - 21. StringBuilder▶ StringBuilder란?▷ StringBuilder ≒ StringBuffer▶ StringBuilder와 StringBuffer의 차이점▷ StringBuilder : 동기화X - 싱글 쓰레드 프로그램▷ StringBuffer : 동기화O - 멀티 쓰레드 프로그램▷ 동기화 : 멀티 쓰레드에 안전하게 하는 것(thread-safe)  싱글 쓰레드 : 한 번에 한 개의 작업  ex) 채팅창에서 파일 다운을 받는 동안은 채팅 못함  멀티 쓰레드 : 한 번에 n개의 작업  ex) 채팅창에서 파일 다운을 받는 동안 채팅 동시 진행 가능  멀티 쓰레드의 단점          여러 명이서 데이터 공유      데이터를 공유하다가 데이터가 손상 될 수 있음      이 때 데이터를 보호 해 주는 것이 동기화      ▷ 멀티 쓰레드 프로그램이 아닌 경우, 동기화는 불필요 → 오히려 성능 저하▷ 이럴 때 StringBuffer 대신 StringBuilder 사용하면 성능 향상  멀티 쓰레드 프로그램      StringBuffer sb;  sb = new StringBuffer();  sb.append(\"abc\");        싱글 쓰레드 프로그램으로 변경      StringBuilder sb; // StringBuffer → StringBuilder  sb = new StringBuilder(); // StringBuffer → StringBuilder  sb.append(\"abc\");        StringBuffer → StringBuilder만 바꿔주고 다른 건 바꾸지 않아도 됨  Ch9 - 22. Math 클래스▶ Math 클래스란?▷ 수학관련 static 메서드의 집합▷ static : 객체 생성 없이 사용 가능▶ Math.round()로 소수점 아래 세 번째 자리에서 반올림▷ 원래 값에 ×10090.7552 * 100// console9075.52▷ Math.round()사용 : 소수점 아래 첫자리에서 반올림Math.round(9075.52)// console9076▷ 다시 100.0으로 나눔9076 / 100.0 // int ÷ double = double// console90.76 // double9076 / 100 // int ÷ int = int// console90 // intCh9 - 23. Math의 메서드▶ static double abs(double d)▶ static float abs(float f)▶ static int abs(int i)▶ static long abs(long l)▷ 주어진 값의 절대값을 반환▷ 양수 → 양수▷ 음수 → 양수int i = Math.abs(-10);double d = Math.abs(-10.0);// console10 // i10.0 // d▶ static double ceil(double d)▷ ceil : 천장 → 숫자 올라감▷ 주어진 값을 올림하여 반환▷ 올림▷ 반올림 아님 주의!double d1 = Math.ceil(10.1);double d2 = Math.ceil(-10.1);double d3 = Math.ceil(10.000000015);// console11.0  // d1 10.1-10.0 // d2 -10.1, -11 아님 주의!11.0  // d3 10.000000015▶ static double floor(double d)▷ ceil : 바닥 → 숫자 내려감▷ 주어진 값을 버림하여 반환double d1 = Math.floor(10.9);double d2 = Math.floor(-10.9);// console10.0  // d1 10.9-11.0 // d2 -10.9, -10 아님 주의!▶ static double max(double d, double d2)▶ static float max(float f, float f2)▶ static int max(int i, int i2)▶ static long max(long l, long l2)▷ 주어진 두 값을 비교하여 큰 쪽을 반환double d = Math.max(10.9, 10.555555503);int i = Math.max(0, -1);// console10.9 // d0 // i▶ static double min(double d, double d2)▶ static float min(float f, float f2)▶ static int min(int i, int i2)▶ static long min(long l, long l2)▷ 주어진 두 값을 비교하여 작은 쪽을 반환double d = Math.min(10.9, 10.555555503);int i = Math.min(0, -1);// console10.555555503 // d-1 // i▶ static double random()▷ 0.0 ≤ 범위 &lt; 1.0 범위에서▷ 임의의 double 값을 반환double d = Math.random(); // 0.0 ≤ d &lt; 1.0 → 0.0 ~ 0.999999999999999...int i = (int)(Math.random() * 10) + 1; // (int)(0.0*10) + 1 ≤ i &lt; (int)(1.0*10) + 1 → 1 ~ 10// console0.05974693674939824 // d7 // i▶ static double rint(double d)▷ 주어진 double 값과 가장 가까운 정수 값을 double로 반환▷ 단, 두 정수의 가운데 있는 값▷ 1.5, 2.5, 3.5 등은▷ 짝수를 반환double d1 = Math.rint(1.2);double d2 = Math.rint(2.6);double d3 = Math.rint(3.5);double d4 = Math.rint(4.5);// console1.03.04.04.0▶ static long round(double d)▶ static long round(float f)▷ 소수점 첫째 자리에서 반올림한 정수 값(long)을 반환▷ 두 정수의 가운데 있는 값은 항상 큰 정수를 반환▷ round() ≠ rint()long l1 = Math.round(1.2);long l2 = Math.round(2.6);long l3 = Math.round(3.7);long l4 = Math.round(4.5);// console1345Ch9 - 24. Math의 메서드 예제▶ round() vs rint()▷ round()와 rint() 반올림 : 0.0 ~ 2.0public static void main(String[] args) {    for (double d = 0.0; d &lt;= 2.0; d += 0.1) {        double d1 = Math.round(d);        double d2 = Math.rint(d);// consoled_round_rint0.0  0.0  0.00.1  0.0  0.00.2  0.0  0.00.3  0.0  0.00.4  0.0  0.00.5  1.0  0.0 // round() ≠ rint()0.6  1.0  1.00.7  1.0  1.00.8  1.0  1.00.9  1.0  1.01.0  1.0  1.01.1  1.0  1.01.2  1.0  1.01.3  1.0  1.01.4  1.0  1.01.5  2.0  2.0 // round() = rint()1.6  2.0  2.01.7  2.0  2.01.8  2.0  2.01.9  2.0  2.0▷ 왜 다를까?0.5  1.0  0.0 // round() ≠ rint()1.5  2.0  2.0 // round() = rint()▷ round()와 rint() 반올림 : 1.5 ~ 10.5 d_round_rint 1.5  2.0  2.0 2.5  3.0  2.0 // round() ≠ rint() 3.5  4.0  4.0 4.5  5.0  4.0 // round() ≠ rint() 5.5  6.0  6.0 6.5  7.0  6.0 // round() ≠ rint() 7.5  8.0  8.0 8.5  9.0  8.0 // round() ≠ rint() 9.5 10.0 10.010.5 11.0 10.0 // round() ≠ rint()▷ 정수의 가운데(_.5)에서 round()와 rint() 반올림 차이▷ 반올림에도 종류가 다양      round() : HALF_UP무조건 올림        rint() : round eveneven : 짝수짝수가 나오면 올려줌  ▷ 정확도 = rint() &gt; round()public static void main(String[] args) {  double sum = 0;  double sum1 = 0;  double sum2 = 0;    for (double d = 1.5; d &lt;= 10.5; d++) {    double d1 = Math.round(d);    double d2 = Math.rint(d);    sum += d;  sum1 += d1;  sum2 += d2;}// console d_round_rint 1.5  2.0  2.0 2.5  3.0  2.0 3.5  4.0  4.0 4.5  5.0  4.0 5.5  6.0  6.0 6.5  7.0  6.0 7.5  8.0  8.0 8.5  9.0  8.0 9.5 10.0 10.010.5 11.0 10.0--- d_round_rint60.0 65.0 60.0",
        "url": "/9cornerstoneJava8"
    }
    ,
    
    "9cornerstonejava7": {
        "title": "Ch9-19~20. StringBuffer",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 19. StringBuffer의 생성자와 메서드  Ch9 - 20. StringBuffer의 생성자와 메서드 예제Ch9 - 19. StringBuffer의 생성자와 메서드▶ StringBuffer()▷ 16문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스 생성StringBuffer sb = new StringBuffer();// console\"\"sb : [][][][][][][][][][][][][][][][] // char[16]▶ StringBuffer(int length)▷ 지정 된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스 생성StringBuffer sb = new StringBuffer(10);// console\"\"sb : [][][][][][][][][][] // char[10]▶ StringBuffer(String str)▷ 지정 된 문자열 값(str)을 갖는 StringBuffer 인스턴스 생성StringBuffer sb = new StringBuffer(\"Hi\");// consoleHisb : [H][i][][][][][][][][][][][][][][][][] // char[2 + 16]▶ StringBuffer append(boolean b)▶ StringBuffer append(char ch)▶ StringBuffer append(char[] str)▶ StringBuffer append(double d)▶ StringBuffer append(float f)▶ StringBuffer append(int i)▶ StringBuffer append(long l)▶ StringBuffer append(Object obj)▶ StringBuffer append(String str)▷ 반환 타입 : StringBuffer → 자기 자신을 반환▷ 매개변수로 입력 된 값을 문자열로 변환▷ StringBuffer 인스턴스가 저장하고 있는 문자열의 뒤에 덧붙임StringBuffer sb1 = new StringBuffer(\"AAA\");StringBuffer sb2 = sb1.append(true);sb1.append('d').append(10.0f);StringBuffer sb3 = sb1.append(\"BBB\").append(123);// consoleAAAtrued10.0BBB123 // sb1AAAtrued10.0BBB123 // sb2AAAtrued10.0BBB123 // sb3sb1 : [A][A][A][][][][][][][][][][][][][][][][]sb1,sb2 : [A][A][A][t][r][u][e][][][][][][][][][][][][]sb1,sb2 : [A][A][A][t][r][u][e][d][][][][][][][][][][][]sb1,sb2 : [A][A][A][t][r][u][e][d][1][0][.][0][][][][][][][]sb1,sb2,sb3 : [A][A][A][t][r][u][e][d][1][0][.][0][B][B][B][][][][]sb1,sb2,sb3 : [A][A][A][t][r][u][e][d][1][0][.][0][B][B][B][1][2][3][]▶ int capacity()▷ StringBuffer 인스턴스의 버퍼 크기(char[] 개수)를 반환StringBuffer sb = new StringBuffer(100);sb.append(\"AAAAA\");int bufferSize = sb.capacity();// console100sb : [A][A][A][A][A][][][][][][][][][][][][][][]...[][][][][] // [] 총 개수 : 100개▶ int length()▷ StringBuffer 인스턴스의 버퍼에 담긴 문자열의 길이를 반환StringBuffer sb = new StringBuffer(100);sb.append(\"AAAAA\");int bufferLength = sb.length();// console5sb : [A][A][A][A][A][][][][][][][][][][][][][][]...[][][][][] // [A] 개수 : 5개▶ char charAt(int index)▷ 지정 된 위치(index)에 있는 문자를 반환StringBuffer sb = new StringBuffer(\"ABC\");char ch = sb.charAt(2);// consoleCsb : [A][B][C][][][][][][][][][][][][][][][][]▶ StringBuffer delete(int begin, int end)▷ 시작 위치(begin)에서 끝 위치(end) 사이에 있는 문자를 제거▷ begin ≤ 범위 &lt; endStringBuffer sb1 = new StringBuffer(\"0123456\");StringBuffer sb2 = sb1.delete(3, 6); // 3 ≤ 범위 &lt; 6, 3 ~ 5// console0126 // sb10126 // sb2sb1 : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb1,sb2 : [0][1][2][][][][6][][][][][][][][][][][][] // delete(3, 6)sb1,sb2 : [0][1][2][6][][][][][][][][][][][][][][][] // 삭제 된 자리는 앞 당겨 채워넣음▶ StringBuffer deleteCharAt(int index)▷ 지정 된 위치(index)의 문자만 제거StringBuffer sb = new StringBuffer(\"0123456\");sb.deleteCharAt(3);// console012456sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb : [0][1][2][][4][5][6][][][][][][][][][][][][] // deleteCharAt(3);sb : [0][1][2][4][5][6][][][][][][][][][][][][][] // 삭제 된 자리는 앞 당겨 채워넣음▶ StringBuffer insert(int pos, boolean b)▶ StringBuffer insert(int pos, char ch)▶ StringBuffer insert(int pos, char[] str)▶ StringBuffer insert(int pos, double d)▶ StringBuffer insert(int pos, float f)▶ StringBuffer insert(int pos, int i)▶ StringBuffer insert(int pos, long l)▶ StringBuffer insert(int pos, Object obj)▶ StringBuffer insert(int pos, String str)▷ append()는 맨 끝에 추가하는 거라서 위치 지정 필요 없음▷ insert()는 위치 지정 필요▷ 반환 타입 : StringBuffer → 자기 자신을 반환▷ 두 번째 매개변수로 받은 값을 문자열로 변환하여▷ 지정 된 위치(pos)에 추가▷ pos는 0부터 시작StringBuffer sb = new StringBuffer(\"0123456\");sb.insert(4, '#');// console0123#456sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb : [0][1][2][3][][4][5][6][][][][][][][][][][][] // insert(4, '#'), char[4] 방 뺌sb : [0][1][2][3][#][4][5][6][][][][][][][][][][][] // insert(4, '#'), char[4] # 넣음▶ StringBuffer replace(int begin, int end, String str)▷ 시작 위치(begin)에서 끝 위치(end) 사이에 있는 문자들을▷ 주어진 문자열(str)로 바꿈▷ begin ≤ 범위 &lt; endStringBuffer sb = new StringBuffer(\"0123456\");sb.replace(3, 6, \"AB\"); // 3 ~ 5// console012AB6sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb : [0][1][2][][][][6][][][][][][][][][][][][] // replace(3, 6, \"AB\"), char[3 ~ 5] 방 뺌sb : [0][1][2][A][B][][6][][][][][][][][][][][][] // replace(3, 6, \"AB\"), char[3 ~ 5] AB 넣음sb : [0][1][2][A][B][6][][][][][][][][][][][][][] // 삭제 된 자리는 앞 당겨 채워넣음▶ StringBuffer reverse()▷ StringBuffer 인스턴스에 저장되어 있는 문자열의 순서를 거꾸로 나열StringBuffer sb = new StringBuffer(\"0123456\");sb.reverse();// console6543210sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb : [6][1][2][3][4][5][0][][][][][][][][][][][][] // 끝 ↔ 끝sb : [6][5][2][3][4][1][0][][][][][][][][][][][][] // 끝-1 ↔ 끝-1sb : [6][5][4][3][2][1][0][][][][][][][][][][][][] // 끝-2 ↔ 끝-2, 홀수라서 짝이 없는 가운데 멤버는 가만 둠▶ StringBuffer setCharAt(int index, char ch)▷ 지정 된 위치(index)의 문자를 주어진 문자(ch)로 바꿈StringBuffer sb = new StringBuffer(\"0123456\");sb.setCharAt(5, 'A');// console01234A6sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb : [0][1][2][3][4][][6][][][][][][][][][][][][] // setCharAt(5, 'A'), char[5] 방 뺌sb : [0][1][2][3][4][A][6][][][][][][][][][][][][] // setCharAt(5, 'A'), char[5] A 넣음▶ void setLength(int newLength)▷ 지정 된 길이(newLength)로 길이를 변경▷ 길이를 늘리는 경우에, 나머지 빈 공간을 char의 초기값 \\u0000을 채움StringBuffer sb1 = new StringBuffer(\"0123456\");sb1.setLength(5);StringBuffer sb2 = new StringBuffer(\"0123456\");sb2.setLength(10);String str = sb2.toString().trim();// consolesb1 : 01234sb2 : 0123456str : 0123456sb1 : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb1 : [0][1][2][3][4][][][][][][][][][][][][][][] // setLength(5), char[5] 까지만 문자열 살림sb2 : [0][1][2][3][4][5][6][][][][][][][][][][][][]sb2 : [0][1][2][3][4][5][6][\\u0000][\\u0000][\\u0000][][][][][][][][][] // setLength(10), char[10] 까지 초기값 \\u0000 채움sb2,str : [0][1][2][3][4][5][6][\\u0000][\\u0000][\\u0000][][][][][][][][][]str : [0][1][2][3][4][5][6][][][][][][][][][][][][] // sb2.toString().trim(), trim()으로 양 끝의 \\u0000 잘라내기▶ String toString()▷ StringBuffer 인스턴스의 문자열을 String으로 반환▷ StringBuffer → StringStringBuffer sb = new StringBuffer(\"0123456\");String str = sb.toString();// console\"0123456\"▶ String substring(int begin)▶ String substring(int begin, int end)▷ 반환 타입 : String → 일부를 뽑아서 StringBuffer를 String으로 반환▷ int end 생략 시, begin ~ 끝▷ int end 작성 시, begin ≤ 범위 &lt; end▷ 지정 된 범위 내의 문자열을 String으로 뽑아서 반환StringBuffer sb = new StringBuffer(\"0123456\");String str1 = sb.substring(3); // 3 ~ 끝String str2 = sb.substring(3, 5); // 3 ~ 4// consolestr1 : 3456str2 : 34sb : [0][1][2][3][4][5][6][][][][][][][][][][][][]str1 : [][][][3][4][5][6][][][][][][][][][][][][] // substring(3), char[3 ~ 끝]만 남기고 다 없애기str1 : [3][4][5][6][][][][][][][][][][][][][][][] // 삭제 된 자리는 앞 당겨 채워넣음str2 : [][][][3][4][][][][][][][][][][][][][][] // substring(3, 5), char[3 ~ 4]만 남기고 다 없애기str2 : [3][4][][][][][][][][][][][][][][][][][] // 삭제 된 자리는 앞 당겨 채워넣음Ch9 - 20. StringBuffer의 생성자와 메서드 예제▶ append()public static void main(String[] args) {    StringBuffer sb = new StringBuffer(\"01\");    StringBuffer sb2 = sb.append(23);    sb.append('4').append(56);        StringBuffer sb3 = sb.append(78);\t\t\t    sb3.append(9.0);// consolesb = 0123456789.0sb2 = 0123456789.0sb3 = 0123456789.0sb : [0][1][][][][][][][][][][][][][][][][]sb,sb2 : [0][1][2][3][][][][][][][][][][][][][][]sb,sb2 : [0][1][2][3][4][5][6][][][][][][][][][][][]sb,sb2,sb3 : [0][1][2][3][4][5][6][7][8][][][][][][][][][]sb,sb2,sb3 : [0][1][2][3][4][5][6][7][8][9][.][0][][][][][][]▶ deleteCharAt(),delete(),insert(),replace()    System.out.println(\"sb = \"+sb);    System.out.println(\"sb2 = \"+sb2);    System.out.println(\"sb3 = \"+sb3);        System.out.println(\"sb = \"+sb.deleteCharAt(10));    System.out.println(\"sb = \"+sb.delete(3,6));    System.out.println(\"sb = \"+sb.insert(3,\"abc\"));    System.out.println(\"sb = \"+sb.replace(6, sb.length(), \"END\"));    // consolesb = 01234567890sb = 01267890sb = 012abc67890sb = 012abcENDsb : [0][1][2][3][4][5][6][7][8][9][.][0][][][][][][]sb : [0][1][2][3][4][5][6][7][8][9][][0][][][][][][] // deleteCharAt(10)sb : [0][1][2][3][4][5][6][7][8][9][0][][][][][][][]sb : [0][1][2][3][4][5][6][7][8][9][0][][][][][][][]sb : [0][1][2][][][][6][7][8][9][0][][][][][][][] // delete(3,6)sb : [0][1][2][6][7][8][9][0][][][][][][][][][][] sb : [0][1][2][][6][7][8][9][0][][][][][][][][][]sb : [0][1][2][a][b][c][6][7][8][9][0][][][][][][][] // insert(3,\"abc\")sb : [0][1][2][a][b][c][6][7][8][9][0][][][][][][][]sb : [0][1][2][a][b][c][][][][][][][][][][][][] // replace(6, sb.length())sb : [0][1][2][a][b][c][E][N][D][][][][][][][][][] // replace(6, sb.length(), \"END\")▶ capacity(), length()    System.out.println(\"capacity = \"+sb.capacity());    System.out.println(\"length = \"+sb.length());}// consolecapacity = 18length = 9sb : [0][1][2][a][b][c][E][N][D][][][][][][][][][] // 처음 StringBuffer(\"01\"), char[2 + 16]sb : [0][1][2][a][b][c][E][N][D][][][][][][][][][] // 012abcEND 총 9개",
        "url": "/9cornerstoneJava7"
    }
    ,
    
    "9cornerstonejava6": {
        "title": "Ch9-15~18. StringBuffer",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 15. StringBuffer 클래스  Ch9 - 16. StringBuffer의 생성자  Ch9 - 17. StringBuffer의 변경  Ch9 - 18. StringBuffer의 비교Ch9 - 15. StringBuffer 클래스▶ StringBuffer 클래스란?▷ 문자열을 저장하고 다루기 위한 클래스▷ String처럼 문자형(char[])을 내부적으로 가짐  StringBuffer code      public final class StringBuffer implements java.io.Serializable {      private char[] value;          ...  }      ▷ String : 내용 변경 불가 ↔ StringBuffer : 내용 변경 가능Ch9 - 16. StringBuffer의 생성자▶ StringBuffer의 생성자란?▷ 배열은 길이 변경 불가▷ 그래서 공간 부족 시, 배열을 새로 생성해야 함▷ 새로운 배열을 생성하면?  배열 생성  기존 배열의 내용 복사  참조 주소 변경결국 성능 저하▷ StringBuffer는 저장 할 문자열의 길이를 고려하여 적절한 크기로 생성public StringBuffer(int length) { // length : 적잘한 크기    value = new char[length];    shared = false;}▷ StringBuffer의 크기를 지정하지 않으면, 크기는 자동 16이 됨public StringBuffer() {    this(16);}▷ 지정한 문자열의 길이보다 16이 더 크게 버퍼를 생성public StringBuffer() {    this(str.length() + 16); // str = \"abc\" 즉 length = 3, 3 + 16짜리가 만들어짐    append(str)}Ch9 - 17. StringBuffer의 변경▶ StringBuffer의 변경이란?▷ StringBuffer는 String과 달리 내용 변경이 가능  StringBuffer가 가진 메서드…          append() : 추가      delete() : 삭제      insert() : 삽입        메서드의 반환 타입 : StringBuffer            ▷ StringBuffer의 메서드는 내용 수행 후, StringBuffer의 참조를 반환Ch9 - 18. StringBuffer의 비교▶ StringBuffer의 비교란?▷ StringBuffer는 equals()가 오버라이딩 되어있지 않음  StringBuffer : 주소 비교▷ String은 equals()가 오버라이딩 되어있음  String :  내용 비교▷ StringBuffer를 String으로 변환 후 equals()로 비교 : 내용 비교String s = sb.toString();String s1 = sb2.toString();System.out.println(s.equals(s1));// consoletrue",
        "url": "/9cornerstoneJava6"
    }
    ,
    
    "9cornerstonejava5": {
        "title": "Ch9-12~14. join()",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 12. join()과 StringJoiner  Ch9 - 13. 문자열과 기본형 간의 변환  Ch9 - 14. 문자열과 기본형 간의 변환 예제Ch9 - 12. join()과 StringJoiner▶ join()이란?▷ static join()▷ join()은 여러 문자열 사이에 구분자를 넣어서 결합String animals = \"dog,cat,bear\";String[] arr = animals.split(\",\");String str = String.join(\"-\", arr); // - : 구분자// console[arr0 : dog][arr1 : cat][arr2 : bear][StringJoiner : dog-cat-bear]Ch9 - 13. 문자열과 기본형 간의 변환▶ 숫자를 문자열로 바꾸는 방법▷ 숫자 + “”int i = 100;String str1 = i + \"\";// console\"100\"▷ String valueOf()int i = 100;String str2 = String.valueOf(i);// console\"100\"속도 높이고 싶을 때, valueOf() 사용▶ 문자열을 숫자로 바꾸는 방법▷ Integer parseInt()int i1 = Integer.parseInt(\"100\");// console100▷ Integer valueOf()int i2 = Integer.valueOf(\"100\");// console100▷ 반환타입 Integer인 Integer valueOf()Integer i3 = Integer.parseInt(\"100\");// console100  반환타입 Integer = 참조형  오토박싱 :  Integer → int 자동 형변환 해 줌  그래서 반환타입 Integer를 형변환 없이도 사용 가능Ch9 - 14. 문자열과 기본형 간의 변환 예제▶ 숫자 100 → 문자열 100▷ 숫자 + “”int i = 100;String iString = i + \"\";// console\"100\"▷ String valueOf()int i = 100;String iString = String.valueOf(i);// console\"100\"▶ 문자열 iString → 숫자 iStringInteger▷ Integer valueOf()int i = 100;String iString = String.valueOf(i);Integer iStringInteger = Integer.valueOf(iString);// console100▶ double d → 문자열 dString → double dStringDouble▷ double d → 문자열 dStringdouble d = 200.0;String dString = String.valueOf(d);// console\"200.0\"▷ 문자열 dString → double dStringDoubledouble d = 200.0;String dString = String.valueOf(d);Double dStringDouble = Double.valueOf(dString);// console200.0▶ dString - iString▷ String join()String join = String.join(\"-\", dString, iString);\t// console200.0-100",
        "url": "/9cornerstoneJava5"
    }
    ,
    
    "9cornerstonejava4": {
        "title": "Ch9-11. String 생성자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 11. String 클래스의 생성자와 메서드Ch9 - 11. String 클래스의 생성자와 메서드▶ String(String s)▷ 주어진 문자열(s)을 갖는 String 인스턴스를 생성▷ 사용 잘 하지 않음String s = new String(\"Hello\");// consoleHello▶ Stirng(char[] value)▷ 주어진 문자열(value)을 갖는 String 인스턴스를 생성▷ char[] → Stringchar[] c = {'H', 'e', 'l', 'l', 'o' };String s = new String(c);// consoleHello  char[] ← String은 어떻게?          tocharArray() 사용      ▶ String(StringBuffer sb)▷ StringBuffer 인스턴스가 갖고있는 문자열과 같은 내용의 String 인스턴스 생성▷ StringBuffer → StringStringBuffer sb = new StringBuffer(\"Hello\");String s = new String(sb);// consoleHello▶ char charAt(int index)▷ 지정된 위치(index)에 있는 문자를 알려 줌▷ index는 0부터 시작String s = \"Hello\";String n = \"0123456\";char c1 = s.charAt(1);char c2 = n.charAt(1);// consolee // c11 // c2▶ int compareTo(String str)▷ 문자열(str)과 사전순(Dictionary Order)으로 비교▷ 정렬int i1 = \"aaa\".compareTo(\"aaa\");int i2 = \"aaa\".compareTo(\"bbb\");int i3 = \"bbb\".compareTo(\"aaa\");// console0   // i1-1  // i21   // i3▶ String concat(String str)▷ 문자열(str)을 뒤에 덧붙임String s1 = \"Hello\";String s2 = s1.concat(\"World\");// consoleHelloWorld // s2▶ boolean contains(CharSequence s)▷ 지정된 문자열(s)이 포함되었는지 검사String s1 = \"abcde\";boolean s2 = s1.contains(\"ab\");// consoletrue // s2CharSequence를 구현한 클래스를 매개변수로 받으면 됨▶ boolean endSwith(String txt)▷ 지정된 문자열(txt)로 끝나는지 검사▷ endSwith ↔ startSwithString file = \"Hello txt\";boolean b = file.endsWith(\"txt\");// consoletrue // b▶ boolean equals(Object obj)▷ 매개변수로 받은 문자열(obj)과 String 인스턴스의 문자열 비교▷ obj가 String이 아니거나 문자열이 다르면 falseString s = \"Hello\";boolean b1 = s.equals(\"Hello\");boolean b2 = s.equals(\"hello\");// consoletrue  // b1false // b2▶ boolean equalsIgnoreCase(String str)▷ 문자열과 String 인스턴스의 문자열을 대소문자 구분없이 비교String s = \"Hello\";boolean b1 = s.equalsIgnoreCase(\"Hello\");boolean b2 = s.equalsIgnoreCase(\"hello\");// consoletrue // b1true // b2▶ int indexOf(int ch)▷ 주어진 문자(ch)가 문자열에 존재하는지 확인하여▷ 위치(index)를 알려줌▷ index에 없으면 -1을 반환▷ index는 0부터 시작String s = \"Hello\";int idx1 = s.indexOf('o');int idx2 = s.indexOf('k');// console4   // idx1-1  // idx2▶ int indexOf(int ch, int pos)▷ 주어진 문자(ch)가 문자열에 존재하는 지▷ 지정 된 위치(pos)부터 확인하여▷ 위치(index)를 알려줌▷ 못 찾으면 -1 반환▷ index는 0부터 시작String s = \"Hello\";int idx1 = s.indexOf('e', 0);int idx2 = s.indexOf('e', 2);// console1   // idx1-1  // idx2▶ int indexOf(String str)▷ 주어진 문자열이 존재하는 위치(index)를 알려줌▷ 주어진 문자열이 존재하지 않으면 -1을 반환▷ index는 0부터 시작String s = \"ABCDEFG\";int idx = s.indexOf(\"CD\");// console2▶ int lastIndexOf(int ch)▷ 지정된 문자 또는 문자 코드를 문자열의 오른쪽 끝에서부터 찾아▷ 위치(index)를 알려줌▷ 못 찾으면 -1을 반환String s = \"java.lang.Object\";int idx1 = s.lastIndexOf('.');int idx2 = s.indexOf('.');// console 9 // idx1 : lastIndexOf4 // idx2 : indexOf▶ int indexOf(String str)▷ 지정된 문자열을 인스턴스의 문자열 오른쪽 끝에서 부터 찾아서▷ 위치(index)를 알려줌▷ 못 찾으면 -1을 반환String s = \"java.lang.java\";int idx1 = s.lastIndexOf(\"java\");int idx2 = s.indexOf(\"java\");// console10 // idx10 // idx2▶ int length()▷ 문자열의 길이를 알려줌String s = \"Hello\";int length = s.length();// console5▶ String[] split(String regex)▷ regular Expresion▷ 문자열을 지정 된 분리자(regex)로 나누어▷ 문자열 배열에 담아 반환String animals = \"dog,cat,bear\";String[] arr = animals.split(\",\");// consoledog   // arr[0]cat   // arr[1]bear  // arr[2] ▶ String[] split(String regex, int limit)▷ 문자열을 지정 된 분리자(regex)로 나누어▷ 문자열 배열에 담아 반환▷ 단, 문자열 전체를 지정된 수(limit)로 자름String animals = \"dog,cat,bear\";String[] arr = animals.split(\",\", 2); // 2부분으로만 나눈다는 뜻// consoledog // arr[0]cat,bear // arr[1]▶ boolean startsWith(String prefix)▷ 주어진 문자열(prifix)로 시작하는 지 검사▷ startsWith ↔ endWithString s = \"java.lang.Object\";boolean b1 = s.startsWith(\"java\");boolean b2 = s.startsWith(\"lang\");// consoletrue  // b1false // b2▶ String substring(int begin)▶ String substring(int begin, int end)▷ int end 생략 시, int begin에서 index의 끝까지 출력▷ 주어진 시작 위치(begin)부터 끝 위치(end) 사이에 포함된 문자열을 얻음▷ 이 때 시작 위치의 문자는 범위에 포함되지만,▷ 끝 위치의 문자는 포함되지 않음▷ begin ≤ 범위 &lt; endString s = \"java.lang.Object\";String c = s.substring(10);String p = s.substring(5, 9);// consoleObject // clang // p▶ String toLowerCase()▷ String 인스턴스에 저장되어있는 모든 문자열을 소문자로 변환하여 반환String s = \"Hello\";String s1 = s.toLowerCase();// consolehello▶ String toUpperCase()▷ String 인스턴스에 저장되어있는 모든 문자열을 대문자로 변환하여 반환String s = \"Hello\";String s1 = s.toUpperCase();// consoleHELLO▶ String trim()▷ 문자열의 양쪽 끝에 있는 공백을 없앤 결과를 반환▷ 문자열의 중간에 있는 공백은 제거되지 않음String s = \"    Hello World    \";String s1 = s.trim();// consoleHello World▶ static String valueOf(boolean b)▶ static String valueOf(char ch)▶ static String valueOf(int i)▶ static String valueOf(long l)▶ static String valueOf(float f)▶ static String valueOf(double d)▶ static String valueOf(Object o)▷ 지정된 값을 String으로 변환하여 반환▷ 참조변수의 경우, toString()을 호출한 결과를 반환String booleanString = String.valueOf(true);String charString = String.valueOf('a');String intString = String.valueOf(100);String longString = String.valueOf(100L);String floatString = String.valueOf(10f);String doubleString = String.valueOf(10.0);java.util.Date dd = new java.util.Date();String deteString = String.valueOf(dd);// consoleboolean → String : \"true\"char → String : \"a\"int → String : \"100\"long → String : \"100\"float → String : \"10.0\"double → String : \"10.0\"dete → String : \"Wed Jul 21 23:24:51 KST 2021\"",
        "url": "/9cornerstoneJava4"
    }
    ,
    
    "9cornerstonejava3": {
        "title": "Ch9-7~10. String 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 7. String 클래스  Ch9 - 8. 문자열(String)의 비교  Ch9 - 9. 문자열 리터럴(String리터럴)  Ch9 - 10. 빈 문자열(empty string)Ch9 - 7. String 클래스▶ String 클래스란?▷ 문자열을 다루는 데 사용되는 클래스▷ String 클래스 = 데이터(char[] : 문자 배열) + (String 관련)메서드  String 클래스 code      public final class String implements java.io.Serializable, Comparable {      private char[] value; // private으로 문자 배열을 가짐      ... // 문자열과 관련된 메서드들이 있음  }      ▷ immutable class : 내용을 변경할 수 없는 불변 클래스▶ StringBuffer▷ StringBuffer : 내용 변경 가능, String처럼 불변X▷ 덧셈 연산자를 이용한 문자열 결합은 성능 저하▷ 저장 공간 하나에서 덧셈을 하는게 아니라, 계속 저장 공간을 만들어야 하니까▷ 이렇게 변경이 잦을 때, 내용 변경 가능한 StringBuffer 사용Ch9 - 8. 문자열(String)의 비교▶ String str = \"abc\" vs String str = new String(\"abc\")▷ String str = \"abc\"▷ String str = new String(\"abc\")항상 새로운 문자열이 만들어짐▶ == vs equals▷ == : 주소 비교▷ equals : 내용 비교String은 equals로 내용 비교!Ch9 - 9. 문자열 리터럴(String리터럴)▶ 문자열 리터럴은?▷ 프로그램 실행 시 자동으로 생성▷ new String(\"abc\")이렇게 안해도 자동 생성▷ constant pool(상수 저장소)에 저장▷ 리터럴 : 상수▷ string 객체 = 불변!▷ 같은 내용의 문자열 리터럴은 하나만 생성Ch9 - 10. 빈 문자열(empty string)▶ 빈 문자열(empty string)이란?▷ “”▷ 내용이 없는 문자열▷ 크기가 0인 char형 배열을 저장하는 문자열String str = \"\"; // str을 빈 문자열로 초기화▷ 크기가 0인 배열을 생성하는 것은 어느 타입이나 가능char[] chArr = new char[0]; // length가 0인 char배열int[] iArr = {}; // length가 0인 int배열  배열의 길이 vs 배열의 크기엄밀히 말하면 길이와 크기는 다름new int[10]          int = 4byte  4byte가 10개 = 4byte × 10 = 40byte                  길이(length) : 10          크기(size) : 40byte                    ▷ 문자(char)와 문자열(String)의 초기화  기본값(유니코드 첫번째 문자) : 거의 사용X    String s = null;char c = '\\u0000';         String : \"\" 빈 문자열  char : ' ' 공백    String s = \"\";char c = ' ';          ",
        "url": "/9cornerstoneJava3"
    }
    ,
    
    "9cornerstonejava2": {
        "title": "Ch9-4~6. Object 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 4. Object 클래스의 메서드 : hashCode()  Ch9 - 5. Object 클래스의 메서드 : toString()  Ch9 - 6. toString()의 오버라이딩Ch9 - 4. Object 클래스의 메서드 : hashCode()▶ hashCode()란?▷ 객체의 hashCode()를 반환하는 메서드▷ hashCode : 정수 값, 해싱 알고리즘에서 사용▷ Object 클래스의 hashCode()는 객체의 주소를 int로 변환하여 반환▷ hashCode() = 객체의 지문 : 객체마다 다른 값을 가지기 때문public class Object {    ...    public native int hashCode();}  native 메서드 : OS 메서드 - C언어로 작성          C언어로 작성 but hashCode()를 통해 java로 작성 된 것처럼 사용      JNI : 다른 언어로 작성 but java로 작성 된 것처럼 사용      ▶ equals() vs hashCode()▷ 처음엔 둘 다 객체의 주소를 이용▷ 그러나 equals()는 보통 iv를 가지고 이용하도록 오버라이딩 함▷ equals() 오버라이딩 → hashCode() 오버라이딩▷ 왜? equals() 결과가 true이면 → hashCode() 결과도 true!▷ equals()는 iv 비교하고 있는데 → hashCode()는 주소 비교하고 있으면▷ equals() == true → hashCode() == false▷ 그래서 equals()가 오버라이딩 하면 → hashCode()도 오버라이딩!String str1 = new String(\"abc\");String str2 = new String(\"abc\");System.out.println(str1.equals(str2));System.out.println(str1.hashCode());System.out.println(str2.hashCode());// consoletrue9635496354▶ System.identityHashCode(Object obj) = Object.hashCode()▷ System.identityHashCode(Object obj)도 객체의 주소 반환▷ 객체의 주소 = 서로 다름▷ 다른 값으로 반환 = System.identityHashCode 사용!System.out.println(System.identityHashCode(str1));System.out.println(System.identityHashCode(str2));// console1239611221227229563▶ 32bit JVM vs 64bit JVM▷ 32bit JVM = 4byte = int▷ 64bit JVM = 8byte = long▶ 64bit JVM에서 hashCode() 사용하면?▷ 64bit JVM : long에서 → hashCode() : int로 반환▷ 8byte(long)를 → 4byte(int)로 반환▷ 8byte를 → 반토막내서 반환▷ 그럼 해쉬코드가 겹칠 수도 있음  ex1) 11112222 → 반토막 → 2222  ex2) 33332222 → 반토막 → 2222Ch9 - 5. Object 클래스의 메서드 : toString()▶ toString()이란?▷ to String▷ 객체를 String(문자열)으로 변환하기 위한 메서드  Object 클래스의 toString    public String toString() {  // return 설계도객체.클래스 이름 at(@) 16진수 문자열(객체 주소);  return getClass().getName() + \"@\" + Integer.toHexString(hashCode());}      Ch9 - 6. toString()의 오버라이딩▶ toString()의 오버라이딩이란?▷ toString() : 객체(iv 집합)를 문자열(String)로 변환 = iv 값을 문자열로 변환▶ 실습▷ 오버라이딩 하지 않고 toString() 출력  클래스 이름 @위치 객체 주소      class Card {      String kind;      int number;          Card() {          this(\"SPADE\", 1);      }          Card(String kind, int number) {          this.kind = kind;          this.number = number;      }  }      class Ex9_4 {      public static void main(String[] args) {          Card c1 = new Card();          Card c2 = new Card();              System.out.println(c1.toString());          System.out.println(c2.toString());      }  }      // console  Card@2401f4c3  Card@7637f22      ▷ toString() 오버라이딩  iv인 kind와 number를 문자열로 바꾸어서 반환      class Card {      String kind;      int number;          Card() {          this(\"SPADE\", 1);      }          Card(String kind, int number) {          this.kind = kind;          this.number = number;      }              // Object 클래스의 toString() 오버라이딩      public String toString() {          return \"kind : \" + kind + \", number : \" + number;      }  }      class Ex9_4 {      public static void main(String[] args) {          Card c1 = new Card();          Card c2 = new Card();              System.out.println(c1.toString());          System.out.println(c2.toString());      }  }      // console  kind : SPADE, number : 1  kind : SPADE, number : 1      ▷ equals() 오버라이딩  객체 주소 비교 → iv 값 비교    class Card {    String kind;    int number;      Card() {        this(\"SPADE\", 1);    }      Card(String kind, int number) {        this.kind = kind;        this.number = number;    }          // Object 클래스의 toString() 오버라이딩    public String toString() {        return \"kind : \" + kind + \", number : \" + number;    }          // Object 클래스의 equals() 오버라이딩    public boolean equals(Object obj) {        if(!(obj instanceof Card))            return false;                  Card card = (Card)obj;        // kind는 String, String은 equals!, == 안됨        return this.kind.equals(card.kind) &amp;&amp; this.number == card.number;    }}  class Ex9_4 {    public static void main(String[] args) {        Card c1 = new Card();        Card c2 = new Card();          System.out.println(c1.equals(c2));                  System.out.println(c1.toString());        System.out.println(c2.toString());    }}  // consoletruekind : SPADE, number : 1kind : SPADE, number : 1      ▷ hashCode() 오버라이딩  equals() 오버라이딩 → hashCode() 오버라이딩  return Objects.hash(kind, number);          Objects : 객체와 관련된 유용한 메서드를 제공하는 유틸 클래스      (kind, number) : 매개변수가 가변인자라서 여러 개 호출 가능        class Card {    String kind;    int number;        Card() {        this(\"SPADE\", 1);    }        Card(String kind, int number) {        this.kind = kind;        this.number = number;    }            // Object 클래스의 toString() 오버라이딩    public String toString() {        return \"kind : \" + kind + \", number : \" + number;    }            // Object 클래스의 equals() 오버라이딩    public boolean equals(Object obj) {        if(!(obj instanceof Card))            return false;                    Card card = (Card)obj;        return this.kind.equals(card.kind) &amp;&amp; this.number == card.number;    }            // Object 클래스의 hashCode() 오버라이딩    public int hashCode() {        return Objects.hash(kind, number);    }        }    class Ex9_4 {    public static void main(String[] args) {        Card c1 = new Card();        Card c2 = new Card();            System.out.println(\"equals : \" + c1.equals(c2));                    System.out.println(\"hashCode : \" + c1.hashCode());        System.out.println(\"hashCode : \" + c2.hashCode());                    System.out.println(\"toString : \" + c1.toString());        System.out.println(\"toString : \" + c2.toString());    }}    // consoleequals : truehashCode : -1842861219hashCode : -1842861219toString : kind : SPADE, number : 1toString : kind : SPADE, number : 1                    ",
        "url": "/9cornerstoneJava2"
    }
    ,
    
    "9cornerstonejava1": {
        "title": "Ch9-1~3. Object 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter9. java.lang 패키지와 유용한 클래스  Ch9 - 1. Object 클래스  Ch9 - 2. Object 클래스의 메서드 : equals()  Ch9 - 3. equals()의 오버라이딩Ch9 - 1. Object 클래스▶ Object 클래스란?▷ 모든 클래스의 최고 조상▷ 오직 11개의 메서드만을 가짐▷ notify(), wait() 등은 쓰레드와 관련된 메서드Ch9 - 2. Object 클래스의 메서드 : equals()▶ equals(Object obj)▷ 객체 자신(this)과 주어진 객체(obj)를 비교▷ 반환타입 boolean : 같으면 true, 다르면 false▷ Object 클래스의 equals()는 객체의 주소를 비교(참조변수 값 비교)▶ 주소 비교 → value 비교▷ Object의 equals()를 오버라이딩하여 주소 비교 → value 비교  주소 비교      public boolean equals(Object obj) {      return this == obj;  }        value 비교      public boolean equals(Object obj) {      return this.value == obj.value; // ERROR!  }        이렇게 하면 에러 → 형변환 해야 함      public boolean equals(Object obj) {      Value v = (Value)obj;              return this.value == v.value;  }        그런데 참조변수의 형변환 전에는 반드시 instanceof로 확인Object는 어떤 타입이든 괜찮으니까 instanceof 생략했었는데 해야함      public boolean equals(Object obj) {      if (!(obj instanceof Value)) return false;              Value v = (Value)obj;              return this.value == v.value;  }          Ch9 - 3. equals()의 오버라이딩▶ equals()의 오버라이딩이란?▷ 인스턴스 변수(iv)의 값을 비교하도록 equals()를 오버라이딩해야 함  cv : 객체마다 같음(공통) → 비교X  iv : 객체마다 다름(개별) → 비교O▶ 예시▷ 주소 비교▷ iv 비교",
        "url": "/9cornerstoneJava1"
    }
    ,
    
    "8cornerstonejava7": {
        "title": "Ch8-18. 연결된 예외",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 18. 연결된 예외(chained exception)Ch8 - 18. 연결된 예외(chained exception)▶ 연결된 예외(chained exception)란?▷ 한 예외가 다른 예외를 발생시킬 수 있음▷ 예외A가 예외B를 발생 시키면, A는 B의 원인 예외(cause exception)Throwable initCause(Throwable 예외A) // 지정한 예외를 원인 예외로 등록Throwable getCause() // 원인 예외를 반환▶ Throwable?▷ Throwable은 Exception이라 생각하고 사용public class Throwable implements Serializable {\tprivate Throwable cause = this; // 객체 자신(this)을 원인 예외로 등록\t\tpublic synchronized Throwable initCouse(Throwable cause) {\t\tthis.cause = cause; // cause를 원인 예외로 등록 \t\treturn this;\t}}▶ 예시▷ 원인 예외 때문에 만들어진 연결된 예외▶ 연결된 예외를 사용하는 이유?▷ 여러 예외를 하나로 묶어 다루기 위해▷ checked예외를 unchecked예외로 변경 할 때▷ 즉 필수 처리를 선택 처리로 변경할 때▷ 보통 예외 선언을 하는 건 checked예외 = Exception자손 = 예외 필수 처리      checked예외일 때        unchecked예외일 때  연결된 예외 → 겉으로 봤을 땐 unchecked예외인 것 처럼 보이게 함",
        "url": "/8cornerstoneJava7"
    }
    ,
    
    "8cornerstonejava6": {
        "title": "Ch8-15~17. 사용자 정의 예외",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 15. 사용자 정의 예외 만들기  Ch8 - 16. 사용자 정의 예외 만들기 예제  Ch8 - 17. 예외 되던지기(exception re-throwing)Ch8 - 15. 사용자 정의 예외 만들기▶ 사용자 정의 예외란?▷ 직접 예외 클래스를 정의하는 것 → 상속을 이용하여▷ 조상은 Exception과 RuntimeException 중에서 선택  Exception 클래스 + 자손들          사용자가 발생시키는 예외      checked 예외 : 예외 처리 필수 → try-catch문 필수        RuntimeException 클래스 + 자손들          프로그래머가 발생시키는 예외      unchecked 예외 : 예외 처리 선택      Ch8 - 16. 사용자 정의 예외 만들기 예제class MyException extends Exception { // Exception이 조상 : 필수 처리 → try-catch문 필수  MyException(String msg) { // 문자열을 매개변수로 받는 생성자    super(msg); // 조상 Exception의 생성자 호출  }}Ch8 - 17. 예외 되던지기(exception re-throwing)▶ 예외 되던지기(exception re-throwing)란?▷ 예외를 처리한 후 다시 예외를 발생▷ 호출한 메서드와 호출 된 메서드 양쪽에서 예외 처리 : 예외 분담 처리",
        "url": "/8cornerstoneJava6"
    }
    ,
    
    "8cornerstonejava5": {
        "title": "Ch8-11~14. 메서드 예외",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 11. 메서드에 예외 선언하기  Ch8 - 12. 메서드에 예외 선언하기 예제1  Ch8 - 13. 메서드에 예외 선언하기 예제2  Ch8 - 14. finally블럭Ch8 - 11. 메서드에 예외 선언하기▶ 예외를 처리하는 방법 3가지▷ try-catch문 : 예외 직접 처리▷ 예외 선언 : 사실상 예외 처리X, 예외를 호출한 쪽에 예외 떠넘기기/알리기▷ 은폐 : 조용히 덮기, try-catch문에서 catch문에 아무것도 넣지 않음▶ 예외 처리 방법 3가지 中 예외 선언▷ throw  vs  throws  예외를 발생시키는 키워드 throw  예외를 선언하는 키워드 throws▶ JAVA APICh8 - 12. 메서드에 예외 선언하기 예제1▶ try-catch문이 어디에도 없을 때 - 예외 처리X▷ 예외를 떠넘기다 떠넘기다 처리를 하지 못해서▷ main에서 JVM까지 예외가 떠넘겨짐▷ JVM에서는 예외 발생 당시의 호출 스택을 보여줌▷ JVM에서 예외 처리가 된 건 아님▷ 폭탄 돌리기하다가 → … → JVM까지 간 것 뿐Ch8 - 13. 메서드에 예외 선언하기 예제2▶ try-catch문이 main에 있을 때 - 예외 처리O▷ 예외 선언으로 인해 main으로 돌아왔는데▷ try-catch문 有▷ 예외 해결Ch8 - 14. finally블럭▶ finally블럭이란?▷ 예외 발생여부와 관계없이 수행되어야 하는 코드를 넣음▷ try-catch문의 맨 마지막에 위치해야 함try {    // 예외 발생 가능성 있는 문장} catch (Exception e) {    // 예외 처리 문장} finally {    // 에러 발생 여부 관계X → 수행되어야 하는 문장}",
        "url": "/8cornerstoneJava5"
    }
    ,
    
    "8cornerstonejava4": {
        "title": "Ch8-9~10. 예외 발생시키기",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 9. 예외 발생시키기  Ch8 - 10. checked예외, unchecked예외Ch8 - 9. 예외 발생시키기▶ 예외를 발생시키는 방법▷ 연산자 new를 이용하여 발생시키려는 예외 클래스의 객체 생성Exception e = new Exception(\"고의적 예외 발생\");▷ 키워드 throw를 이용하여 예외 발생throw e;▷ 예외 객체 생성 + throw 한 번에 하는 방법throw new Exception(\"고의적 예외 발생\");Ch8 - 10. checked예외, unchecked예외▶ checked예외란?▷ 컴파일러가 예외 처리 여부를 체크▷ 예외 처리 필수▶ unchecked예외▷ 컴파일러가 예외 처리 여부를 체크X▷ 예외 처리 선택▷ try-catch문으로 해결class Ex8_8 {\tpublic static void main(String[] args) {\t\ttry {\t\t\tthrow new RuntimeException();\t\t} catch (Exception e) {\t\t\tSystem.out.println(\"에러 해결\");\t\t}\t}}// console에러 해결",
        "url": "/8cornerstoneJava4"
    }
    ,
    
    "8cornerstonejava3": {
        "title": "Ch8-7~8. 멀티 catch블럭",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 7. printStackTrace()와 getMessage()  Ch8 - 8. 멀티 catch블럭Ch8 - 7. printStackTrace()와 getMessage()class Ex8_5 {\tpublic static void main(String args[]) {\t\tSystem.out.println(1);\t\t\t\t\tSystem.out.println(2);\t\ttry {\t\t\tSystem.out.println(3);\t\t\tSystem.out.println(0/0); // 예외발생!!!\t\t\tSystem.out.println(4);   // 실행X\t\t} catch (ArithmeticException ae)\t{\t\t\tae.printStackTrace();\t\t\tSystem.out.println(\"예외메시지 : \" + ae.getMessage());\t\t}\t// try-catch의 끝\t\tSystem.out.println(6);\t}\t// main메서드의 끝}// console123java.lang.ArithmeticException: / by zero\tat Ex8_5.main(Ex8_5.java:8)예외메시지 : / by zero6▶ printStackTrace() 메서드란?▷ 예외 발생 시, 호출 스택에 있는 메서드의 정보와 예외 메세지를 화면에 출력java.lang.ArithmeticException: / by zero\tat Ex8_5.main(Ex8_5.java:8)▶ getMessage() 메서드란?▷ 발생한 예외 클래스의 인스턴스에 저장된 메세지를 getby zeroCh8 - 8. 멀티 catch블럭▶ 멀티 catch블럭이란?▷ 내용이 같은 catch블럭을 하나로 합친 것▷ JDK1.7부터▶ 주의▷ 부모 자식 관계는 멀티 catch블럭 사용 → 에러  부모-자식 멀티 catch블럭 = ERROR      class ExceptionA extends ExceptionB e { }      try {       ...  } catch (ExceptionA | ExceptionB e) { // ERROR!      e.printStackTrace();  }        부모만 catch블럭 = OK      class ExceptionA extends ExceptionB e { }      try {       ...  } catch (ExceptionA e) { // OK      e.printStackTrace();  }      ▷ 멀티 catch블럭에서 공통 멤버만 사용가능",
        "url": "/8cornerstoneJava3"
    }
    ,
    
    "8cornerstonejava2": {
        "title": "Ch8-4~6. 예외 처리",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 4. 예외 처리하기 : try-catch문  Ch8 - 5. try-catch문에서의 흐름  Ch8 - 6. 예외의 발생과 catch블럭Ch8 - 4. 예외 처리하기 : try-catch문▶ try-catch문이란?▷ 예외를 처리하기 위해 만들어 놓은 구문▷ {} 생략 불가try {    // 예외 발생 가능성이 있는 문장 작성} catch (Exception1 e1) {    // Exception1 발생했을 경우, 처리 문장 작성  } catch (Exception2 e2) {    // Exception2 발생했을 경우, 처리 문장 작성  } catch (Exception3 e3) {    // Exception3 발생했을 경우, 처리 문장 작성  }Ch8 - 5. try-catch문에서의 흐름▶ try블럭 내에서 예외가 발생한 경우▷ 발생한 예외가 일치하는 catch블럭이 있는지 확인▷ 일치하는 catch블럭 찾음→ 해당 catch블럭 내의 문장을 수행→ 전체 try-catch문을 빠져나감→ 다음 문장 계속적 수행▷ 일치하는 catch블럭 못 찾음→ 예외 처리 불가→ 프로그램 종료▶ try블럭 내에서 예외가 발생하지 않은 경우▷ catch블럭을 거치지 않고▷ 전체 try-catch문을 빠져나가▷ 계속적 수행Ch8 - 6. 예외의 발생과 catch블럭▶ 다양한 예외 발생▷ ArithmeticException▷ Exception▷ IndexOutOfBoundsException",
        "url": "/8cornerstoneJava2"
    }
    ,
    
    "8cornerstonejava1": {
        "title": "Ch8-1~3. 프로그램 오류",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter8. 예외처리  Ch8 - 1. 프로그램 오류  Ch8 - 2. 예외 클래스의 계층구조  Ch8 - 3. Exception과 RuntimeExceptionCh8 - 1. 프로그램 오류▶ 프로그램 오류의 종류 3가지▷ 컴파일 에러(compile-time error) : 컴파일 할 때 발생하는 에러▷ 런타임 에러(runtime error) : 실행 할 때 발생하는 에러▷ 논리적 에러(logical error) : 작성 의도와 다르게 동작하는 에러▶ 컴파일 에러(compile-time error) : 컴파일 할 때 발생하는 에러▷ 컴파일러가 하는 일  구문체크  번역  최적화 : 간단한 계산식 계산  생략된 코드 추가▶ 런타임 에러(runtime error) : 실행 할 때 발생하는 에러▷ 컴파일 시 모든 에러를 다 잡아주지 않음▷ 에러(error) : 심각한 오류▷ 예외(exception) : 다소 미약한 오류에러는 어쩔 수 없지만, 예외는 처리하자!▷ 예외처리(exception handling)의 정의: 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드 작성▷ 예외처리(exception handling)의 목적: 프로그램의 비정상 종료를 막고, 정상적인 실행 상태를 유지▶ 논리적 에러(logical error) : 작성 의도와 다르게 동작하는 에러▷ 컴파일 에러 = 실행이 안됨▷ 런타임 에러 = 실행이 다 되지 않고 프로그램 종료▷ 논리적 에러 = 프로그램이 다 실행 됨 그러나 생각했던 대로 실행이 안됨  예를 들어, 게임을 하다가 폭탄이 날아오면 터져야 함  하지만 폭탄이 터지지 않는 경우 = 논리적 에러Ch8 - 2. 예외 클래스의 계층구조▶ 상속계층도▷ 미약한 오류와 심각한 오류Ch8 - 3. Exception과 RuntimeException▶ Exception 클래스 + 자손들▷ 사용자의 실수와 같은 외적 요인에 의해 발생하는 예외▶ RuntimeException 클래스 + 자손들▷ 프로그래머의 실수로 발생하는 예외",
        "url": "/8cornerstoneJava1"
    }
    ,
    
    "7cornerstonejava24": {
        "title": "Ch7-51~52. 익명 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 51. 익명 클래스  Ch7 - 52. 익명 클래스 예제Ch7 - 51. 익명 클래스▶ 익명 클래스(anonymous class)란?▷ 이름이 없는 일회용 클래스▷ 정의와 생성을 동시에// 클래스 정의class Name extends Object{ }// 객체 생성Name name = new Name();그런데 이름이 없다면?// 클래스 정의class ? extends Object{ }// 객체 생성? name = new ?();조상의 이름을 대신 적어 줌// 정의 + 생성new Object {    // 멤버 선언}▶ 익명 클래스(anonymous class)의 선언 방법▷ 방법1 : 조상 클래스 이름 빌리기new 조상 클래스 이름 {    // 멤버 선언}▷ 방법2 : 구현 인터페이스 이름 빌리기new 구현 인터페이스 이름 {    // 멤버 선언}Ch7 - 52. 익명 클래스 예제▶ AWJ(java의 윈도우 프로그래밍) 코드를 익명 클래스로 변경▷ EventHandler는 일회성 클래스class Test {\tpublic static void main(String[] args) {\t\tButton button = new Button(\"Start\");\t\tbutton.addActionListener(new EventHandler()); // 객체 생성\t}}class EventHandler implements ActionListener { // 클래스 정의    public void actionPerformed(ActionEvent e) {        System.out.println(\"ActionEvent coourred!\");    }}▷ 익명 클래스로 줄여주기",
        "url": "/7cornerstoneJava24"
    }
    ,
    
    "7cornerstonejava23": {
        "title": "Ch7-45~50. 내부 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 45. 내부 클래스의 제어자와 접근성  Ch7 - 46. 내부 클래스의 제어자와 접근성 예제1  Ch7 - 47. 내부 클래스의 제어자와 접근성 예제2  Ch7 - 48. 내부 클래스의 제어자와 접근성 예제3  Ch7 - 49. 내부 클래스의 제어자와 접근성 예제4  Ch7 - 50. 내부 클래스의 제어자와 접근성 예제5Ch7 - 45. 내부 클래스의 제어자와 접근성▶ 클래스 앞 제어자▷ 일반적 클래스 앞 제어자 : (default), public 2개만 가능▷ 내부 클래스 앞 제어자 : (default), public, private, protected 4개 다 가능▷ 내부 클래스 ≒ 변수Ch7 - 46. 내부 클래스의 제어자와 접근성 예제1▶ static 멤버를 가질 수 있는 건 static 클래스 뿐!▷ staitc 멤버는 객체 생성없이 사용 가능한 것▷ static 클래스는 객체 생성 안해도 됨▷ iv → cv 사용 가능▷ iv ← cv 사용 불가class Outer {\tclass InstanceInner {\t\tint iv = 100;\t\tstatic int cv = 100; // ERROR! 인스턴스에서 static변수 → 선언 불가!\t\tfinal static int CONST = 100; // final static = 상수 → 선언 가능\t}\tstatic class StaticInner {\t\tint iv = 200;\t\tstatic int cv = 200; // static에서 static변수 → 선언 가능\t}\tvoid method() {\t\tclass LocalInner {\t\t\tint iv = 300;\t\t\tstatic int cv = 300; // ERROR! Local에서 static변수 → 선언 불가!\t\t\tfinal static int CONST = 300; // final static = 상수 → 선언 가능\t\t}\t}}▷ final static은 상수, 변수X → static 클래스 아니어도 사용 가능▷ final static 상수는 객체 생성 없이 바로 호출도 가능  System.out.println(InstanceInner.CONST);  System.out.println(StaticInner.cv);  System.out.println(LocalInner.cv);          지역 내부 클래스는 method 안에서만 사용 가능!      Ch7 - 47. 내부 클래스의 제어자와 접근성 예제2▶ static 메서드에서 instance 직접 사용 불가!▷ iv → cv 사용 가능▷ iv ← cv 사용 불가▷ 같은 원리로 static에서 instance 직접 사용 불가!class Outer {\tclass InstanceInner { }\tstatic class StaticInner { }\tInstanceInner iv = new InstanceInner();\tstatic StaticInner cv = new StaticInner();\t\tstatic void staticMethod() {\t\tInstanceInner obj1 = new InstanceInner(); // ERROR! static 메서드 안에서 instance 직접 접근 불가\t\tStaticInner obj2 = new StaticInner();\t}\t\tvoid instanceMethod() {\t\tInstanceInner obj1 = new InstanceInner();\t\tStaticInner obj2 = new StaticInner(); // instance 메서드에서는 static 사용 가능\t\tLocalInner lv = LocalInner(); // ERROR! 지역 내부 클래스는 메서드 안에서만\t}\t\tvoid method() {\t\tclass LocalInner {\t\t\tLocalInner lv = new LocalInner();\t\t}\t}}Ch7 - 48. 내부 클래스의 제어자와 접근성 예제3▶ 내부 클래스 private 사용 가능!▷ private : 같은 클래스만 사용가능▷ 내부 클래스 : 같은 클래스 안에 있는 다른 클래스▷ 내부 클래스도 같은 클래스class Outer {\tprivate int outerIv = 0;\tstatic int outerCv = 0;\tclass InstanceInner {\t\tint iv = outerIv; // 외부 클래스의 private 사용 가능\t\tint cv = outerCv;\t}\tstatic class StaticInner {\t\tint siv = outerIv; // ERROR! static → 인스턴스 멤버 접근 불가\t\tstatic int scv = outerCv;\t}}▶ 지역 내부 클래스에서는 변수 사용 불가, 상수만 접근 가능▷ 상수 : final int▷ JDK1.8 부터는 final 생략가능int lv = 0;int LV = 0; // final int lv = 0;  겉보기에 똑같음  어떻게 구분?  값이 바뀌지 않으면 상수로 간주▷ 상수만 접근 가능한 이유는 상수는 constant pool이란 곳에서 따로 관리  method는 자기 할 거 다 하면 없어짐  근데 상수는 constant pool가면 있음class Outer {\tvoid method() {\t\tint lv = 0;\t\tfinal int LV = 0;\t\t\t\tclass LocalInner {\t\t\tint iv = outerIv;\t\t\tint cv = outerCv;\t\t\t\t\t\tint lv = lv; // 원래는 ERROR! 외부 클래스 지역변수는 상수만 접근 가능, JDK1.8부터는 에러 아님\t\t\tint lV = LV;\t\t}\t}}  method보다 method 안에 있는 내부 클래스의 객체가 더 오래 살 수도 있음          method는 자기 할 거 다하면 없어져서      Ch7 - 49. 내부 클래스의 제어자와 접근성 예제4▶ 인스턴스 사용하려면, 외부 클래스 인스턴스 먼저 생성!▷ 인스턴스 사용하려면? 외부 클래스 인스턴스 생성 → 내부 클래스 인스턴스 생성▷ static은? 외부 클래스 인스턴스 생성 안해도 됨, 바로 내부 클래스 인스턴스 생성  단, 생성 시 외부 클래스 이름.내부 클래스 이름 = new 외부 클래스 이름.내부 클래스 이름class Outer {  class InstanceInner {    int iv = 100;  }    static class StaticInner {    int iv = 200;    static int cv = 300;  }    void method() {    class LocalInner {      int iv = 400;    }  }}class Test {  public static void main(String[] args) {  Outer o = new Outer(); // 외부 클래스의 인스턴스 먼저 생성  Outer.InstanceInner oi = o.new InstanceInner(); // 인스턴스 클래스의 인스턴스 생성 가능    Outer.StaticInner s = new Outer.StaticInner(); // static 내부 클래스는 외부 클래스 인스턴스를 먼저 생성 안해도 됨  }}Ch7 - 50. 내부 클래스의 제어자와 접근성 예제5▶ 변수의 위치 파악▷ 외부 클래스의 iv▷ 내부 클래스의 iv▷ lvclass Outer {\tint value = 10; // 외부 클래스의 iv\tclass Inner {\t\tint value = 20; // 내부 클래스의 iv\t\tvoid method() {\t\t\tint value = 30; // lv\t\t\tSystem.out.println(\"value : \" + value); // 가장 가까운 value\t\t\tSystem.out.println(\"this.value : \" + this.value); // 내부 클래스의 iv\t\t\tSystem.out.println(\"Outer.this.value : \" + Outer.this.value); // 외부 클래스의 iv\t\t}\t}}class Test {\tpublic static void main(String[] args) {\t\tOuter o = new Outer(); // 외부 클래스의 인스턴스 먼저 생성\t\tOuter.Inner inner = o.new Inner(); // 인스턴스 클래스의 인스턴스 생성 가능\t\tinner.method();\t}}// consolevalue : 30this.value : 20Outer.this.value : 10",
        "url": "/7cornerstoneJava23"
    }
    ,
    
    "7cornerstonejava22": {
        "title": "Ch7-42~44. 내부 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 42. 내부 클래스  Ch7 - 43. 내부 클래스의 종류와 특징  Ch7 - 44. 내부 클래스의 선언Ch7 - 42. 내부 클래스▶ 내부 클래스란?▷ 클래스 안의 클래스  일반적 클래스      class A {      ...  }      class B {      ...  }        내부 클래스      class A { // B의 외부 클래스      ...      class B { // A의 내부 클래스      ...      }  }      ▶ 내부 클래스의 장점▷ 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능▷ 코드의 복잡성을 감소 시킴(캡슐화)▶ 실습▷ 일반적 클래스 B에서 A의 멤버 i를 사용class A {\tint i = 100;}class B {\tvoid method() {\t\tA a = new A();\t\tSystem.out.println(a.i);\t}}▷ 내부 클래스 B에서 A의 멤버 i를 사용class A {\tint i = 100;\t\tclass B {\t\tvoid method() {\t\t\tSystem.out.println(i); // A a = new A(); 객체 생성 필요X\t\t}\t}}Ch7 - 43. 내부 클래스의 종류와 특징▶ 변수의 종류▷ iv▷ cv▷ lv▶ 내부 클래스의 종류▷ 인스턴스 내부 클래스 ≒ iv▷ 스태틱 내부 클래스 ≒ cv▷ 지역 클래스 ≒ lv▷ 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스(일회용)Ch7 - 44. 내부 클래스의 선언▶ 인스턴스 내부 클래스▷ ≒ ivclass Outer {  class InstanceInner {    ...  }}▶ 스태틱 내부 클래스▷ ≒ cv(static + iv)class Outer {  static class StaticInner {    ...  }}▶ 지역 내부 클래스▷ ≒ lvclass Outer {  void method() {    class LocalInner {      ...    }  }}",
        "url": "/7cornerstoneJava22"
    }
    ,
    
    "7cornerstonejava21": {
        "title": "Ch7-40~41. 메서드",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 40. 디폴트 메서드와 static 메서드  Ch7 - 41. 디폴트 메서드와 static 메서드 예제Ch7 - 40. 디폴트 메서드와 static 메서드▶ 인터페이스의 디폴트 메서드와 static 메서드▷ 인터페이스는 추상 메서드만 가질 수 있었음▷ 인터페이스에 디폴트 메서드와 static 메서드는 JDK1.8부터 추가 된 기능▶ 디폴트 메서드(default method)▷ 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움▷ 해결책 : 디폴트 메서드Ch7 - 41. 디폴트 메서드와 static 메서드 예제▶ 인터페이스에 디폴트 메서드가 생기면?▷ boolean isfinished(); : 추상 메서드를 인터페이스에 선언하면 생기는 일?▷ default boolean isfinished() {} : 디폴트 메서드를 인터페이스에 선언하면 생기는 일?",
        "url": "/7cornerstoneJava21"
    }
    ,
    
    "7cornerstonejava20": {
        "title": "Ch7-39. 인터페이스 장점",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 39. 인터페이스 장점Ch7 - 39. 인터페이스 장점▶ 인터페이스(interface)의 장점▷ interface : inter(~사이) + face(얼굴)▷ 두 대상(객체) 간의 연결, 대화, 소통을 돕는 ‘중간 역할’▷ 변경에 유리 : 선언(껍데기)과 구현(알맹이) 분리 가능  인터페이스 덕분에 C가 변경 되어도 A는 바뀌지 않아도 됨 : 느슨한 결합▷ 개발 시간을 단축▷ 표준화 가능▷ 서로 관계없는 클래스들을 관계를 맺어줄 수 있음▶ 실습▷ 인터페이스 사용하지 않고 클래스 A가 클래스 B를 사용class A {\tpublic void method(B b) {\t\tb.method();\t}}class B {\tpublic void method() {\t\tSystem.out.println(\"method B\");\t}}class Test { \tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.method(new B());\t} }// consolemethod B▷ 인터페이스 사용하지 않고 클래스 A가 클래스 C를 사용▷ 어디가 달라졌나?class A {\tpublic void method(C c) { // 매개변수 C로 변경\t\tc.method();\t}}class B {\tpublic void method() {\t\tSystem.out.println(\"method B\");\t}}class C { // 클래스 C 생성\tpublic void method() {\t\tSystem.out.println(\"method C\");\t}}class Test { \tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.method(new C()); // 클래스 C 객체 생성 해 주기\t} }// consolemethod C▷ 인터페이스 사용하여 클래스 A가 클래스 B를 사용class A {\tpublic void method(I i) { // 매개변수 : I를 구현한 애들만 와라\t\ti.method();\t}}interface I { // 메서드 선언부만 있음\tvoid method();}class B implements I { // I implements\tpublic void method() { // 구현부 완성\t\tSystem.out.println(\"I구현 : 클래스B'method\");\t}}class Test { \tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.method(new B());\t} }// consoelI구현 : 클래스B'method▷ 인터페이스 사용하여 클래스 A가 클래스 C를 사용▷ 어디가 달라졌나?package baek;class A {\tpublic void method(I i) {\t\ti.method();\t}}interface I {\tvoid method();}class B implements I {\tpublic void method() {\t\tSystem.out.println(\"I구현 : 클래스B'method\");\t}}class C implements I { // 여기\tpublic void method() {\t\tSystem.out.println(\"I구현 : 클래스C'method\");\t}}class Test { \tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.method(new C()); // 여기\t} }// consoleI구현 : 클래스C'method클래스 A에서 매개변수 일일이 바꿔주지 않아도 됨",
        "url": "/7cornerstoneJava20"
    }
    ,
    
    "7cornerstonejava19": {
        "title": "Ch7-38. 인터페이스 → 다형성",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 38. 인터페이스를 이용한 다형성Ch7 - 38. 인터페이스를 이용한 다형성▶ 인터페이스도 다형성 형성이 가능한가?▷ 가능▷ 인터페이스도 구현 클래스의 반만 부모▶ 인터페이스 타입 매개변수▷ 인터페이스 구현한 클래스의 객체만 가능▶ 인터페이스 리턴타입▷ 인터페이스를 메서드의 리턴타입으로 지정 가능▶ 실습▷ 추상 클래스 Unitabstract class Unit {\tint x, y;\tabstract void move(int x, int y);\tvoid stop() { System.out.println(\"stop\"); }}▷ interface Fightableinterface Fightable {\tvoid move(int x, int y);\tvoid attack(Fightable f);}▷ 클래스 Fighter : Unint 상속, Fightable 구현class Fighter extends Unit implements Fightable {\tpublic void move(int x, int y) { // public 안쓰면 에러!\t\tSystem.out.printf(\"(%d, %d) 이동\\n\", x, y);\t}\tpublic void attack(Fightable f) { // public 안쓰면 에러!\t\tSystem.out.println(f + \"를 공격\");\t}}  public 미작성 시, 에러나는 이유 :  오버라이딩 규칙 때문  오버라이딩 규칙 : 조상 접근제어자 &lt;= 자손 접근제어자  조상 : interface Fightable → 모든 메서드가 추상 메서드(public abstract 생략)      interface Fightable {      void move(int x, int y); // public abstract 생략      void attack(Fightable f); // public abstract 생략  }        자손 : default는 조상 접근제어자 public보다 작음, 그래서 public 생략 불가      public void move(int x, int y) { }  public void attack(Fightable f) { }      ▷ 클래스 Fighter : 리턴 타입이 Fightable인 getFightable 메서드Fightable getFightable() { // 리턴 타입 Fightable  Fightable f = new Fighter();  return (Fightable)f; // 리턴 타입 Fightable과 일치시키기 위해 형변환, 자동 형변환 가능}▷ 실행class FighterTest {\tpublic static void main(String[] args) {\t\tFighter f = new Fighter();\t\tf.move(100, 200);\t\tf.attack(new Fighter()); // Fighter f2 = new Fighter(); → f.attack(f2);\t\t    Fightable f2 = f.getFightable(); // getFightable 리턴 타입 Fightable과 일치시켜 호출\t}}▷ 실행 불가 경우Fightable f = new Fighter();Unit u = new Fighter();f.move(100, 200);f.attack(new Fighter());f.stop(); // 실행 불가, Fightable애 stop없음u.move(100, 200);u.stop();u.attack(new Fighter()); // 실행 불가, Unit에 attack없음",
        "url": "/7cornerstoneJava19"
    }
    ,
    
    "7cornerstonejava18": {
        "title": "Ch7-35~37. 인터페이스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 35. 인터페이스  Ch7 - 36. 인터페이스 상속  Ch7 - 37. 인터페이스 구현Ch7 - 35. 인터페이스▶ 인터페이스(interface)란?▷ 대부분 추상 메서드의 집합▷ 구현된 것이 전혀 없는 설계도▷ 껍데기▷ 모든 멤버가 public▶ 인터페이스(interface)의 특징▷ 변수 iv, cv 불가▷ 상수 가능▷ 예외없이 모든 상수는 public static final → public static final 생략 가능▷ 추상 메서드 가능▷ 예외없이 모든 메서드는 public abstract → public abstract 생략 가능interface 인터페이스 이름 {    public static final 타입 상수 이름 =  값;    public abstract 메서드 이름(매개변수 목록);}interface PlayingCard {    public static final int SPADE = 4;    final int DIAMOND = 3;    static int HEART = 2;    int CLOVER = 1; // public static final int CLOVER = 1;        public abstract String getCardNumber();    String getCardKind(); // public abstract String getCardKind();}▶ 추상 클래스 vs 인터페이스▷ 추상 클래스 : 추상 메서드, 생성자, iv를 가진 일반 클래스▷ 인터페이스 : 추상 메서드만 가진 클래스 → 생성자, iv, cv… 안됨Ch7 - 36. 인터페이스 상속▶ 인터페이스 상속은?▷ 인터페이스의 조상은 인터페이스만 가능▷ Object가 최고 조상 아님▷ 다중 상속이 가능(조상이 여러 개)▷ 다중 상속의 문제점 : 충돌▷ 추상 메서드는 충돌해도 문제 없음 → 구현부가 없기 때문, 내용 충돌 없음interface Fightable extends Movable, Attackable { }abstract class Unit {    abstract void unit();}interface Movable { void move(int x, int y); }interface Attackable { void attack(Unit u); }Ch7 - 37. 인터페이스 구현▶ 인터페이스 구현이란?▷ 인터페이스에 정의된 추상 메서드를 완성하는 것▷ 인터페이스 = 추상 메서드의 집합 = 미완성 설계도▷ 완성을 시켜야 사용이 가능함▷ 추상 클래스는 extends를 통해 상속받아 완성 시킴▷ 인터페이스는 implements를 통해 상속받아 완성 시킴▷ 구현 : 인터페이스에 정의 된 추상 메서드의 구현부{}를 모두 작성하는 것class 클래스 이름 implements 인터페이스 이름 {    // 인터페이스에 정의 된 추상 메서드에 구현부{} 모두 작성 }  Fighter 클래스는 Fightable 인터페이스를 구현했다      interface Fightable {      void move(int x, int y);      void attrack(Unit u);  }      class Fighter implements Fightable {      void move(int x, int y) { }      void attrack(Unit u) { }  }      ▷ 일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함abstract class Fighter implements Fightable {    public void move(int x, int y) { }}",
        "url": "/7cornerstoneJava18"
    }
    ,
    
    "7cornerstonejava17": {
        "title": "Ch7-33~34. 추상 클래스 작성",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 33. 추상 클래스의 작성  Ch7 - 34. 추상 클래스의 작성 예제Ch7 - 33. 추상 클래스의 작성▶ 추상 클래스 작성 방법▷ 여러 클래스에 공통적으로 사용될 수 있는 추상 클래스를▷ 바로 작성하거나▷ 기존 클래스의 공통 부분을 뽑아서 추상 클래스를 생성▶ 추상 클래스의 장점▷ 추상화 ↔ 구체화▷ 불명확 ↔ 명확▷ 때론 불명확하고 애매한 게 장점일 때가 있음▷ 추상화 된 코드 : 유연성↑, 변경에 유리GregofianCalendar cal = new GregofianCal(); // 구체적Calendar cal = Calendar.getInstance(); // 추상적, Calendar는 추상 클래스Ch7 - 34. 추상 클래스의 작성 예제▶ 공통 부분 추상 클래스로 작성abstract class Unit {\tint x, y;\tabstract void move(int x, int y);\tvoid stop() { }}class Marine extends Unit {Marine() { }\tvoid move(int x, int y) { System.out.printf(\"Marine [%d, %d] move\\n\", x, y); }\tvoid stimPack() { }}class Tank extends Unit {Tank() { }\tvoid move(int x, int y) { System.out.printf(\"Tank [%d, %d] move\\n\", x, y); }\tvoid changeMode() { }}class Dropship extends Unit {Dropship() { }\tvoid move(int x, int y) { System.out.printf(\"Dropship [%d, %d] move\\n\", x, y); }\tvoid load() { }\tvoid unload() { }}class Test {Test() { }\tpublic static void main(String[] args) {\t\tUnit[] group = { new Marine(), new Marine(), new Dropship() };\t\t\t\tfor (int i = 0; i &lt; group.length; i++) {\t\t\tgroup[i].move(100, 200);\t\t}\t}}// consoleMarine [100, 200] moveMarine [100, 200] moveDropship [100, 200] move",
        "url": "/7cornerstoneJava17"
    }
    ,
    
    "7cornerstonejava16": {
        "title": "Ch7-31~32. 추상 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 31. 추상 클래스  Ch7 - 32. 추상 메서드Ch7 - 31. 추상 클래스▶ 추상 클래스(abstract class)란?▷ 미완성 설계도▷ 미완성 메서드를 갖고 있는 클래스  추상 메서드          구현부{}가 없는 미완성 메서드      abstract를 붙임abstract void play(int pos);        추상 클래스 : 추상 메서드를 갖고 있는 클래스      abstract class Player {      abstract void play(int pos);  }      ▷ 다른 클래스 작성에 도움을 주기 위한 것▷ 인스턴스 생성 불가  추상 클래스 = 미완성 설계도 → 제품 설계 불가      Player p = new Player(); // 에러! 추상 클래스의 인스턴스 생성 불가      ▷ 상속을 통해 추상 메서드 완성시킨 후, 인스턴스 생성 가능class AudioPlayer extends Player { // 미완성 설계도를 상속 → 완성 설계도    void play(int pos) { } // 추상 메서드 구현, 구현부{}를 만들어 줌    void stop() { } // 추상 메서드 구현}AudioPlayer ap = new AudioPlayer(); // 인스턴스 생성 가능Ch7 - 32. 추상 메서드▶ 추상 메서드(abstract method)란?▷ 미완선 메서드▷ 구현부{}가 없는 메서드abstract 리턴타입 메서드 이름();▶ 상속을 받았지만, 추상 메서드가 유지되는 경우▷ 자손마다 다르게 구현 될 것으로 예상하는 경우abstract class Player { // // 추상 클래스\tabstract void play(int pos); // 추상 메서드\tabstract void stop(); // 추상 메서드}class AudioPlayer extends Player { // 추상 클래스 상속 → 완전한 클래스로 생성 된 자손  void play(int pos) { } // 추상 메서드 구현  void stop() { } // 추상 메서드 구현}abstract class AbstractPlayer extends Player { // 추상 클래스 상속 → 완전한 클래스?? : nope! 미완성 클래스 그래서 abstract 붙임  abstract void play(int pos) { } // 상속받은 추상 클래스의 추상메서드 2개 중 하나만 구현 → 미완성 클래스가 됨}▶ 추상 메서드 호출 가능▷ 호출 시, 선언부만 필요abstract class Player {\tboolean pause; // 추상 클래스 내 iv, 일시정지\tint currentPos; // 추상 클래스 내 iv, 현재 paly 위치\t\tPlayer() { // 추상 클래스도 생성자有\t\tpause = false;\t\tcurrentPos = 0;\t}\t\tabstract void play(int pos); // pos에서 play!\tabstract void stop(); // stop!\tvoid play() { // 인스턴스 메서드\t\tplay(currentPos); // 추상 메서드 호출\t}}  인스턴스 메서드 사용법          클래스 객체 생성      추상 클래스를 객체 생성하려면 상속 해야 함        추상 메서드 사용법          자손 객체가 추상 클래스 상속      자손 객체가 구현부{} 생성        인스턴스 메서드나 추상 메서드나 객체 생성 필요  그러나 추상 클래스에서는 객체 생성이 불가  결론 : 인스턴스 메서드 play에 있는 추상 메서드 play(currentPos)를 사용하려면?          추상 클래스를 온전히 상속 받는 자손 생성      자손 클래스에서 조상 클래스의 모든 메서드의 구현부{} 생성      자손 클래스 객체 생성      객체.Play(currentPos) 호출하여 사용      dvdPlayer든 어떤 Player든 간에 abstract는 꼭 해야만 하는 것을 의미▶ 실습▷ 추상 클래스 상속, 구현부{} 만들기, 객체 생성, 추상 메서드 호출abstract class Player {\tabstract void play(int pos);\tabstract void stop();}class AudioPlayer extends Player {\tvoid play(int pos) { System.out.println(pos + \"'부터 시작\"); }\tvoid stop() { System.out.println(\"stop\"); }}class Test {\tpublic static void main(String[] args) {\t\tAudioPlayer ap = new AudioPlayer();\t\tap.play(100);\t\tap.stop();\t}}// console100'부터 시작stop▷ 객체 생성할 때, 실제 생성되는 객체 = AudioPlayer▷ 리모콘은 AudioPlayer, Player 둘 중 아무거나 상관 없음AudioPlayer ap = new AudioPlayer();Player ap = new AudioPlayer(); // 다형성",
        "url": "/7cornerstoneJava16"
    }
    ,
    
    "7cornerstonejava15": {
        "title": "Ch7-29~30. 객체 → 배열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 29. 여러 종류의 객체를 배열로 다루기  Ch7 - 30. 여러 종류의 객체를 배열로 다루기 예제Ch7 - 29. 여러 종류의 객체를 배열로 다루기▶ 다형성의 장점▷ 다형적 매개변수▷ 하나의 배열에 여러 종류의 객체 저장  보통 하나의 배열은 같은 타입만 저장 가능  다형성을 이용하면, 조상 타입의 배열에 자손들의 객체 여러 개 저장 가능Ch7 - 30. 여러 종류의 객체를 배열로 다루기 예제▶ 장바구니 기능 : 구매한 총 금액, 구매한 상품▷ 모든 제품의 조상 Product p로 다형적 매개변수 생성▷ 배열 cart에 다형적 매개변수로 받은 객체를 저장▷ 배열 하나로 여러 가지 객체 이용 가능package baek;public class Product2 {Product2() {}\tint price;\tint point;\t\tProduct2(int price) {\t\tthis.price = price;\t\tpoint = (int) (price / 10.0);\t}}class Tv extends Product2 {Tv() { super(100); }\tpublic String toString() { return \"TV\";\t}}class Computer extends Product2 {Computer() { super(200); }\tpublic String toString() { return \"Computer\"; }}class Buyer {Buyer() {}\tint myMoney = 400;\tint myPoint = 0;\t\tProduct2[] cart = new Product2[10];\tint i = 0;\tvoid buy(Product2 p) {\t\tif (myMoney &lt; p.price) {\t\t\tSystem.out.println(\"잔액이 부족합니다.\");\t\t\treturn;\t\t} else {\t\t\tmyMoney -= p.price;\t\t\tmyPoint += p.point;\t\t\t\t\t\tcart[i++] = p;\t\t\t\t\t\tSystem.out.printf(\"[%s] 구매\\n\", p);\t\t}\t}\t\tvoid cartIn() {\t\tint sum = 0;\t\tString itemList = \"\";\t\t\t\tfor (int i = 0; i &lt; cart.length; i++) {\t\t\tif (cart[i] == null) { break; }\t\t\telse {\t\t\t\tsum += cart[i].price;\t\t\t\titemList += \"[\" + cart[i].toString() + \"] \";\t\t\t}\t\t}\t\tSystem.out.printf(\"총 금액 : %d만원\\n\", sum);\t\tSystem.out.printf(\"선택한 제품 : %s\\n\", itemList);\t}}class Act {public static void main(String[] args) {Buyer b = new Buyer();\t\tb.buy(new Tv());\t\tb.buy(new Computer());\t\tb.cartIn();\t\t\t\tSystem.out.printf(\"잔액은 %d만원 입니다.\\n\", b.myMoney);\t\tSystem.out.printf(\"잔여 포인트는 %d점 입니다.\\n\", b.myPoint);\t}}// console[TV] 구매[Computer] 구매총 금액 : 300만원선택한 제품 : [TV] [Computer]잔액은 100만원 입니다.잔여 포인트는 30점 입니다.",
        "url": "/7cornerstoneJava15"
    }
    ,
    
    "7cornerstonejava14": {
        "title": "Ch7-27~28. 매개변수 다형성",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 27. 매개변수의 다형성  Ch7 - 28. 매개변수의 다형성 예제Ch7 - 27. 매개변수의 다형성▶ 다형성의 장점▷ 다형적 매개변수▷ 하나의 배열로 여러 종류의 객체 다루기▶ 다형성 정리▷ Tv t = new SmartTv(); : 조상 = new 자손();▷ 참조변수의 형변환(리모콘 바꾸기) : 사용가능한 멤버개수 조절▷ instanceof 연산자 : 형변환 가능여부 확인▶ 매개변수의 다형성이란?▷ 참조형 매개변수는 메서드 호출 시,▷ 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있음Ch7 - 28. 매개변수의 다형성 예제▶ 제품과 구매자 관리▷ 제품▷ 제품마다 buy 메서드에 오버라이딩하여 구매자 관리오버라이딩 → 코드 중복 발생▷ 제품들의 조상인 Product 클래스를▷ 다형적 매개변수로 받아 하나의 메서드로 구매자 관리▶ 예제 클론 코딩▷ class Product  price  point(price의 10%)      public class Product {      int price;      int point;          Product() {      }          Product(int price) {          this.price = price;          point = (int) (price / 10.0);      }  }      ▷ class Tv  Product 상속  super로 price 호출 = 100  Object의 toString으로 return “TV”    class Tv extends Product {      Tv() {        super(100);    }      public String toString() {        return \"TV\";    }}      ▷ class Computer  Product 상속  super로 price 호출 = 200  Object의 toString으로 return “Computer”    class Computer extends Product {      Computer() {        super(200);    }      public String toString() {        return \"Computer\";    }}      ▷ class Buyer  myMoney, myPoint  제품 price가 myMoney보다 작을 시, 잔액 부족 메세지 출력  myMoney에서 price차감  myPoint에서 point증가    class Buyer {    Buyer() { }      int myMoney = 400;    int myPoint = 0;      void buy(Product p) {        if (myMoney &lt; p.price) {            System.out.println(\"잔액이 부족합니다.\");            return;        } else {            myMoney -= p.price;            myPoint += p.point;            System.out.println(p + \" 구매를 선택\");        }    }}      ▷ class Act  Buyer 객체 생성  b.buy(new Tv()); = Product p = new Tv; = b.buy(p);    class Act {    public static void main(String[] args) {        Buyer b = new Buyer();                  b.buy(new Tv());        b.buy(new Computer());                  System.out.printf(\"잔액은 %d만원 입니다.\\n\", b.myMoney);        System.out.printf(\"잔여 포인트는 %d점 입니다.\", b.myPoint);    }}  // consoleTV 구매를 선택Computer 구매를 선택잔액은 100만원 입니다.잔여 포인트는 30점 입니다.      ",
        "url": "/7cornerstoneJava14"
    }
    ,
    
    "7cornerstonejava13": {
        "title": "Ch7-26. instatnceof",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 26. instatnceof 연산자Ch7 - 26. instatnceof 연산자▶ instatnceof 연산자란?▷ 참조변수의 형변환(조상·자손) 가능여부 확인에 사용▷ 가능하면, ture반환▷ 형변환 전 반드시 instanceof로 확인!!public class Car {\tString color;\tint door;\tvoid drive() {\t\tSystem.out.println(\"drive\");\t}\t\tvoid stop() {\t\tSystem.out.println(\"stop!\");\t}}class FireEngine extends Car {    void water() {    System.out.println(\"water\");    }}class Ambulance extends Car {    void hospital() {    System.out.println(\"hospital\");    }}public class CarTest {\tvoid doWork(Car c) { // Car 또는 Car의 모든 자손 가능 : new Car{}, new FireEngine(); new Ambulance(); \t\tif (c instanceof FireEngine) {\t\t\tSystem.out.println(c instanceof FireEngine); // 형변환 가능한지 확인 : c가 FireEngine의 자손이냐? true면 다음으로\t\t\tFireEngine fe = (FireEngine) c; // 형변환 \t\t\tfe.water();\t\t}\t}}FireEngine fe = new FireEngine();System.out.println(fe instanceof Object); // trueSystem.out.println(fe instanceof Car); // trueSystem.out.println(fe instanceof FireEngine); // trueObject obj = (Object)fe; // okCar car = (Car)fe; // ok",
        "url": "/7cornerstoneJava13"
    }
    ,
    
    "7cornerstonejava12": {
        "title": "Ch7-24~25. 참조변수 형변환",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 24. 참조변수의 형변환  Ch7 - 25. 참조변수의 형변환 예제Ch7 - 24. 참조변수의 형변환▶ 참조변수의 형변환이란?▷ 결론 : 사용할 수 있는 멤버의 개수를 조절하는 것  기본형의 형변환 : 값이 달라짐(int)3.6 = 3  참조변수의 형변환 : 멤버의 개수가 달라짐, 값은 달라지지 않음▷ 조상 자손 관계일 때만 서로 형변환 가능Ch7 - 25. 참조변수의 형변환 예제▶ 에러가 발생하는 이유는? - 1public static void main(String[] args) {    Car car = null;    FireEngine fe = new FireEngine();    FireEngine fe2 = null;    fe.water();    car = (Car)fe;        car.water(); // 컴파일 에러        fe2 = (FireEngine)car;    fe2.water();}▷ Car타입의 참조변수는 water()를 호출 할 수 없음▷ Car타입의 리모콘은 water()기능을 사용할 수 없음▶ 에러가 발생하는 이유는? - 2public static void main(String[] args) {    Car c = new Car();    FireEngine fe = (FireEngine)c; // 형변환 실행 에러    fe.water(); // 컴파일은 통과}// consoleException in thread \"main\" java.lang.ClassCastException: class baek.Car cannot be cast to class baek.FireEngine (baek.Car and baek.FireEngine are in unnamed module of loader 'app')\tat baek.CarTest.main(Car.java:39)▷ 실제 생성된 Car인스턴스에 애초에 water()가 없음",
        "url": "/7cornerstoneJava12"
    }
    ,
    
    "7cornerstonejava11": {
        "title": "Ch7-23. 다형성",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 23. 다형성Ch7 - 23. 다형성▶ 다형성(polymorphism)란?▷ 여러 가지 형태를 가질 수 있는 능력▷ 조상 타입 참조변수로 자손 타입 객체를 다루는 것▷ 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?      객체 = 참조변수 타입        객체 ≠ 참조변수 타입  ▷ 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다!Tv t = new SamrtTv(); = OK!SamrtTv s = Tv(); = ERROR!      Tv t = new SamrtTv(); = OK!        SamrtTv s = Tv(); = ERROR!  ▶ Q&amp;A▷ Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치?  A. No! 보통은 일치하나, 불일치일 때도 있음(불일치 = 다형성)Tv t = new SamrtTv()▷ Q. 참조변수가 조상 타입일 때와 자손 타입일 때의 차이?  A. 참조변수로 사용할 수 있는 멤버의 개수가 다름▷ Q. 자손 타입의 잠조변수로 조상 타입의 객체를 가리키기 가능?  A. No!",
        "url": "/7cornerstoneJava11"
    }
    ,
    
    "7cornerstonejava10": {
        "title": "Ch7-22. 캡슐화",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 22. 캡슐화와 접근제어자Ch7 - 22. 캡슐화와 접근제어자▶ 접근제어자를 사용하는 이유?▷ 외부로부터 데이터를 보호(캡슐화)하기 위해서public class Time {\tpublic int hour; // 범위 : 0 ~ 23\tpublic int minute; // 범위 : 0 ~ 59\tpublic int second; // 범위 : 0 ~ 59}class TimeTest {\tpublic static void main(String[] args) {\t\tTime time = new Time();\t\ttime.hour = 100; // 범위 초과 방지 못함\t}}▷ 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서  접근제어자의 범위는 좁은 게 좋음  필요 시 점점 넓혀가는 게 좋음▶ 실습▷ 조건문 기능 분리  메서드 추출 : alt + shift + Mpackage baek;public class Time {\tprivate int hour;\tprivate int minute;\tprivate int second;\tpublic void setHour(int hour) {\t\tif (isNotValidHour(hour)) return;\t\tthis.hour = hour;\t}\t// 매개변수로 넘겨진 hour가 유효한지 확인해서 알려주는 메서드, 내부에서만 사용 private\tprivate boolean isNotValidHour(int hour) {\t\treturn hour &lt; 0 || hour &gt; 23;\t}\t\tpublic int getHour() { return hour; }}class TimeTest {\t\tpublic static void main(String[] args) {\t\tTime time = new Time();\t\ttime.setHour(20);\t\tSystem.out.println(time.getHour());\t}}",
        "url": "/7cornerstoneJava10"
    }
    ,
    
    "7cornerstonejava9": {
        "title": "Ch7-21. 접근제어자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 21. 접근제어자Ch7 - 21. 접근제어자▶ 접근제어자(access modifier) 4가지▷ private  같은 클래스 내에서만 접근 가능▷ (default)  같은 패키지 내에서만 접근 가능▷ protected  같은 패키지 내 + 다른 패키지의 자손 클래스 내에서 접근 가능▷ public  접근 제한 없음, 모두 접근 가능▶ class 앞 : public, (default)▷ publicpublic class AccessModifierTest { }▷ (default)class AccessModifierTest { }▶ iv 앞 : private, (default), protected, public▷ privateprivate int iv;▷ (default)int iv;▷ protectedpublic protected int iv;▷ publicpublic int iv;▶ cv 앞 : private, (default), protected, public▷ privateprivate static int cv;▷ (default)static int cv;▷ protectedprotected static int cv;▷ publicpublic static int cv;▶ 실습▷ 같은 클래스package baek;class Prent {\tprivate int prv;\tint dft;\tprotected int prt;\tpublic int pub;\t\tvoid members() {\t\tSystem.out.println(\"prv\" + prv); // ok\t\tSystem.out.println(\"dft\" + dft); // ok\t\tSystem.out.println(\"prt\" + prt); // ok\t\tSystem.out.println(\"pub\" + pub); // ok\t}}▷ 다른 클래스package baek;class Different1 {\tvoid members() {\t\tPrent p = new Prent();\t\tSystem.out.println(\"prv\" + p.prv); // error, private : 다른 클래스 사용X\t\tSystem.out.println(\"dft\" + p.dft); // ok\t\tSystem.out.println(\"prt\" + p.prt); // ok\t\tSystem.out.println(\"pub\" + p.pub); // ok\t}}▷ 다른 패키지 + 상속  다른 패키지에서 상속받으려면 조상 클래스가 public 이어야 함  default class는 같은 패키지 내에서만 상속 가능  class Prent → public class Prent  class Diffrent2 extends baek.Prent  상속 받은 뒤 ctrl + shift + o 자동 import 해 주기package baek2;import baek.Prent;class Different2 extends baek.Prent {\tvoid members() {\t\tSystem.out.println(\"prv\" + prv); // error, private : 같은 클래스만\t\tSystem.out.println(\"dft\" + dft); // error, defalut : 같은 패키지만\t\tSystem.out.println(\"prt\" + prt); // ok, protected : 같은 패키지만 + 다른 패키지 자손은 가능\t\tSystem.out.println(\"pub\" + pub); // ok\t}}▷ 다른 패키지package baek2;import baek.Prent;class Different3 {\tvoid members() {\t\tPrent p = new Prent();\t\tSystem.out.println(\"prv\" + p.prv); // error, private : 같은 클래스만\t\tSystem.out.println(\"dft\" + p.dft); // error, defalut : 같은 패키지만\t\tSystem.out.println(\"prt\" + p.prt); // error, protected : 같은 패키지만 + 다른 패키지 자손은 가능\t\tSystem.out.println(\"pub\" + p.pub); // ok\t}}▷ 정리 그림",
        "url": "/7cornerstoneJava9"
    }
    ,
    
    "7cornerstonejava8": {
        "title": "Ch7-17~20. 제어자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 17. 제어자  Ch7 - 18. static : 클래스의, 공통적인  Ch7 - 19. final :  마지막의, 변경될 수 없는  Ch7 - 20. abstract : 추상의, 미완성의Ch7 - 17. 제어자▶ 제어자(modifier)란?▷ 클래스와 클래스의 멤버(멤버 변수·메서드)에 부가적인 의미 부여▷ 마치 명사를 꾸며주는 형용사 같은 역할▷ 하나의 대상에 여러 제어자를 같이 사용 가능▷ 접근 제어자는 하나만▶ 접근제어자▷ public, protected, (default), private▷ 4개 중 하나만 붙일 수 있음▷ (default)는 아무것도 붙이지 않는 것을 의미▶ 그 외 제어자▷ static, final, abstract, native, transient, synchroniaed, volatile, strictfppublic class ModifierTest {    public static final int WIDTH = 200; // 접근 제어자는 보통 제일 왼쪽에}Ch7 - 18. static : 클래스의, 공통적인▶ static + 멤버변수▷ static + iv = cv▷ cv는 인스턴스를 생성하지 않아도 사용 가능▷ 클래스가 메모리에 로드될 때 생성▶ static 메서드▷ static 메서드는 인스턴스를 생성 없이 호출 가능▷ static 메서드 내에서는 인스턴스 멤버(iv, im) 직접 사용 불가class StaticTest {\tstatic int width = 200; // cv(static 변수), 대입 연산자 = 간단한·명시적 초기화\tstatic int geight = 120; // cv(static 변수)\tstatic { // 클래스 초기화 블럭 static { }\t\t// cv(static 변수)의 복잡한 초기화 수행\t}\t\tstatic int max(int a, int b) { // 클래스 메서드(static 메서드) : iv 사용 불가\t\treturn a &gt; b ? a : b;\t}}Ch7 - 19. abstract : 추상의, 미완성의▶ final + 클래스▷ 변경 불가 클래스▷ 확장 불가 클래스▷ final 클래스는 다른 클래스의 조상 불가  대표적인 final 클래스          String : 보안 때문      Math : 모두 static 메서드 집합이기 때문      ▶ final + 메서드▷ 변경 불가 메서드▷ final 메서드는 오버라이딩으로 재정의 불가▶ final + 멤버·지역 변수▷ final + 멤버·지역 변수는 값을 변경할 수 없는 상수가 됨final class FinalTest { // 다른 클래스 조상 불가\tfinal int MAX_SIZE = 10; // 값 변경 불가 멤버 변수(상수)\t\tfinal void getMaxSize() { // 오버라이딩 불가 메서드\t\tfinal int LV = MAX_SIZE; // 값 변경 불가 지역 변수(상수)\t\treturn MAX_SIZE;\t}}Ch7 - 20. abstract : 추상의, 미완성의▶ abstract + 클래스▷ 미완성 클래스 : 미완성 설계도 → 제품 생성 불가 → 즉, 객체 생성 불가AbstractTest a = new AbstractTest();▷ 추상 클래스를 상속받아 완전한 클래스(구상 클래스)를 만들면, 객체 생성 가능▷ 추상 메서드가 있으면 무조건 추상 클래스▷ 클래스 내, 추상 메서드가 선언되어 있음을 의미▶ abstract + 메서드▷ 미완성 메서드▷ 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림abstract class AbstractTest { // 추상 클래스(추상 메서드를 포함한 클래스)abstract void move(); // 추상 메서드(구현부{}가 없는 메서드)}",
        "url": "/7cornerstoneJava8"
    }
    ,
    
    "7cornerstonejava7": {
        "title": "Ch7-15~16. import문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 15. import문  Ch7 - 16. static import문Ch7 - 15. import문▶ import문이란?▷ 클래스를 사용할 때 패키지 이름을 생략할 수 있음▷ 컴파일러에게 클래스가 속한 패키지를 알려줌▷ 이클립스 자동 import 단축키 : ctrl + shift + o▷ java.lang 패키지(기본 패키지)의 클래스는 import하지 않고도 사용 가능  String, Object, System. Thread…  import java.lang.*; // *은 java.lang의 모든 클래스 의미 생략가능▶ import문 선언 방법▷ 방법 1▷ ctrl + shift + o → 방법 1로 선언import 패키지 이름. 클래스 이름;▷ 방법 2import 패키지 이름.*;▷ import문은 패키지 문과 클래스 선언의 사이에 선언package com.codechobo.book; // 패키지 선언import java.util.Date; // import문class ImportTest { // 클래스 정의\tDate date = new Date();}▷ import문은 컴파일 시 처리 → 프로그램의 성능에 영향 없음▷ *이 붙었다고 다 같은 건 아님▷ 패키지 두 개가 같은 이름의 클래스를 가질 때,import문에 사용하는 패키지 이름 붙여주기import java. sql*; // java.sql.Date 존재import java. util*; // java.util.Date 존재pobic class ImportTest {    publid static void main(String[] args) {        java.util.Date today = new java.util.Date(); // sql.Date 아니고 util.Date 사용인 걸 알 수 있음         }}Ch7 - 16. static import문▶ static import문이란?▷ static 멤버를 사용할 때, 클래스 이름을 생략할 수 있게 해 줌▷ 클래스 이름을 생략하여, 코드를 짧게 만들어 줌",
        "url": "/7cornerstoneJava7"
    }
    ,
    
    "7cornerstonejava6": {
        "title": "Ch7-12~14. 패키지",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 12. 패키지  Ch7 - 13. 패키지의 선언  Ch7 - 14. class pathCh7 - 12. 패키지▶ 패키지(package)란?▷ 서로 관련된 클래스의 묶음▷ JAVA8 기준 약 4000개의 클래스가 존재▷ 이 많은 클래스들을 작은 단위로 나누어 저장하기 위해 패키지 사용▷ 클래스는 클래스 파일(*.class), 패키지는 폴더▷ 하위 패키지는 하위 폴더▷ 클래스의 실제 이름(full name)은 패키지를 포함▷ String의 실제 이름 = java.lang.String▷ rt.jar는 클래스들을 압축한 파일(JDK설치경로\\jre\\lib에 위치)  rt = runtime 실행 중을 의미  jar 파일 = 클래스 파일을 묶어 놓은 것  JAVA9 부터 rt.jar 없어짐  → module 개념의 도입으로 rt.jar 같이 큰 파일은 module 단위로 놓음Ch7 - 13. 패키지의 선언▶ 패키지의 선언이란?▷ 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언▷ 같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 됨▷ 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속함 : default package▶ cmd에서 패키지 명으로 코드 실행하기package com.codechobo.book; // 패키지 선언public class PackageTest {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"Hello World!\");\t}}▷ package com.codechobo.book;뜻  com &gt; codechobo &gt; book 안에 있다는 뜻▷ cmd에서 패키지 실행▷ cd 패키지가 있는 경로를 찾아서 실행▷ 매번 패키지 경로를 설정하지 않는 방법 =  class path를 이용Ch7 - 14. class path▶ class path란?▷ 클래스 파일(*.class)의 위치를 알려주는 경로(path)▷ 환경변수 class path로 관리  환경변수 : OS에서 관리하는 것▷ 경로 간 구분자는 ‘;’을 사용▷ class path(환경변수)에 패키지 루트를 등록해 주어야 함▶ cmd에서 패키지 경로 입력 없이 패키지 명으로 코드 실행▷ 환경변수 등록▷ class path 확인  set class path▷ class path 추가  set class path 기존 설정 경로 입력 + 세미콜론; + 추가 경로 입력",
        "url": "/7cornerstoneJava6"
    }
    ,
    
    "7cornerstonejava5": {
        "title": "Ch7-10~11. super",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 10. 참조변수 super  Ch7 - 11. super() - 조상의 생성자Ch7 - 10. 참조변수 super▶ 참조변수 super란?▷ super ≒ this▷ this : lv와 iv 구별▷ super : 조상 멤버와 자신 멤버 구별▷ 객체 자신을 가리키는 참조변수▷ 인스턴스 메서드(생성자) 내에서만 존재▷ static 메서드 내에서는 사용 불가▶ 실습▷ 부모와 자식 모두 x를 가진 경우class Act {\tpublic static void main(String[] args) {\t\t\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}class Child extends Parent {\tint x = 20;\t\tvoid method() {\t\t\t\tSystem.out.println(\"x = \" + x); // 가까운 쪽의 x, 바로 위의 int x = 20;\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}// consolex = 20this.x = 20super.x = 10▷ 부모만 x를 가진 경우class Act {\t\tpublic static void main(String[] args) {\t\t\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}class Child extends Parent {\t\tvoid method() {\t\t\t\tSystem.out.println(\"x = \" + x); // Prent의 int x = 10;\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}// consolex = 10this.x = 10super.x = 10Ch7 - 11. super() - 조상의 생성자▶ 조상의 생성자 super()란?▷ 참조변수 super ≠ 조상의 생성자 super()▷ 조상의 생성자 super()는 생성자this와 같음▷ 조상의 생성자를 호출할 때 사용▷ 생성자와 초기와 블럭은 상속 불가▷ 조상의 멤버는 조상의 생성자를 호출해서 초기화▷ 생성자의 첫 줄에 반드시 다른 생성자를 호출▷ 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입▶ 실습▷ 왜 에러가 났을까?class Point {\tint x;\tint y;\t\tPoint(int x, int y) {\t\tthis.x = x;\t\tthis.y = y;\t}\t\tString getLocation() {\t\treturn \"x : \" + x + \"y : \" + y;\t}}class Point3D extends Point {\tint z;\t\tPoint3D(int x, int y, int z) {\t\tthis.x = x;\t\tthis.y = y;\t\tthis.z = z;\t}\t\tString getLocation() {\t\treturn \"x : \" + x + \"y : \" + y + \"z : \" + z;\t}}class PointTest {\tpublic static void main(String[] args) {\t\tPoint3D point3d = new Point3D(1, 2, 3);\t}}// consoleException in thread \"main\" java.lang.Error: Unresolved compilation problem: Implicit super constructor Point() is undefined. Must explicitly invoke another constructorat baek_ch02.Point3D.&lt;init&gt;(Point.java:20)at baek_ch02.PointTest.main(Point.java:33)▷ 기본 생성자 Point() {}의 부재 때문▷ 에러 수정",
        "url": "/7cornerstoneJava5"
    }
    ,
    
    "7cornerstonejava4": {
        "title": "Ch7-7~9. 오버라이딩",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 7. 오버라이딩  Ch7 - 8. 오버라이딩의 조건  Ch7 - 9. 오버로딩 vs. 오버라이딩Ch7 - 7. 오버라이딩▶ 오버라이딩(overriding)이란?▷ overriding : v. 덮어쓰다▷ 상속받은 조상의 메서드를 자신에 맞게 변경하는 것class Point {    int x;    int y;    String getLocation() {        return \"x : \" + x + \", y : \" + y;    }}class Point3D extends Point {    int z;    String getLocation() { // 조상의 String getLocation()을 오버라이딩        return \"x : \" + x + \", y : \" + y + \" z : \" + z; // 선언부 변경불가, 구현부 변경가능    }}▶ Object 클래스의 toString()을 오버라이딩▷ p.toString()class Point {    int x;    int y;    public String toString() {        return \"x : \" + x + \", y : \" + y;    }}class OverrideTest {\t\tpublic static void main(String[] args) {\t\t\t\tPoint p = new Point();\t\t\t\tSystem.out.println(p.toString());\t}}// consolex : 0, y : 0▷ p만 넣어도 toString() 출력class OverrideTest {\t\tpublic static void main(String[] args) {\t\t\t\tPoint p = new Point();\t\t\t\tSystem.out.println(p);\t}}// consolex : 0, y : 0▷ 매개변수가 있는 생성자를 이용하여 x, y 출력class Point {    int x;    int y;    Point(int x, int y) {    \tthis.x = x;    \tthis.y = y;    }        public String toString() {        return \"x : \" + x + \", y : \" + y;    }}class OverrideTest {\t\tpublic static void main(String[] args) {\t\t\t\tPoint p = new Point(5, 9);\t\t\t\tSystem.out.println(p);\t}}// consolex : 5, y : 9Ch7 - 8. 오버라이딩의 조건▶ 오버라이딩의 조건 3가지▷ 선언부가 조상 클래스의 메서드와 일치해야 함  선언부의 반환 타입, 메서드 이름, 매개변수 목록 모두 일치해야 함▷ 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없음  접근 제어자 : public, protected, private, defalt▷ 예외는 조상 클래스의 메서드보다 많이 선언할 수 없음Ch7 - 9. 오버로딩 vs. 오버라이딩오버로딩과 오버라이딩은 이름만 비슷할 뿐 전혀 관계 없음▶ 오버로딩(overloading)▷ 기존에 없는 이름이 같은 새로운 메서드를 정의하는 것(new)▷ 상속과 관계無▶ 오버라이딩(overriding)▷ 상속받은 메서드의 내용을 변경하는 것(change, modify)▷ 상속과 관계有class Parent {    void parentMethod() { }}class Child extends Parent {    void parentMethod() { } // 오버라이딩    void parentMethod(int i) { } // 오버로딩        void childMethod() { } // 메서드 정의    void childMethod(int i) { } // 오버로딩    void childMethod() { } // 에러, 중복 정의}",
        "url": "/7cornerstoneJava4"
    }
    ,
    
    "7cornerstonejava3": {
        "title": "Ch7-5~6. object 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 5. 단일 상속  Ch7 - 6. object 클래스 : 모든 클래스의 조상Ch7 - 5. 단일 상속(single ingeritance)▶ 단일 상속이란?▷ java는 단일 상속만 허용class TvDVD extends Tv, DVD { // 에러, 다중 상속 불가    // ...}▷ 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 함package baek_ch02;class Tv {\t\tboolean power;\tint channel;\t\tvoid power()\t{ power = !power; }\tvoid channelUp()\t{ ++channel; }\tvoid channelDown()\t{ --channel; }}class DVD {\tboolean power;\t\tvoid power() { power = !power; }\tvoid play() {  }\tvoid stop() {  }\tvoid rew() {  }\tvoid ff() {  }}class TvDVD extends Tv { // Tv는 상속\tDVD dvd = new DVD(); // DVD는 포함\t\tvoid play() {\t\tdvd.play();\t}\t\tvoid stop() {\t\tdvd.stop();\t}\t\tvoid rew() {\t\tdvd.rew();\t}\t\tvoid ff() {\t\tdvd.ff();\t}}Ch7 - 6. object 클래스 : 모든 클래스의 조상▶ object 클래스란?▷ 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 됨▷ 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속 받음  toString(), equals(Object obj), hashCode(), …  객체 home은 자동으로 최고 조상 Object 클래스를 상속 받음  그래서 home 객체에서 Object에 있는 toString() 사용 가능      class Home { }      class Act {          public static void main(String[] args) {              Home home = new Home();              System.out.println(home.toString());      }  }      ",
        "url": "/7cornerstoneJava3"
    }
    ,
    
    "7cornerstonejava2": {
        "title": "Ch7-2~3. 포함",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 3. 클래스 간의 관계 - 포함관계  Ch7 - 4. 클래스 간의 관계 결정하기Ch7 - 3. 클래스 간의 관계 - 포함관계▶ 포함(composite)이란?▷ 클래스의 멤버로 참조변수를 선언하는 것▷ 작은 단위의 클래스를 만들고, 이들을 조합하여 클래스를 만듦class Car {  Engine e = new Engine(); // 엔진  Door[] d = new Door[4]; // 문, 문의 개수를 넷으로 가정하고 배열로 처리}엔진이나 도어 클래스를 만들어 포함시켜 사용함으로 복잡도↓▶ 원을 그리는 두가지 방법▷ 클래스만 사용class Circle {    int x;    int y;    int r;}  객체로 만들었을 때      Circle c = new Circle();          ▷ 포함 사용class point {    int x;    int y;}class Circle {    point c = new Pint();    int r;}  객체로 만들었을 때      Circle c = new Circle();          ▶ 실습▷ 상속으로 원의 중심과 반지름 출력class point {\tint x;\tint y;}class Circle extends point {\tint r;}class Act {\t\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\t\t\tc.x = 1;\t\tc.y = 2;\t\tc.r = 3;\t\t\t\tSystem.out.printf(\"원의 중심 : (%d, %d)\\n\", c.x, c.y);\t\tSystem.out.printf(\"반지름 : %dcm\" ,c.r);\t}}// console원의 중심 : (1, 2)반지름 : 3cm▷ 포함으로 원의 중심과 반지름 출력class point {\tint x;\tint y;}class Circle {\tPoint p = new Point();\tint r;}class Act {\t\tpublic static void main(String[] args) {\t\tCircle c = new Circle();\t\t\t\tc.p.x = 1;\t\tc.p.y = 2;\t\tc.r = 3;\t\t\t\tSystem.out.printf(\"원의 중심 : (%d, %d)\\n\", c.p.x, c.p.y);\t\tSystem.out.printf(\"반지름 : %dcm\" ,c.r);\t}}// console원의 중심 : (1, 2)반지름 : 3cmCh7 - 4. 클래스 간의 관계 결정하기▶ 상속관계▷ A는 B이다(is)▶ 포함관계▷ A는 B를 가지고 있다(has)  원은 점이다 : X  원은 점을 가지고 있다 : O → 포함    class Circle {Point c = new Point();int r;}       90%는 포함관계로 사용, 상속은 제약이 많기 때문에 꼭 필요할 때만 사용",
        "url": "/7cornerstoneJava2"
    }
    ,
    
    "7cornerstonejava1": {
        "title": "Ch7-1~2. 상속",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter7. 객체지향 프로그래밍Ⅱ  Ch7 - 1. 상속  Ch7 - 2. 상속 예제Ch7 - 1. 상속▶ 상속(inheritance)이란?▷ 기존의 클래스로 새로운 클래스를 작성▷ 코드의 재사용▷ 두 클래스를 부모와 자식으로 관계를 맺어 주는 것▶ 상속 작성 방법class 자식클래스 extends 부모클래스 {    //  ...}class Prent { }class Chind extends Prent {    // ...}▶ 상속 : 부모와 조상 그리고 자식▷ 자손은 조상(부모의 부모)의 모든 멤버를 상속 받음▷ 생성자, 초기화 블럭 제외 후 상속▷ 자손의 멤버 개수는 조상보다 적을 수 없음▷ 자손의 멤버 개수 &gt;= 조상// 부모 : 자신 멤버 1개class Prent {     int age;}// 자식 : 자신 멤버 0개 + 상속 멤버 1개 &gt;= 부모 멤버 1개class Child extends Parent { }▷ 자손의 변경은 조상에 영향을 미치지 않음// 부모 : 자신 멤버 1개class Prent {     int age;}// 자식 : 자신 멤버 1개 + 상속 멤버 1개class Child extends Parent {    void plya() {        System.out.println(\"Play!\");    }}Ch7 - 2. 상속 예제▶ 2차원 좌표의 한 점 : (x, y)class Point {    int x;    int y;}▶ 3차원 좌표의 한 점 : (x, y, z)▷ Point 클래스와 관계없는 클래스 : 부모 클래스의 변경과 관계 없음class Point3D {    int x;    int y;    int z;}  객체로 만들었을 때 모양      Point3D p = new Point3D();          ▷ Point 클래스를 상속 : 부모 클래스의 변경과 관계 있음class Point3D extends Point {    int z;}  객체로 만들었을 때 모양      Point3D p = new Point3D();          ",
        "url": "/7cornerstoneJava1"
    }
    ,
    
    "6cornerstonejava19": {
        "title": "Ch6-38~41. 초기화",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 38. 변수의 초기화  Ch6 - 39. 멤버변수의 초기화  Ch6 - 40. 멤버변수의 초기화 예제1  Ch6 - 41. 멤버변수의 초기화 예제2Ch6 - 38. 변수의 초기화▶ 지역변수(lv)▷ 사용 전 반드시 수동 초기화 해야 함▷ 멤버변수(iv, cv)는 자동 초기화 됨class InitTest{    int x; // iv, 자동 초기화, x = 0    int y = x; // iv, y = x = 0    void method1() {        int i; // lv, 자동 초기화 안됨        int j = i; // lv, j = i = ?, 자동 초기화× → 어떤 값 들어있는 지 모름    }}Ch6 - 39. 멤버변수의 초기화▶ 멤버변수란?▷ iv와 cv▶ 자동 초기화▶ 간단 초기화▷ 명시적 초기화 : =class Car {    int door = 4; // 기본형 변수의 초기화    Engine e = new Engine(); // 참조형 변수의 초기화}▶ 복잡 초기화▷ 초기화 블럭 : {}, static {}  인스턴스(iv) 초기화 블럭 : {} → 거의 사용하지 않음, 생성자로 사용  클래스(cv) 초기화 블럭 : static {}▷ 생성자  인스턴스(iv) 초기화 블럭▶ 멤버변수의 초기화 시점▷ 클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때, 단 한번▷ 인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때마다▶ 멤버변수의 초기화 순서▷ cv → iv▷ 자동 → 간단 → 복잡Ch6 - 40. 멤버변수의 초기화 예제1▶ 간단 초기화, 복잡 초기화class StaticBlockTest {    static int[] arr = new int[10]; // 간단 초기화, 명시적 초기화    static { // 복잡 초기화 : 배열 arr을 난수로 채움        for(int i = 0; i &lt; arr.length; i++) {            arr[i] = (int)(Math.random() * 10) + 1;                }    }}Ch6 - 41. 멤버변수의 초기화 예제2▶ 간단 초기화, 복잡 초기화, 초기화 순서class InintTest {\t\tstatic int cv = 1; // 명시적 초기화\tint iv = 1; // 명시적 초기화\t\tstatic { cv = 2; } // 클래스 초기화 블럭\t{ iv = 2; } // 인스턴스 초기화 블럭\t\tInintTest() { // 생성자\t\tiv = 3;\t}}",
        "url": "/6cornerstoneJava19"
    }
    ,
    
    "6cornerstonejava18": {
        "title": "Ch6-36~37. this",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 36. 생성자에서 다른 생성자 호출하기 : this()  Ch6 - 37. 객체 자신을 가리키는 참조변수 : thisCh6 - 36. 생성자에서 다른 생성자 호출하기 : this()▶ 생성자 this()▷ 생성자에서 다른 생성자 호출 할 때 사용▷ 다른 생성자 호출 시, 첫 줄에서만 사용 가능▷ 코드의 중복제거를 위해 생성자끼리 호출Ch6 - 37. 객체 자신을 가리키는 참조변수 : this▶ 참조변수 this란?▷ this() 생성자 ≠ 참조변수 this▷ 인스턴스 자신을 가리키는 참조변수▷ 인스턴스 메서드(생성자 포함)에서 사용가능▷ 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용▶ 참조변수 this와 생성자 this()",
        "url": "/6cornerstoneJava18"
    }
    ,
    
    "6cornerstonejava17": {
        "title": "Ch6-32~35. constructor",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 32. 생성자(constructor)  Ch6 - 33. 기본 생성자  Ch6 - 34. 매개변수가 있는 생성자  Ch6 - 35. 매개변수가 있는 생성자 예제Ch6 - 32. 생성자(constructor)▶ 생성자(constructor)란?▷ 인스턴스가 생성될 때마다 호출되는 인스턴스 초기화 메서드▷ 인스턴스 = 객체(iv 묶음) 그래서 iv 초기화 메서드▷ 인스턴스 생성 시 수행 할 작업(iv 초기화)에 사용Time t = new Time();t.hour = 12;t.minute = 34;t.second = 56;이걸 한 줄로 할 수 있음 : 생성자 사용Time t = new Time(12, 34, 56);  // 생성자를 추가해 주면, 생성자 호출해서 사용 가능즉 생성자란?iv 초기화를 편리하게 하기 위한 메서드▶ 생성자 작성 규칙▷ 생성자 이름 =  클래스 이름▷ 리턴값 없음 : 항상 반환값이 없기 때문▷ void 안 붙임▷ 모든 클래스는 반드시 하나 이상의 생성자를 가짐▷ 기본 생성자 : 컴파일러가 생성자가 하나도 없을 때 생성 해 줌클래스이름(타입 변수명, 타입 변수명, ...) {    // 인스턴스 생성시 수행 될 코드,    // 주로 인스턴스 변수의 초기화 코드를 적음}▶ 생성자 오버로딩class Card() {    Card() { // 매개변수 없는 생성자        // 인스턴스 초기화 작업    }        Card(String kind, int number) { // 매개변수 있는 생성자        // 인스턴스 초기화 작업    }}Ch6 - 33. 기본 생성자▶ 기본 생성자란?▷ 매개변수가 없는 생성자▷ 생성자가 하나도 없을 때만, 컴파일러가 자동 추가클래스이름() { } // 기본 생성자Point() { } // 직접 작성, Point 클래스의 기본 생성자▷ 생성자는 자동 추가보다 직접 추가로 반드시 넣어 주기class Data_1 {Data_1() {} // 기본 생성자\tint value;}class Data_2 {Data_2() {} // 기본 생성자\tint value;\tData_2(int x) {   // 매개변수가 있는 생성자.\t\tvalue = x;\t}}class Ex6_11 {    public static void main(String[] args) {    Data_1 d1 = new Data_1();        // compile error발생, The constructor Data_2() is undefined    // Data_2() {} 기본 생성자 추가    Data_2 d2 = new Data_2();    }}Ch6 - 34. 매개변수가 있는 생성자▶ 기본 생성자와 매개변수가 있는 생성자class Car {    String color;    String gearType;    int door;        Car() {} // 기본 생성자    Car(String c, String g, int d) { // 매개변수가 있는 생성자        color = c;        gearType = g;        door = d;        }}Ch6 - 35. 매개변수가 있는 생성자 예제▶ iv 초기화를 매개변수가 있는 생성자로▷ iv 초기화Car c = new Car();c.color = \"white\";c.gearType = \"auto\";c.door = 4;▷ iv 초기화 : 매개변수가 있는 생성자class Car {    String color;    String gearType;    int door;        Car() {} // 기본 생성자    Car(String c, String g, int d) { // 매개변수가 있는 생성자        color = c;        gearType = g;        door = d;        }        Car c = new Car(\"white\", \"auto\", 4); // iv 초기화}",
        "url": "/6cornerstoneJava17"
    }
    ,
    
    "6cornerstonejava16": {
        "title": "Ch6-30~31. overloading",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 30. 오버로딩(overloading)  Ch6 - 31. 오버로딩(overloading) 예제Ch6 - 30. 오버로딩(overloading)▶ 오버로딩(overloading)이란?▷ 한 클래스 안에 같은 이름의 메서드를 여러 개 정의하는 것▷ 일반적으로, 메서드 : 메서드 이름 = 1 : 1▷ 오버로딩은, 메서드 : 메서드 이름 = n : 1void println()void println(boolean x)void println(char x)void println(char[] x)void println(double x)void println(float x)void println(int x)void println(long x)void println(object x)void println(String x)오버로딩 지원 시, 매개변수를 통해 메서드를 알아 봄▶ 오버로딩(overloading)이 성립하기 위한 조건▷ 메서드 이름이 같아야 함▷ 매개변수의 개수 또는 타입이 달라야 함▷ 반환 타입은 영향 없음long add(int a, long b) { return a+b; }long add(long a, int b) { return a+b; }▶ 오버로딩(overloading)이 아닌 경우▷ 매개변수의 이름만 다른 경우int add(int a, int b) { return a + b; }int add(int x, int y) { return x + y; }▷ 반환 타입만 다른 경우int add(int a, int b) { return a + b; }long add(int a, int b) { return (long)(a + b); }▷ ambiguous(모호한)add(3, 3);  // 두 개의 add 모두 반응, (3, 3L) → 첫번 째 add 반응long add(int a, long b) { return a+b; }long add(long a, int b) { return a+b; }▶ 메서드 이름▷ add, println, round, random : 대부분 동사 → 작업▷ 메서드 이름이 같다 = 하는 작업이 같다Ch6 - 31. 오버로딩(overloading) 예제▶ 오버로딩의 올바른 예▷ 매개변수는 다르지만 같은 의미의 기능 수행class Hello {\tpublic static void main(String[] args) {\t\t\t\tPlus p = new Plus();\t\t\t\tSystem.out.println(\"int a, int b = \" + p.add(10, 10));\t\tSystem.out.println(\"long a, int b = \" + p.add(10, 10L));\t\tSystem.out.println(\"int a, long b = \" + p.add(10L, 10));\t\tSystem.out.println(\"long a, long b = \" + p.add(10L, 10L));\t\t\t\tint[] a = {100, 200, 400};\t\tSystem.out.println(\"int[] a = \" + p.add(a));\t}}class Plus {\tlong add(int a, int b) {\t\treturn a + b;\t}\t\tlong add(long a, int b) {\t\treturn a + b;\t}\t\tlong add(int a, long b) {\t\treturn a + b;\t}\t\tlong add(long a, long b) {\t\treturn a + b;\t}\t\tint add(int[] a) {\t\tint result = 0;\t\t\tfor(int i = 0; i &lt; a.length; i++) {\t\t\t\tresult += a[i];\t\t\t}\t\treturn result;\t}}// consoleint a, int b = 20long a, int b = 20int a, long b = 20long a, long b = 20int[] a = 700",
        "url": "/6cornerstoneJava16"
    }
    ,
    
    "6cornerstonejava15": {
        "title": "Ch6-26~29. static",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 26. static 메서드와 인스턴스 메서드  Ch6 - 27. static 메서드와 인스턴스 메서드 예제  Ch6 - 28. static을 언제 붙여야 할까?  Ch6 - 29. 메서드 간 호출과 참조Ch6 - 26. static 메서드와 인스턴스 메서드▶ 인스턴스 변수(iv)의 사용 여부▷ iv 사용 = 인스턴스 메서드▷ iv 미사용 = static(클래스) 메서드▶ static 메서드란?▷ = 클래스 메서드▷ 메서드 앞에 static 붙은 것▷ 객체 생성 없이 클래스 이름.메서드 이름()으로 호출Math.random()Math.round()// 객체 생성 없이 사용▷ 인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드▷ 메서드 내, 인스턴스 변수(iv) 사용 불가▶ 인스턴스 메서드란?▷ 메서드 앞에 static 붙지 않은 것▷ 인스턴스 생성 후, 참조변수.메서드 이름()으로 호출▷ 인스턴스 멤버(iv, im)와 관련 된 작업을 하는 메서드▷ 메서드 내, 인스턴스 변수(iv) 사용 가능Ch6 - 27. static 메서드와 인스턴스 메서드 예제▶ static 메서드와 인스턴스 메서드 생성▶ static 메서드와 인스턴스 메서드 호출Ch6 - 28. static을 언제 붙여야 할까?▶ static을 언제 붙여야 할까? - 변수▷ 속성(멤버 변수) 중에서 공통 속성에 static을 붙임class Card {    // 개별 속성 : iv    String sign; // 기호    int number; // 숫자    // 공통 속성 : cv    static int width = 100; // 폭;    static int height = 230; // 높이;}▶ static을 언제 붙여야 할까? - 메서드▷ 인스턴스 멤버(iv, im)을 사용하지 않는 메서드에 static을 붙임class Hello {\t\tlong a, b;\t\tlong add() { return a + b; }   // a, b = 인스턴스 변수\tstatic long add(long a, long b) { return a + b;\t}   // a, b = 지역 변수}Ch6 - 29. 메서드 간 호출과 참조▶ static 메서드는 인스턴스 변수(iv)를 사용 불가▶ static 메서드는 인스턴스 메서드(im)를 사용 불가▶ static 메서드는 static 메서드 호출가능?▷ 네▶ static 메서드는 인스턴스 변수 사용가능?▷ 아니요▶ static 메서드는 인스턴스 메서드 호출가능?▷ 아니요▶ 왜 static 메서드는 인스턴스 멤버를 사용할 수 없는가?▷ static 메서드는 객체 생성없이 항상 사용가능, 그래서 객체(iv)가 없을 수도 있어서",
        "url": "/6cornerstoneJava15"
    }
    ,
    
    "6cornerstonejava14": {
        "title": "Ch6-24~25. 참조형",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 24. 참조형 매개변수  Ch6 - 25. 참조형 반환타입Ch6 - 24. 참조형 매개변수▶ 참조형 매개변수▷ read &amp; write▷ 변수의 값을 읽기 가능▷ 변경 가능▶ 기본형 매개변수▷ read only▷ 변수의 값을 읽기만 가능▷ 변경 불가▶ 실습▷ 참조형 매개변수Ch6 - 25. 참조형 반환타입▶ 참조형 반환타입이란?▷ 객체의 주소를 반환▶ 실습▷ 참조형 반환타입  static 메서드 객체 생성 없이 호출가능  같은 클래스 내 참조 변수 생략 가능",
        "url": "/6cornerstoneJava14"
    }
    ,
    
    "6cornerstonejava13": {
        "title": "Ch6-23. 기본형",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 23. 기본형 매개변수Ch6 - 23. 기본형 매개변수▶ 기본형 매개변수▷ read only▷ 변수의 값을 읽기만 가능▷ 변경 불가▶ 참조형 매개변수▷ read &amp; write▷ 변수의 값을 읽기 가능▷ 변경 가능▶ 실습▷ 기본형 매개변수",
        "url": "/6cornerstoneJava13"
    }
    ,
    
    "6cornerstonejava12": {
        "title": "Ch6-22. call stack",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 22. 호출 스택(call stack)Ch6 - 22. 호출 스택(call stack)▶ 스택(stack)이란?▷ 밑이 막힌 상자, 위로 차곡차곡 쌓임▶ 호출 스택(call stack)이란?▷ 메서드 수행에 필요한 메모리가 제공되는 공간▷ 메서드가 호출되면, 호출 스택에 메로리 할당▷ 종료 시, 해제아래 있는 메서드가 위의 메서드를 호출맨 위의 메서드 하나만 실행 중, 나머지는 대기 중",
        "url": "/6cornerstoneJava12"
    }
    ,
    
    "6cornerstonejava11": {
        "title": "Ch6-20~21. return",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 20. return문  Ch6 - 21. 반환값Ch6 - 20. return문▶ return문이란?▷ 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아 감  반환 타입 : void → return 생략가능      void printGugudan(int dan) {      if (!(2 &lt;= dan &amp;&amp; dan &lt;= 9))          return; // dan의 값이 2 ~ 9가 아닌 경우, 호출한 곳으로 그냥 되돌아 감              for (int i = 1; i &lt; 10; i++) {          System.out.printf(\"%d x %d = %d\", dan, i, i * dan);      }      return; // 생략가능  }        반환 타입 : void가 아닌 경우 → return 생략불가      int multi(int x, int y) {      int result = x * y;              return result;  // 생략불가  }      int max(int a, int b) {      if (a &gt; b) return a;    // 참 : return문 실행, 거짓 : return문 없음 → 에러      else return b;  // 에러 안나도록 return문이 언제나 실행 될 수 있게 작성  }      Ch6 - 21. 반환값▶ 반환값이란?▷ return 옆에 써 주는 값▷ 반환 타입이 void가 아닐 때,▷ 반환 타입 = 반환값 타입 = 반환값을 담는 변수 타입",
        "url": "/6cornerstoneJava11"
    }
    ,
    
    "6cornerstonejava10": {
        "title": "Ch6-17~19. 메서드의 실행",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 17. 메서드의 호출  Ch6 - 18. 메서드의 실행 흐름  Ch6 - 19. 메서드의 실행 흐름 예제Ch6 - 17. 메서드의 호출▶ 메서드 call▷ 메서드를 불러서 일 시키는 역할▷ 메서드 호출 방법메서드이름(작업에 필요한 값1, 값2, ...);  // 값 없을 땐 () 빈칸으로 호출  voidprint99danAll();을 console에 뿌리고 끝저장하지 않음    print99danAll(); //  void print99danAll();        intadd(3, 5)의 결과값 int 8을result에 저장    int add(int x, int y) {  int result = x + y;          return result;}  int result = add(3, 5);      ▶ 매개변수(parameter)▷ 호출과 메서드 사이, 매개체 역할▶ 실습▷ 사칙연산 클래스 + 메서드를 만들고, 호출하여 사용class Hochul {\tpublic static void main(String[] args) {\t\t\t\tSachickYounsan sy = new SachickYounsan();\t\tlong addResult = sy.add(5, 2);\t\tlong subResult = sy.sub(5, 2);\t\tlong multiResult = sy.multi(5, 2);\t\tlong divResult = sy.div(5, 2);\t\t\t\tSystem.out.printf(\"+ = %d\\n\", addResult);\t\tSystem.out.printf(\"- = %d\\n\", subResult);\t\tSystem.out.printf(\"× = %d\\n\", multiResult);\t\tSystem.out.printf(\"÷ = %d\\n\", divResult);\t}}class SachickYounsan {\tlong add(long a, long b) { return a + b; }\tlong sub(long a, long b) { return a - b; }\tlong multi(long a, long b) { return a * b; }\tlong div(long a, long b) { return a / b; }}// console+ = 7- = 3× = 10÷ = 2▷ 두 값을 받아서 둘 중 큰 값을 반환하는 메서드 작성class Hochul {\t\tpublic static void main(String[] args) {\t\t\t\tMax m = new Max();\t\tlong maxResult = m.max(7, 9);\t\t\t\tSystem.out.printf(\"MAX = %d\\n\", maxResult);\t}}class Max {\tlong max(long a, long b) { \t\t\t\treturn a &gt; b ? a : b;\t\t//\t\tif (a &gt; b) result = a;//\t\telse result = b;//\t\treturn result; \t}}// consoleMAX = 9Ch6 - 18. 메서드의 실행 흐름▶ 객체 생성▶ main 메서드에서 메서드 호출▷ 입력한 값이 매개 변수로 복사 대입 즉 입력▶ 호출 된 메서드 문장 실행▷ return문을 만나면 main 메서드로 복귀▶ 복귀 후 main 메서드의 나머지 문장 실행Ch6 - 19. 메서드의 실행 흐름 예제▶ 객체 생성Max m = new Max();▶ main 메서드에서 메서드 호출▷ 입력한 값이 매개 변수로 복사 대입 즉 입력long maxResult = m.max(7, 9);▶ 호출 된 메서드 문장 실행▷ return문을 만나면 main 메서드로 복귀class Max {\tlong max(long a, long b) { \t\t\t\treturn a &gt; b ? a : b;\t}}▶ 복귀 후 main 메서드의 나머지 문장 실행public static void main(String[] args) {        Max m = new Max();    long maxResult = m.max(7, 9);        System.out.printf(\"MAX = %d\\n\", maxResult);}// consoleMAX = 9",
        "url": "/6cornerstoneJava10"
    }
    ,
    
    "6cornerstonejava9": {
        "title": "Ch6-14~16. 메서드",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 14. 메서드란?  Ch6 - 15. 메서드의 선언부  Ch6 - 16. 메서드의 구현부Ch6 - 14. 메서드란?▶ (1) 메서드란?▷ 작업 단위로!!▷ 문장들을 {}로 묶어놓은 것  코드 중복      public static void main(String[] args) {              // 배열 초기화      for (int i = 0; i &lt; 10; i++) {          numArr[i] = (int)(Math.random() + 10);      }          // 배열 출력      for (int i = 0; i &lt; 10; i++) {          System.out.printf(\"%d\", numArr[i]);      }  ...      // 배열 출력 : 코드 중복      for (int i = 0; i &lt; 10; i++) {          System.out.printf(\"%d\", numArr[i]);      }  }        코드 중복 : 메서드로 해결    // 배열 출력 작업 담당 메서드 : 이름 printArr static void printArr(int[] numArr) {     for (int i = 0; i &lt; 10; i++) {         System.out.printf(\"%d\", numArr[i]);     } }    public static void main(String[] args) {             // 배열 초기화     for (int i = 0; i &lt; 10; i++) {         numArr[i] = (int)(Math.random() + 10);     }         // 배열 출력 : 메서드 호출     pirntArr(numArr); ...     // 배열 출력 : 메서드 호출     pirntArr(numArr);     } }      ▶ (2) 메서드란?▷ 값(입력)을 받아서 처리하고, 결과를 반환(출력)▶ 메서드 ≒ 함수▷ 메서드 : 객체지향개념에서 함수를 지칭하는 말  클래스에 종속적 : 반드시 클래스 안에서만▷ 함수  클래스에 독립적 : 어디서든▶ 메서드의 장점▷ 코드의 중복 제거▷ 코드의 관리 용이▷ 코드를 재사용 가능▷ 코드의 간결화▶ 메서드의 작성▷ 반복적으로 수행되는 여러 문장을 메서드로 작성▷ 하나의 메서드는 한 가지 기능만 수행하도록 작성Ch6 - 15. 메서드의 선언부▶ 메서드 = 선언부 + 구현부Ch6 - 16. 메서드의 구현부▶ 지역 변수(lv)▷ 메서드 내(메서드 영역), 선언된 변수▷ 매개 변수(입력)도 지역 변수",
        "url": "/6cornerstoneJava9"
    }
    ,
    
    "6cornerstonejava8": {
        "title": "Ch6-12~13. 변수",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 12. 클래스 변수와 인스턴스 변수  Ch6 - 13. 클래스 변수와 인스턴스 변수 예제Ch6 - 12. 클래스 변수와 인스턴스 변수▶ 클래스 변수와 인스턴스 변수의 차이점▷ 공통 속성 : 클래스 변수(cv)▷ 개별 속성 : 인스턴스 변수(iv)class Card {    // 개별 속성 : iv    String sign; // 기호    int number; // 숫자        // 공통 속성 : cv    static int width = 100; // 폭;    static int height = 230; // 높이;}▶ 클래스 변수와 인스턴스 변수의 사용 방법▷ 객체 생성Card c = new Card();▷ 객체 사용  인스턴스 변수(iv)      c.kind = \"HEART\";  c.number = 5;        클래스 변수(cv)      Card.width = 200;  Card.height = 300;      Ch6 - 13. 클래스 변수와 인스턴스 변수 예제▶ 카드의 공통 속성(cv), 개별 속성(iv) 활용▷ 코드class Ex6_3 {\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Card.width = \" + Card.width);\t\tSystem.out.println(\"Card.height = \" + Card.height);\t\tCard c1 = new Card();\t\tc1.kind = \"Heart\";\t\tc1.number = 7;\t\tCard c2 = new Card();\t\tc2.kind = \"Spade\";\t\tc2.number = 4;\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다.\");\t\tCard.width = 50;\t\tCard.height = 80;\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\");\t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\");\t}}class Card {String kind;int number;static int width = 100;static int height = 250;}// consoleCard.width = 100Card.height = 250c1은 Heart, 7이며, 크기는 (100, 250)c2는 Spade, 4이며, 크기는 (100, 250)c1의 width와 height를 각각 50, 80으로 변경합니다.c1은 Heart, 7이며, 크기는 (50, 80)c2는 Spade, 4이며, 크기는 (50, 80)▷ 그림 그려보며 cv, iv 생각하기",
        "url": "/6cornerstoneJava8"
    }
    ,
    
    "6cornerstonejava7": {
        "title": "Ch6-11. 변수의 종류",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 11. 선언위치에 따른 변수의 종류Ch6 - 11.선언위치에 따른 변수의 종류▶ 변수의 종류는 선언위치에 따라 3가지로 분류▷ 변수의 타입 ≠ 변수의 종류▷ 클래스 영역 : iv, cv▷ 메서드 영역 : lv▶ 클래스 영역▷ 클래스 영역 내에서는 변수 선언, 메서드 선언 등 선언문만 가능class Class { ← 클래스 시작int iv;static int cv; // static iv = cv} ← 클래스 끝▶ 메서드 영역▷ lv의 범위(scope)는 보통 메서드 내clas Class {       void method() { ← 메서드 시작        int lv = 0;    } ← 메서드 끝}",
        "url": "/6cornerstoneJava7"
    }
    ,
    
    "6cornerstonejava6": {
        "title": "Ch6-9~10. 클래스란?",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 9. 클래스의 정의(1) : 데이터와 함수의 결합  Ch6 - 10. 클래스의 정의(2) : 사용자 정의 타입Ch6 - 9. 클래스의 정의(1) : 데이터와 함수의 결합▶ 클래스란?▷ 설계도▷ 데이터 + 함수Ch6 - 10. 클래스의 정의(2) : 사용자 정의 타입▶ 클래스란?▷ 설계도▷ 데이터 + 함수▷ 사용자 정의 타입 : 원하는 타입을 직접 만듦▶ 비객체지향과 객체지향 - 생성▷ 비객체지향 - 변수  시간 관련 변수 필요      int hour;  int minute;  int second;        시간 관련 변수가 많이 필요      int hour1, hour2, hour3;  int minute1, minute2, minute3;  int second1, second2, second3;        변수를 배열로 저장      int [] hour = new int [3];  int [] minute = new int [3];  int [] second = new int [3];      ▷ 객체지향 - 클래스class Time {    int hour;    int minute;    int second;}  시간 관련 변수가 필요? - 객체 생성      Time t = new Time();        시간 관련 변수가 많이 필요? - 객체 많이 생성      Time t1 = new Time();  Time t2 = new Time();  Time t3 = new Time();        객체 배열로 저장    Time[] t = new Time[3];t[0] = new Time();t[1] = new Time();t[2] = new Time();      ▶ 비객체지향과 객체지향 - 사용  12시 34분 56초 저장▷ 비객체지향int hour = 12;int minute = 34;int second = 56;▷ 객체지향Time t = new Time();t.hour = 12;t.minute = 34;t.second = 56;",
        "url": "/6cornerstoneJava6"
    }
    ,
    
    "6cornerstonejava5": {
        "title": "Ch6-8. 객체배열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 8. 객체 배열Ch6 - 8. 객체 배열▶ 객체 배열이란?▷ 객체 배열 == 참조변수 배열▶ 객체 배열 생성 과정▷ 객체 타입의 참조변수 배열 생성Tv Tv1, Tv2, Tv3; == Tv[] tvArr = new Tv[3];Tv[] tvArr = new Tv[3]; // length가 3인 Tv타입의 참조변수 배열▷ 배열의 각 요소에 생성한 객체를 저장tvArr[0] = new Tv();tvArr[1] = new Tv();tvArr[2] = new Tv();생성 ~ 초기값 저장 : 한 번에 하는 법Tv[] tvArr = { new Tv(), new Tv(), new Tv() };",
        "url": "/6cornerstoneJava5"
    }
    ,
    
    "6cornerstonejava4": {
        "title": "Ch6-6~7. 객체 생성·사용",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 6. 객체의 생성과 사용  Ch6 - 7. 객체의 생성과 사용 예제Ch6 - 6. 객체의 생성과 사용▶ 객체의 생성▷ 변수의 생성클래스명 변수명;변수명 = new 클래스명();Tv t;   // 참조변수t - 리모콘t = new Tv();   // 참조변수t(리모콘)와 Tv(제품) 연결▶ 객체의 사용▷ 메서드의 사용① 클래스(설계도) 작성class Tv {String color;boolean power;int channel;    void power()      { }void channelUp()  { channel++; }  void channelDown(){ channel--; }② 객체(제품) 생성Tv t;t = new Tv();  t(리모콘) 타입 == 객체 타입 TvTv t;  참조변수t(리모콘)가 있어야만 객체 사용가능  참조변수t(리모콘)와 객체는 연결하여 사용t = new Tv();③ 객체(제품) 사용 : t(리모콘)으로 접근t.channel = 7;t.channelDown();Ch6 - 7. 객체의 생성과 사용 예제▶ 리모콘t : 1개, 객체 : Tvclass Tv {\tString color;\tboolean power;\tint channel;\tvoid power() {\t\tpower = !power;\t}\tvoid channelUp() {\t\tchannel++;\t}\tvoid channelDown() {\t\tchannel--;\t}}class Act {\tpublic static void main(String[] args) {\t\tTv t;\t\tt = new Tv();\t\tt.channel = 7;\t\tt.channelDown();\t\tSystem.out.println(\"현재 채널 : \" + t.channel);\t}}// console현재 채널 : 6▶ 리모콘t : 2개, 객체 : Tvclass Act {\tpublic static void main(String[] args) {\t\tTv t1 = new Tv();\t\tTv t2 = new Tv();\t\tt1.channel = 8;\t\tt1.channelDown();\t\t\t\tt2.channel = 100;\t\tt2.channelUp();\t\t\t\tSystem.out.println(\"t1 현재 채널 : \" + t1.channel);\t\tSystem.out.println(\"t2 현재 채널 : \" + t2.channel);\t}}// consolet1 현재 채널 : 7t2 현재 채널 : 101t1 = t2;System.out.println(\"t1 현재 채널 : \" + t1.channel);System.out.println(\"t2 현재 채널 : \" + t2.channel);// consolet1 현재 채널 : 101t2 현재 채널 : 101",
        "url": "/6cornerstoneJava4"
    }
    ,
    
    "6cornerstonejava3": {
        "title": "Ch6-5. .java → 多.class...",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 5. 하나의 소스파일에 여러 클래스 작성Ch6 - 5. 하나의 소스파일에 여러 클래스 작성▶ 하나의 소스파일에 여러 클래스 작성하는 방법▷ 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직!▷ 하나의 소스파일에 여러 클래스 작성하는 규칙이 있음▶ 실습▷ 하나의 소스파일에 여러 클래스 작성▷ 이름.java == 이름.class 일치해야 실행▷ 수동으로 실행파일 설정",
        "url": "/6cornerstoneJava3"
    }
    ,
    
    "6cornerstonejava2": {
        "title": "Ch6-2~4. 객체",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 2. 클래스와 객체  Ch6 - 3. 객체의 구성요소 : 속성과 기능  Ch6 - 4. 객체와 인스턴스Ch6 - 2. 클래스와 객체▶ 클래스의 정의▷ 클래스란 객체를 정의해 놓은 것▶ 클래스의 용도▷ 클래스는 객체를 생성하는데 사용▶ 객체의 정의▷ 실제로 존재하는 것, 사물 또는 개념▶ 객체의 용도▷ 객체가 가지고 있는 기능과 속성에 따라 다름Ch6 - 3. 객체의 구성요소 : 속성과 기능▶ 객체 = 속성(변수) + 기능(메서드)▷ 속성(변수)      속성  크기, 길이, 높이, 색상, 볼륨, 채널 등         변수      class Tv {  String color;  boolean power;  int channel;  }          ▷ 기능(메서드)      기능켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경 등         메서드      class Tv {  void power()      { power = !power; }  void channelUp()  { channel++; }    void channelDown(){ channel--; }  }          class Tv는 TV(제품)의 설계도Ch6 - 4. 객체와 인스턴스▶ 객체▷ 모든 인스턴스를 대표하는 일반적 용어▶ 인스턴스▷ 특정 클래스로부터 생성된 객체ex. class Tv로 부터 만들어진 객체(제품) = Tv인스턴스객체 ≒ 인스턴스▶ 인스턴스화▷ 클래스를 만들었으면 따로 객체를 생성해야 클래스 사용 가능▷ 설계도 → 제품▷ 클래스 → 인스턴스(객체)▶ 정리▷ 클래스가 왜 필요?  객체를 생성하기 위해▷ 객체가 왜 필요?  객체를 사용하기 위해▷ 객체를 사용한다는 것은?  객체가 가진 속성과 기능을 사용",
        "url": "/6cornerstoneJava2"
    }
    ,
    
    "6cornerstonejava1": {
        "title": "Ch6-1. 객체지향 언어",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter6. 객체지향 프로그래밍Ⅰ  Ch6 - 1. 객체지향 언어Ch6 - 1. 객체지향 언어▶ 객체지향 언어가 나오기까지▷ 80년 초 소프트웨어의 위기 : 빠른 변화를 못 쫓아감▷ 해결책으로 객체지향 언어를 도입▷ 절차적 → 객체지향▷ 객체지향  코드의 재사용성이 높음  유지보수가 용이 : 빠른 변화에 대한 대처 능력 향상  중복 코드 제거▶ 객체지향 언어▷ 프로그래밍 언어 + 객체지향 개념(규칙)▷ 객체지향 개념(Object Oriented Programming)이란?  캡슐화  상속  추상화  다형성",
        "url": "/6cornerstoneJava1"
    }
    ,
    
    "5cornerstonejava11": {
        "title": "Ch5-24. Arrays",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 24. Arrays로 배열 다루기Ch5 - 24. Arrays로 배열 다루기▶ 배열의 비교와 출력▷ Arrays.equals() : 1차원 배열 비교String[][] str2D = new String[][] { { \"aaa\", \"bbb\" }, { \"AAA\", \"BBB\" } };String[][] str2D2 = new String[][] { { \"aaa\", \"bbb\" }, { \"AAA\", \"BBB\" } };System.out.println(Arrays.equals(str2D, str2D2));// consolefalse비교불가▷ Arrays.deepEquals() : 2차원 이상 다차원 비교String[][] str2D = new String[][] { { \"aaa\", \"bbb\" }, { \"AAA\", \"BBB\" } };String[][] str2D2 = new String[][] { { \"aaa\", \"bbb\" }, { \"AAA\", \"BBB\" } };System.out.println(Arrays.deepEquals(str2D, str2D2));// consoletrue▷ Arrays.toString() : 1차원 배열 출력int[] arr = { 0, 1, 2, 3, 4 };System.out.println(Arrays.toString(arr));// console[0, 1, 2, 3, 4]▷ Arrays.deepToString() : 2차원 이상 다차원 배열 출력int[][] arr2D = { { 11, 12 }, { 21, 22 } };System.out.println(Arrays.deepToString(arr2D));// console[[11, 12], [21, 22]]▶ 배열의 복사▷ copyOf(메서드, 복사 수)arr의 0 ~ 복사 수까지 복사  Arrays.copyOf(arr, arr.length);      int[] arr = {0, 1, 2, 3, 4};  int[] arr2 = Arrays.copyOf(arr, arr.length);      System.out.println(Arrays.toString(arr2));      // console  [0, 1, 2, 3, 4]        Arrays.copyOf(arr, 3);    int[] arr = {0, 1, 2, 3, 4};int[] arr3 = Arrays.copyOf(arr, 3);  System.out.println(Arrays.toString(arr3));  // console[0, 1, 2]        Arrays.copyOf(arr, 7);    int[] arr4 = Arrays.copyOf(arr, 7);  System.out.println(Arrays.toString(arr4));    // console[0, 1, 2, 3, 4, 0, 0]      ▷ copyOfRange(메서드, 복사 범위의 첫 인덱스, 복사 범위의 마지막 인덱스)from ~ to의 개념첫 인덱스 ~ 마지막 인덱스to는 to - 1 : [마지막 인덱스]는 미포함 [마지막 인덱스 - 1]은 포함  Arrays.copyOfRange(arr, 0, arr.length);    int[] arr = {0, 1, 2, 3, 4};  int[] arr5 = Arrays.copyOfRange(arr, 0, arr.length);  // arr의 [0] ~ [5 - 1]  System.out.println(Arrays.toString(arr5));  // console[0, 1, 2, 3, 4]        Arrays.copyOfRange(arr, 2, 4);    int[] arr = {0, 1, 2, 3, 4};  int[] arr6 = Arrays.copyOfRange(arr, 2, 4); // arr의 [2] ~ [4 - 1]  System.out.println(Arrays.toString(arr6));  // console[2, 3]        Arrays.copyOfRange(arr, 3, 9);    int[] arr = {0, 1, 2, 3, 4};  int[] arr7 = Arrays.copyOfRange(arr, 3, 9); // arr의 [3] ~ [9 - 1]  System.out.println(Arrays.toString(arr7));  // console[3, 4, 0, 0, 0, 0]          ▶ 배열의 정렬 - 오름차순▷ sort()int[] arr = {4, 5, 3, 2, 1};Arrays.sort(arr);System.out.println(Arrays.toString(arr));// console[1, 2, 3, 4, 5]",
        "url": "/5cornerstoneJava11"
    }
    ,
    
    "5cornerstonejava10": {
        "title": "Ch5-21~23. 2차원 배열 예제",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 21. 2차원 배열의 초기화 예제1  Ch5 - 22. 2차원 배열의 초기화 예제2  Ch5 - 23. 2차원 배열의 초기화 예제3Ch5 - 21. 2차원 배열의 초기화 예제1▶ 2차원 배열의 모든 값 더하기▷ 변수 sum에 더한 값 저장▷ 2차원 배열의 값을 모두 꺼내려면, 이중 for문 이용int[][] score = {                {100, 100, 100}                , {20, 20, 20}                , {30, 30, 30}                , {40, 40, 40}                  };int sum = 0;for (int i = 0; i &lt; score.length; i++) {    for (int j = 0; j &lt; score[i].length; j++) {        System.out.printf(\"score[%d][%d] = %d\\n\", i, j, score[i][j]);                sum += score[i][j];    }    System.out.println(\"---\");}System.out.println(\"sum = \" + sum);// consolescore[0][0] = 100score[0][1] = 100score[0][2] = 100---score[1][0] = 20score[1][1] = 20score[1][2] = 20---score[2][0] = 30score[2][1] = 30score[2][2] = 30---score[3][0] = 40score[3][1] = 40score[3][2] = 40---sum = 570Ch5 - 22. 2차원 배열의 초기화 예제2▶ 국, 영, 수 성적의 총점과 평균값 구하기▷ 번호별 국, 영, 수 성적 총점 구하기▷ 번호별 국, 영, 수 성적 평균 구하기int[][] score = {                {100, 100, 100}                , {20, 20, 20}                , {30, 30, 30}                , {40, 40, 40}                  };\t\tint sum = 0;for (int i = 0; i &lt; score.length; i++) {    System.out.println(\"번호 \" + (i + 1));    System.out.printf(\"%s %s %s\\n\", \"국어\", \"수학\", \"영어\");        for (int j = 0; j &lt; score[i].length; j++) {        System.out.printf(\"%3d \", score[i][j]);                sum += score[i][j];    }    System.out.printf(\"\\n총점 %d\", sum);    System.out.printf(\"\\n평균 %f\", sum/(float)score[i].length);    System.out.printf(\"\\n---\\n\");}System.out.println(\"전체 총점 = \" + sum);// console번호 1국어 수학 영어100 100 100 총점 300평균 100.000000---번호 2국어 수학 영어 20  20  20 총점 360평균 120.000000---번호 3국어 수학 영어 30  30  30 총점 450평균 150.000000---번호 4국어 수학 영어 40  40  40 총점 570평균 190.000000---전체 총점 = 570Ch5 - 23. 2차원 배열의 초기화 예제3▶ 퀴즈▷ 배열의 인덱스 이용String[][] question = { { \"cup\", \"컵\" }, { \"integer\", \"정수\" }, { \"cat\", \"고양이\" }, { \"angel\", \"천사\" } };Scanner scanner = new Scanner(System.in);for (int i = 0; i &lt; question.length; i++) {    System.out.printf(\"Q%d. %s의 뜻은? \\n&gt; \", (i + 1), question[i][0]);    String inputString = scanner.nextLine();        if (inputString.equals(question[i][1])) {        System.out.printf(\"정답!\\n\\n\");    } else {        System.out.println(\"오답!\");        System.out.printf(\"정답은 %s\\n\\n\", question[i][1]);    }}// consoleQ1. cup의 뜻은?&gt; cup오답!정답은 컵Q2. integer의 뜻은?&gt; 정수정답!Q3. cat의 뜻은?&gt; 고양이정답!Q4. angel의 뜻은?&gt; 1004오답!정답은 천사",
        "url": "/5cornerstoneJava10"
    }
    ,
    
    "5cornerstonejava9": {
        "title": "Ch5-18~20. 2차원 배열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 18. 2차원 배열의 선언  Ch5 - 19. 2차원 배열의 인덱스  Ch5 - 20. 2차원 배열의 초기화Ch5 - 18. 2차원 배열의 선언▶ 2차원 배열이란?▷ 테이블 형태의 데이터를 저장하기 위한 배열▷ 1차원 배열이 여러 개 모인 배열int[][] score = new int[4][3];Ch5 - 19. 2차원 배열의 인덱스▶ 2차원 배열의 인덱스란?▷ 0에서 시작▷ 행의 길이 - 1 까지▷ 열의 길이 - 1 까지int[][] score = new int[4][3];score[0][0] = 100;System.out.println(score[0][0]);// console100Ch5 - 20. 2차원 배열의 초기화▶ 2차원 배열의 초기화란?▷ 2차원 배열 생성 시, 초기화 방법int[][] score = { {1, 2, 3,}, {4, 5, 6} };int[][] score = {                {1, 2, 3}                , {4, 5, 6}                  };int[][] score = {                {100, 100, 100}                , {20, 20, 20}                , {30, 30, 30}                , {40, 40, 40}                  };",
        "url": "/5cornerstoneJava9"
    }
    ,
    
    "5cornerstonejava8": {
        "title": "Ch5-16~17. 커맨드라인",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 16. 커맨드라인을 통해 입력받기  Ch5 - 17. 이클립스 : 커맨드라인 입력받기Ch5 - 16. 커맨드라인을 통해 입력받기▶ 실습▷ 커맨드라인에 입력한 값이 문자열 배열에 담겨서 전달▷ 123 abc “hello world” 출력public static void main(String[] args) {    System.out.println(\"매개변수의 개수:\"+args.length);    for(int i=0;i&lt; args.length;i++) {        System.out.println(\"args[\" + i + \"] = \\\"\"+ args[i] + \"\\\"\");    }}// console매개변수의 개수:0Ch5 - 17. 이클립스 : 커맨드라인 입력받기▶ 실습▷ 커맨드라인에 입력한 값이 문자열 배열에 담겨서 전달▷ 123 abc “hello world” 출력",
        "url": "/5cornerstoneJava8"
    }
    ,
    
    "5cornerstonejava7": {
        "title": "Ch5-14~15. Stirng 클래스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 14. String 클래스  Ch5 - 15. Stirng 클래스의 주요 메서드Ch5 - 14. Stirng 클래스▶ String 클래스란?▷ String 클래스는 char[]와 메서드(기능)를 결합한 것String 클래스 = char[] + 메서드(기능)▷ String 클래스는 내용을 변경할 수 없다(read only)String a = \"a\";String b = \"b\";a = a + b;  // \"a\" + \"b\" = \"ab\"  “a”가 “ab”로 바뀌는 게 아님  변수 a가 “a”가 아닌 “ab”를 가리키는 것Ch5 - 15. Stirng 클래스의 주요 메서드▶ [char] str.charAt(int index)▷ 문자열에서 해당 위치(index)에 있는 문자를 반환String str = \"ABCDE\";char ch = str.charAt(3); // 문자열 str의 4번째 문자 'D'를 ch에 저장System.out.println(ch);// consoleD▶ [String] str.length()▷ 문자열의 길이를 반환String str = \"ABCDE\";System.out.println(str.length());// console5▶ [String] str.substring(int from, int to)▷ 문자열에서 해당 범위(from ~ to)의 문자열을 반환(to는 미포함)String str = \"ABCDE\";System.out.println(str.substring(0, 4));// consoleABCD▶ [boolean] str.equals(Object obj)▷ 문자열의 내용이 같은지 확인▷ 같으면 true▷ 다르면 falseString str = \"ABCDE\";System.out.println(str.equals(\"ABCDE\"));// consoletrue▶ [char[]] str.toCharArray()▷ 문자열을 문자배열(char[])로 변환해서 반환String str = \"ABCDE\";System.out.println(str.toCharArray());// consoleABCDE",
        "url": "/5cornerstoneJava7"
    }
    ,
    
    "5cornerstonejava6": {
        "title": "Ch5-12~13. String 배열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 12. String 배열의 선언과 생성  Ch5 - 13. String 배열의 초기화Ch5 - 12. String 배열의 선언과 생성▶ String 배열이란?▷ 여러 개의 문자열을 저장할 수 있는 배열▶ String 배열 선언과 생성▷ String 배열 선언과 생성String[] name = new String[3];Ch5 - 13. String 배열의 초기화▶ 초기값 참고표▶ String 배열 생성 후, 초기화name[0] = \"Kim\";name[1] = \"Park\";name[2] = \"Yi\";▶ String 배열 생성 시, 초기화String[] name = {\"Kim\", \"Park\", \"Yi\"};▶ 실습▷ {가위, 바위, 보} 랜덤으로 출력 하기String[] strArrStrings = {\"가위\", \"바위\", \"보\"};System.out.println(Arrays.toString(strArrStrings));for (int i = 0; i &lt; 10; i++) {    int tmp = (int) (Math.random() * 3);    System.out.println(strArrStrings[tmp]);}//console[가위, 바위, 보]바위보보바위가위가위보가위바위보",
        "url": "/5cornerstoneJava6"
    }
    ,
    
    "5cornerstonejava5": {
        "title": "Ch5-10~11. 배열 섞기",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 10. 배열의 활용(3) 섞기(shuffle)  Ch5 - 11. 배열의 활용(4) 로또 번호 만들기Ch5 - 10. 배열의 활용(3) 섞기(shuffle)▶ 섞기?▷ 배열의 요소의 순서를 반복해서 바꿈▶ 숫자 섞기▷ numArr[0] ↔ numArr[random] : 100번 반복int numArr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};System.out.println(Arrays.toString(numArr));for (int i = 0; i &lt; 100; i++) {        int random = (int)(Math.random() * 10);    int tmp = numArr[0];    numArr[0] = numArr[random];    numArr[random] = tmp;}System.out.println(Arrays.toString(numArr));// console[0, 1, 2, 3, 4, 5, 6, 7, 8, 9][5, 0, 3, 6, 2, 4, 1, 8, 9, 7]  계산과정      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]      0번째 반복  numArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  random = 2      numArr[0] = 0 → tmp에 저장  numArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  tmp = 0      numArr[2(random)] = 2 → numArr[0] = 2에 붙여넣기  numArr = [2, 1, 2, 3, 4, 5, 6, 7, 8, 9]  random = 2      tmp = 0를 → numArr[2(random)]에 저장  numArr = [2, 1, 0, 3, 4, 5, 6, 7, 8, 9]  tmp = 0      1번째 반복  numArr = [2, 1, 0, 3, 4, 5, 6, 7, 8, 9]  random = 5      numArr[0] = 2 → tmp에 저장  numArr = [2, 1, 0, 3, 4, 5, 6, 7, 8, 9]  tmp = 2      numArr[5(random)] = 5 → numArr[0] = 5에 붙여넣기  numArr = [5, 1, 0, 3, 4, 5, 6, 7, 8, 9]  random = 5      tmp = 2를 → numArr[5(random)]에 저장  numArr = [5, 1, 0, 3, 4, 2, 6, 7, 8, 9]  tmp = 2      ...          98번째 반복  numArr = [0, 7, 3, 6, 2, 4, 1, 8, 9, 5]  random = 1      numArr[0] = 0 → tmp에 저장  numArr = [0, 7, 3, 6, 2, 4, 1, 8, 9, 5]  tmp = 0      numArr[1(random)] = 7 → numArr[0] = 7에 붙여넣기  numArr = [7, 7, 3, 6, 2, 4, 1, 8, 9, 5]  random = 1      tmp = 0를 → numArr[1(random)]에 저장  numArr = [7, 0, 3, 6, 2, 4, 1, 8, 9, 5]  tmp = 0      99번째 반복  numArr = [7, 0, 3, 6, 2, 4, 1, 8, 9, 5]  random = 9      numArr[0] = 7 → tmp에 저장  numArr = [7, 0, 3, 6, 2, 4, 1, 8, 9, 5]  tmp = 7      numArr[9(random)] = 5 → numArr[0] = 5에 붙여넣기  numArr = [5, 0, 3, 6, 2, 4, 1, 8, 9, 5]  random = 9      tmp = 7를 → numArr[9(random)]에 저장  numArr = [5, 0, 3, 6, 2, 4, 1, 8, 9, 7]  tmp = 7      [5, 0, 3, 6, 2, 4, 1, 8, 9, 7]      ▷ numArr[0] ↔ numArr[random] : numArr.length 만큼 반복int numArr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};System.out.println(\"최초. \" + Arrays.toString(numArr));    for (int i = 0; i &lt; numArr.length; i++) {        int random = (int)(Math.random() * 10);    int tmp = numArr[i];    numArr[0] = numArr[random];    numArr[random] = tmp;    System.out.println(i + \"번째 섞기. \" + Arrays.toString(numArr));}System.out.println(\"최종. \" + Arrays.toString(numArr));// console최초. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]0번째 섞기. [9, 1, 2, 3, 4, 5, 6, 7, 8, 0]1번째 섞기. [6, 1, 2, 3, 4, 5, 1, 7, 8, 0]2번째 섞기. [2, 1, 2, 3, 4, 5, 1, 7, 8, 0]3번째 섞기. [8, 1, 2, 3, 4, 5, 1, 7, 3, 0]4번째 섞기. [4, 1, 2, 3, 4, 5, 1, 7, 3, 0]5번째 섞기. [1, 5, 2, 3, 4, 5, 1, 7, 3, 0]6번째 섞기. [5, 1, 2, 3, 4, 5, 1, 7, 3, 0]7번째 섞기. [7, 1, 2, 3, 4, 5, 1, 7, 3, 0]8번째 섞기. [1, 1, 2, 3, 4, 5, 3, 7, 3, 0]9번째 섞기. [4, 1, 2, 3, 0, 5, 3, 7, 3, 0]최종. [4, 1, 2, 3, 0, 5, 3, 7, 3, 0]Ch5 - 11. 배열의 활용(4) 로또 번호 만들기▶ 로또 번호 만들기▷ 배열 45개에 값 넣기int rotto[] = new int[45];for (int i = 0; i &lt; rotto.length; i++) {rotto[i] = i + 1;System.out.printf(\"[%d]\", rotto[i]);}// console[1][2][3][4][5][6][7][8][9][10]...[40][41][42][43][44][45]▷ 6번 섞기int rotto[] = new int[45];for (int i = 0; i &lt; rotto.length; i++) {    rotto[i] = i + 1;}for (int j = 0; j &lt; 6; j++) {        int random = (int)(Math.random() * 45);    int tmp = rotto[j];    rotto[j] = rotto[random];    rotto[random] = tmp;    System.out.println(Arrays.toString(rotto));}// console[44, 2, 3, 4, 5, 6, 7, 8, 9, 10, ... 42, 43, 1, 45][44, 6, 3, 4, 5, 2, 7, 8, 9, 10, ... 42, 43, 1, 45][44, 6, 27, 4, 5, 2, 7, 8, 9, 10, ... 42, 43, 1, 45][44, 6, 27, 18, 5, 2, 7, 8, 9, 10, ... 42, 43, 1, 45][44, 6, 27, 18, 25, 2, 7, 8, 9, 10, ... 42, 43, 1, 45][44, 6, 27, 18, 25, 35, 7, 8, 9, 10, ... 42, 43, 1, 45]▷ 6개 당청번호 출력int rotto[] = new int[45];for (int i = 0; i &lt; rotto.length; i++) {    rotto[i] = i + 1;}for (int j = 0; j &lt; 6; j++) {        int random = (int)(Math.random() * 45);    int tmp = rotto[j];    rotto[j] = rotto[random];    rotto[random] = tmp;}for (int t = 0; t &lt; 6; t++) {        System.out.printf(\"[%d]\", rotto[t]);}// console[7][6][4][44][19][23]",
        "url": "/5cornerstoneJava5"
    }
    ,
    
    "5cornerstonejava4": {
        "title": "Ch5-8~9. 배열 총합·평균",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 8. 배열의 활용(1) 총합과 평균  Ch5 - 9. 배열의 활용(2) 최대값과 최소값Ch5 - 8. 배열의 활용(1) 총합과 평균▶ 총합과 평균?▷ 배열의 모든 요소를 더해서 총합과 평균을 구함▶ 총합구하기int sum = 0;int[] iArr = { 1, 2, 3, 4, 100, -8 };for (int i = 0; i &lt; iArr.length; i++) {        System.out.printf(\"%d + %d = \", sum, iArr[i]);    sum += iArr[i];    System.out.printf(\"%d\\n\", sum);}System.out.printf(\"\\ntotal sum &gt; %d\", sum);// console0 + 1 = 11 + 2 = 33 + 3 = 66 + 4 = 1010 + 100 = 110110 + -8 = 102total sum &gt; 102▶ 평균구하기▷ 총합 ÷ 배열의 길이▷ 정확한 평균을 위해 float로 형변환int sum = 0;float average = 0f;int[] iArr = { 100, 50, 90, 80 };for (int i = 0; i &lt; iArr.length; i++) {        System.out.printf(\"%d + %d = \", sum, iArr[i]);    sum += iArr[i];    System.out.printf(\"%d\\n\", sum);}average = sum / (float)iArr.length;System.out.printf(\"\\n%d ÷ %f = %f\\n\", sum, (float)iArr.length, average);System.out.printf(\"\\ntotal sum &gt; %d\\n\", sum);System.out.printf(\"average &gt; %f\", average);// console0 + 100 = 100100 + 50 = 150150 + 90 = 240240 + 80 = 320320 ÷ 4.000000 = 80.000000total sum &gt; 320average &gt; 80.000000Ch5 - 9. 배열의 활용(2) 최대값과 최소값▶ 최대값과 최소값?▷ 배열의 요소 중에서 제일 큰 값과 제일 작은 값을 찾음int[] score = {77, 88, 33, 44, 222};int max = score[0];int min = score[0];for (int i = 1; i &lt; score.length; i++) {    if (score[i] &gt; max) {                System.out.println(\"max\");        System.out.printf(\"%d &gt; %d : %b\\n\", score[i], max, score[i] &gt; max);                max = score[i];        System.out.printf(\"max = %d\\n\\n\", max);    } else if (score[i] &lt; min) {        System.out.println(\"min\");        System.out.printf(\"%d &lt; %d : %b\\n\", score[i], min, score[i] &lt; min);        min = score[i];                System.out.printf(\"min = %d\\n\\n\", min);    }}System.out.println(\"max = \" + max);System.out.println(\"min = \" + min);// consolemax88 &gt; 77 : truemax = 88min33 &lt; 77 : truemin = 33max222 &gt; 88 : truemax = 222max = 222min = 33  score[i] &gt; max : true면 max(if문)  score[i] &gt; max : false면 min(else if문)",
        "url": "/5cornerstoneJava4"
    }
    ,
    
    "5cornerstonejava3": {
        "title": "Ch5-6~7. 배열 출력",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 6. 배열의 출력  Ch5 - 7. 배열의 출력 예제Ch5 - 6. 배열의 출력▶ 배열에 저장된 모든 값을 출력하려면?int[] iArr = {100, 95, 80, 70, 60};▷ System.out.println으로 출력  [I@7637f22이런 문자열 출력[I : int 배열7637f22 : 배열의 주소(?)  뒤 숫자는 배열마다 다 다르게 나옴System.out.println(iArr);// console[I@7637f22  예외 : char타입은 System.out.println으로 출력가능      char[] chArr = {'a', 'b', 'c', 'd'};      System.out.println(chArr);      // console  abcd      ▷ for문으로 출력모든 배열의 요소 출력int[] iArr = {100, 95, 80, 70, 60};for (int i = 0; i &lt; iArr.length; i++) {        System.out.printf(\"iArr[%d] = %d\\n\", i, iArr[i]);}// consoleiArr[0] = 100iArr[1] = 95iArr[2] = 80iArr[3] = 70iArr[4] = 60▷ Arrays.toString으로 출력Arrays.toString(배열이름)   // 배열을 to Stringint[] iArr = {100, 95, 80, 70, 60};System.out.printf(Arrays.toString(iArr));// console[100, 95, 80, 70, 60]Ch5 - 7. 배열의 출력 예제▶ 1 ~ 10의 숫자를 순서대로 배열에 넣기▷ for문int[] iArr = new int[10];for (int i = 0; i &lt; iArr.length; i++) {    iArr[i] = i + 1;    System.out.println(iArr[i]);}// console12345678910▶ 1 ~ 10의 숫자를 랜덤으로 배열에 넣기▷ Math.random(), for문for (int i = 0; i &lt; iArr.length; i++) {\t\t\t    iArr[i] = (int)(Math.random() * 10) + 1;    System.out.println(iArr[i]);}// console10167594912▶ 배열의 선언 시 저장한 값을 출력▷ Arrays.toString()int[] iArr = { 1, 2, 3, 4, 100, -8 };System.out.println(Arrays.toString(iArr));// console[1, 2, 3, 4, 100, -8]",
        "url": "/5cornerstoneJava3"
    }
    ,
    
    "5cornerstonejava2": {
        "title": "Ch5-4~5. 배열 초기화",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 4. 배열의 길이(배열이름.length)  Ch5 - 5. 배열의 초기화Ch5 - 4. 배열의 길이(배열이름.length)▶  배열의 길이란?▷ 배열의 길이는 배열이름.length를 통해 알아낼 수 있음▷ 배열은 한 번 생성하면 실행하는 동안 그 길이를 바꿀 수 없음int[] arr = new int[5];int tmp = arr.length;   // arr.length = 5, tmp = 5System.out.println(tmp);// console5▷ 그래서 배열이름.length = 배열의 길이(int형 상수)int[] score = new int[6];for (int i = 0; i &lt; score.length; i++) {    System.out.println(score[i]);}for (int i = 0; i &lt; score.length; i++)배열의 길이인 6을 찍어주지 않고 score.length를 찍음int[] score = new int[6];에서 int[5]로 변경그럼 자동으로 for문 조건식은 5로 변경굳이 바꿔주지 않아도 됨변경에 유리▶  실습int[] arr = new int[5];    for (int i = 0; i &lt; arr.length; i++) {        System.out.println(\"arr.length[\" + i + \"] = \" + arr[i]);    }    // consolearr.length[0] = 0arr.length[1] = 0arr.length[2] = 0arr.length[3] = 0arr.length[4] = 0Ch5 - 5. 배열의 초기화▶ 배열의 초기화▷ 배열의 각 요소에 처음으로 값을 저장하는 것▷ 배열은 기본적으로 초기화가 됨int i;  // i = 0으로 초기화▶ 배열의 초기화 방법▷ 변수에 값 넣듯 하나씩 초기화int[] score = new int[5];score[0] = 50;score[1] = 60;score[2] = 70;score[3] = 80;score[4] = 90;▷ 반복문 초기화int[] score = new int[5];for (int i = 0; i &lt; score.length; i++) {    System.out.printf(\"score[%d] = \", i);    System.out.println((i * 10) + 50);}// consolescore[0] = 50score[1] = 60score[2] = 70score[3] = 80score[4] = 90▷ 괄호 초기화int[] score = new int[]{50, 60, 70, 80, 90};    // new int[] 생략가능for (int i = 0; i &lt; score.length; i++) {        System.out.printf(\"score[%d] = %d\\n\", i, score[i]);}// consolescore[0] = 50score[1] = 60score[2] = 70score[3] = 80score[4] = 90  주의    int[] score = {50, 60, 70, 80, 90};        이 방식을 두 줄로 나눠쓰면 에러    int[] score;score = {50, 60, 70, 80, 90}    // 에러      ",
        "url": "/5cornerstoneJava2"
    }
    ,
    
    "5cornerstonejava1": {
        "title": "Ch5-1~3. 배열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter5. 배열  Ch5 - 1. 배열이란?  Ch5 - 2. 배열의 선언과 생성  Ch5 - 3. 배열의 인덱스Ch5 - 1. 배열이란?▶ 배열이란?▷ 배열은 같은 타입의 여러변수를 하나의 묶음으로 다루는 것▶ 변수와 배열 - 5명의 성적을 저장할 공간▷ 변수int score1, score2, score3, score4, score5; ▷ 배열int[] score = new int[5]    // int[] × 5 : 5개 저장공간 생성Ch5 - 2. 배열의 선언과 생성▶ 배열의 선언이란?▷ 배열을 다루기 위한 참조변수의 선언▶ 배열의 선언방법▷ ① 타입[] 변수이름;int[] score;▷ ② 타입 변수이름[];int score[];▶ 배열의 생성▷ 참조변수와 배열의 연결▶ 배열의 생성 방법▷ ① 배열의 선언int[] score;▷ ② 배열의 생성score = new int[5];참조변수를 통해서 배열을 다룰 수 있다!▶ 배열의 선언과 생성▷ 배열의 선언과 생성을 한 번에int[] score;    // 배열의 선언score = new int[5]; // 배열의 생성int[] score = new int[5];   // 배열의 선언과 생성을 한 번에Ch5 - 3. 배열의 인덱스▶ 배열의 인덱스란?▷ 배열의 각 요소(저장공간)에 자동으로 붙는 번호(일련 번호)▷ 인덱스의 범위는 ‘0’부터 ‘배열길이 -1’까지(0부터 시작하니까 -1)▶ 배열의 인덱스 사용 방법▷ 변수 사용방법과 같음int[] score = new int[5];score[3] = 100;int value = score[3];▶ 실습int[] score = new int[5];score[3] = 100;System.out.println(\"score[0] = \" + score[0]);System.out.println(\"score[1] = \" + score[1]);System.out.println(\"score[2] = \" + score[2]);System.out.println(\"score[3] = \" + score[3]);System.out.println(\"score[4] = \" + score[4]);int value = score[3];System.out.println(\"value = \" + value);// consolescore[0] = 0score[1] = 0score[2] = 0score[3] = 100score[4] = 0value = 100",
        "url": "/5cornerstoneJava1"
    }
    ,
    
    "4cornerstonejava8": {
        "title": "Ch4-20~24. break문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 20. break문  Ch4 - 21. continue문  Ch4 - 22. break문과 continue문 예제  Ch4 - 23. 이름 붙은 반복문  Ch4 - 24. 이름 붙은 반복문 예제Ch4 - 20. break문▶ break문이란?▷ 자신이 포함된 하나의 반복문을 벗어남▶ for문과 while문 - break문▷ while문 break문while (true) {  // 무한반복 = ture(생략불가)    if (sum &gt; 100)        break;    sum = 101;}System.out.println(\"무한반복 BREAK!\");// console무한반복 BREAK!▷ for문 break문for (;;) {  // 무한반복 = true(생략가능, ;;로 표기가능)    if (sum &gt; 100)        break;    sum = 101;}System.out.println(\"무한반복 BREAK!\");// console무한반복 BREAK!Ch4 - 21. continue문▶ continue문이란?▷ 자신이 포함된 반복문의 끝으로 이동▷ 다음 반복으로 넘어감▷ 전체 반복 중에서 특정 조건 시 반복을 건너 뛸 때 적합for (int i = 0; i &lt; 10; i++) {    if (i % 3 == 0) {        continue;   // if의 조건식이 true일 때, for문 하나 나감    }     System.out.println(i);}// console// 0 % 3 = 0 → 그래서 0도 건너띔12// 3 → 3의 배수 부분만 건너띔45// 678// 9Ch4 - 22. break문과 continue문 예제▶ 메뉴▷ 메뉴 입력 시, continue문▷ 종료 시, break문while (true) {    System.out.println(\"{MENU}\");    System.out.println(\"[121]\");    System.out.println(\"[131]\");    System.out.println(\"[180] : OFF\");    System.out.print(\"menu &gt; \");        Scanner scanner = new Scanner(System.in);    int menuS = scanner.nextInt();        switch (menuS) {                case 180: {            System.out.printf(\"종료\\n\\n\");            break;        }                case 121: {            System.out.printf(\"하이!에이치아이~\\n\\n\");            continue;        }                case 131: {            System.out.printf(\"바이!짜이찌엔~\\n\\n\");            continue;        }                default: {            System.out.printf(\"재입력\\n\\n\");            continue;        }    }}// console{MENU}[121][131][180] : OFFmenu &gt; 188재입력{MENU}[121][131][180] : OFFmenu &gt; 121하이!에이치아이~{MENU}[121][131][180] : OFFmenu &gt; 131바이!짜이찌엔~{MENU}[121][131][180] : OFFmenu &gt; 180종료{MENU}[121][131][180] : OFFmenu &gt; Ch4 - 23. 이름 붙은 반복문▶ 이름 붙은 반복문이란?▷ break문 : 하나의 반복문을 벗어남▷ 그런데 중첩 for문 처럼 brea문이 하나 이상의 for문을 벗어나야 한다면?▷ 반복문에 이름을 붙여서 하나 이상의 반복문을 벗어남▶ break문과 이름붙은 break문▷ break문int i;\t\tLoop1 : for (i = 1; i &lt;= 5; i++) {        System.out.printf(\"여기는 Loop1-for문\\n\");        for (;;) {                System.out.printf(\"여기는 Loop1-for문-중첩for문\\n\");        System.out.printf(\"%d번째 탈출시도!\\n\", i);        System.out.printf(\"%d번째 탈출실패ㅠㅠ\\n\\n\", i);        break;    }}System.out.printf(\"NONO~\\n\");System.out.printf(\"%d번째 탈출성공!!!\", i - 1);// console여기는 Loop1-for문여기는 Loop1-for문-중첩for문1번째 탈출시도!1번째 탈출실패ㅠㅠ여기는 Loop1-for문여기는 Loop1-for문-중첩for문2번째 탈출시도!2번째 탈출실패ㅠㅠ여기는 Loop1-for문여기는 Loop1-for문-중첩for문3번째 탈출시도!3번째 탈출실패ㅠㅠ여기는 Loop1-for문여기는 Loop1-for문-중첩for문4번째 탈출시도!4번째 탈출실패ㅠㅠ여기는 Loop1-for문여기는 Loop1-for문-중첩for문5번째 탈출시도!5번째 탈출실패ㅠㅠNONO~5번째 탈출성공!!!  중첩 for문 {break문}→ 중첩 for문만 빠져나옴→ 다시 for문 안에서 반복→ for문 돌 거 다 돌고 빠져나옴▷ 이름붙은 break문int i;\t\tLoop1 : for (i = 1; i &lt;= 5; i++) {        System.out.printf(\"여기는 Loop1-for문\\n\");        for (;;) {                System.out.printf(\"여기는 Loop1-for문-중첩for문\\n\");        System.out.printf(\"%d번째 탈출시도!\\n\", i);        break Loop1;    }}System.out.printf(\"%d번째 탈출성공!!!\", i);// console여기는 Loop1-for문여기는 Loop1-for문-중첩for문1번째 탈출시도!1번째 탈출성공!!!  중첩 for문 {break문 Loop1}→ 중첩 for문 빠져나옴→ for문도 한 번에 빠져나옴Ch4 - 24. 이름 붙은 반복문 예제▶ 메뉴 - 완전종료 추가▷ 완전종료 시, while문 전체 빠져나가기Loop1: while (true) {    System.out.println(\"{MENU}\");    System.out.println(\"[121] : hi\");    System.out.println(\"[131] : bye\");    System.out.println(\"[180] : 처음처럼\");    System.out.println(\"[181] : OFF\");    System.out.print(\"menu &gt; \");        Scanner scanner = new Scanner(System.in);    int menuS = scanner.nextInt();        switch (menuS) {                case 180: {            System.out.printf(\"돌아가기\\n\\n\");            break;        }                case 181: {            System.out.println(\"OFF\");            break Loop1;        }                case 121: {            System.out.printf(\"하이!에이치아이~\\n\\n\");            continue;        }                case 131: {            System.out.printf(\"바이!짜이찌엔~\\n\\n\");            continue;        }                default: {            System.out.printf(\"재입력\\n\\n\");            continue;        }    }}// console{MENU}[121] : hi[131] : bye[180] : 처음처럼[181] : OFFmenu &gt; 121하이!에이치아이~{MENU}[121] : hi[131] : bye[180] : 처음처럼[181] : OFFmenu &gt; 131바이!짜이찌엔~{MENU}[121] : hi[131] : bye[180] : 처음처럼[181] : OFFmenu &gt; 180돌아가기{MENU}[121] : hi[131] : bye[180] : 처음처럼[181] : OFFmenu &gt; 181OFF",
        "url": "/4cornerstoneJava8"
    }
    ,
    
    "4cornerstonejava7": {
        "title": "Ch4-16~19. while문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 16. while문  Ch4 - 17. while문 예제1  Ch4 - 18. while문 예제2  Ch4 - 19. do - while문Ch4 - 16. while문▶ while문이란?▷ 조건을 만족시키는 동안 블럭{}을 반복▷ 반복횟수를 모를 때 적합while (조건식) {// 조건식의 결과가 참인 동안, 이 부분(while () {_})을 반복}   // 조건식의 결과가 거짓이면, while문을 빠져나옴▶ for문과 while문[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] ▷ for문for (int i = 1; i &lt;= 10; i++) {    System.out.printf(\"[%d] \", i);}// console[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] ▷ while문int i = 1;while (i &lt;= 10) {    System.out.printf(\"[%d] \", i);    i++;}// console[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] if문 - case문과는 달리for문 - while문은 100% 변경가능Ch4 - 17. while문 예제1▶ i--를 사용하여 i가 0이 될 때 까지 반복int i = 5;while (i-- != 0) {    System.out.println(i);}// console43210▶ i에 1씩 증가시킨 값을 더하여 100이하의 수가 나올 때까지 반복int i = 0;int sum = 0;while (sum &lt;= 100) {    System.out.printf(\"+%d [%d]\\n\", i, sum);    sum += ++i;}// console+0 [0]+1 [1]+2 [3]+3 [6]+4 [10]+5 [15]+6 [21]+7 [28]+8 [36]+9 [45]+10 [55]+11 [66]+12 [78]+13 [91]1 + 2 + 3 + … + 13 = 91Ch4 - 18. while문 예제2▶ 입력받은 수(한 자리 수)를 모두 더한 값 출력int sum = 0, num = 0;System.out.print(\"입력 &gt; \");Scanner scanner = new Scanner(System.in);String str = scanner.nextLine();num = Integer.parseInt(str);while (num != 0) {        int namuge = num % 10;  // 1234 % 10 = 4 : namuge = 나누는 수의 맨 마지막 값    System.out.printf(\" %d + %d = \", sum, namuge);        sum += namuge;  // sum = sum + namuge        System.out.printf(\"%d\\n\", sum);        num /= 10;  // 1234 / 10 = 123...4 : 다음 반복 시 num은 123}System.out.println(\"결과 값 &gt; \" + sum);// console입력 &gt; 12340 + 4 = 44 + 3 = 77 + 2 = 99 + 1 = 10결과 값 &gt; 10Ch4 - 19. do - while문▶ do - while문이란?▷ 블럭{}을 최소한 한 번 이상 반복▷ 사용자 입력받을 때 유용do {// 조건식의 연산결과가 참일 때, 이 부분(do {_})을 실행} while (조건식); ▶ 예시▷ 나도 모르는 임의의 수 찾기(do - while문)int input = 0, answer = 0;Scanner scanner = new Scanner(System.in);answer = (int) (Math.random() * 100) + 1;System.out.print(\"1 ~ 100 사이 정수를 입력 &gt; \");do {    input = scanner.nextInt();    if (input &gt; answer) {        System.out.println(\"down\");        System.out.print(\"&gt; \");    } else if (input &lt; answer) {        System.out.println(\"up\");        System.out.print(\"&gt; \");    } else {        System.out.println(\"정답!\");    }} while (input != answer);// console1 ~ 100 사이 정수를 입력 &gt; 100down&gt; 80down&gt; 70down&gt; 60down&gt; 50정답▷ 나도 모르는 임의의 수 찾기(while문)int input = 0, answer = 0;Scanner scanner = new Scanner(System.in);answer = (int) (Math.random() * 100) + 1;System.out.print(\"1 ~ 100 사이 정수를 입력 &gt; \");while (input != answer) {    input = scanner.nextInt();    if (input &gt; answer) {        System.out.println(\"down\");        System.out.print(\"&gt; \");    } else if (input &lt; answer) {        System.out.println(\"up\");        System.out.print(\"&gt; \");    } else {        System.out.println(\"정답!\");    }}// console1 ~ 100 사이 정수를 입력 &gt; 100down&gt; 90down&gt; 80down&gt; 70down&gt; 60down&gt; 50down&gt; 40up&gt; 30up&gt; 44up&gt; 45up&gt; 46up&gt; 47up&gt; 48정답!",
        "url": "/4cornerstoneJava7"
    }
    ,
    
    "4cornerstonejava6": {
        "title": "Ch4-15. 중첩 for문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 15. 중첩 for문Ch4 - 15. 중첩 for문▶ 중첩 for문이란?▷ for문 내에 또 다른 for문을 포함▶ 구구단▷ 대표적 중첩 for문for (int i = 2; i &lt;= 9; i++) {    System.out.println(\"[\" + i + \"단]\");        for (int j = 1; j &lt;= 9; j++) {        System.out.println(i + \"×\" + j + \"=\" + i * j);    }        System.out.println();}// console[2단]2×1=22×2=42×3=62×4=82×5=102×6=122×7=142×8=162×9=18[3단]3×1=33×2=63×3=93×4=123×5=153×6=183×7=213×8=243×9=27[4단]4×1=44×2=84×3=124×4=164×5=204×6=244×7=284×8=324×9=36[5단]5×1=55×2=105×3=155×4=205×5=255×6=305×7=355×8=405×9=45[6단]6×1=66×2=126×3=186×4=246×5=306×6=366×7=426×8=486×9=54[7단]7×1=77×2=147×3=217×4=287×5=357×6=427×7=497×8=567×9=63[8단]8×1=88×2=168×3=248×4=328×5=408×6=488×7=568×8=648×9=72[9단]9×1=99×2=189×3=279×4=369×5=459×6=549×7=639×8=729×9=81▷ 실행순서① for문 먼저 실행i = 2; 2단 실행② 중첩 for문 실행j = 1; 2 × 1 실행③ 중첩 for문이 다 돌 때까지 빠져나가지 않음j = 9; 2 × 9 까지 다 실행④ 2단 완료중첩 for문 빠져나감⑤ for문 실행i = 3; 3단 실행…반복▶ 실습**************************************************▷ System.out.println();으로 출력System.out.println(\"**********\");System.out.println(\"**********\");System.out.println(\"**********\");System.out.println(\"**********\");System.out.println(\"**********\");// console**************************************************▷ for문으로 출력  ********** → 5번      for (int i = 1; i &lt;= 5; i++) {          System.out.println(\"**********\");  }      // console  **********  **********  **********  **********  **********      ▷ 중첩 for문으로 출력  ********** = * → 10번    for (int j = 1; j &lt;= 10; j++) {    System.out.print(\"*\");}  // console**********        ********** → 5번    for (int i = 1; i &lt;= 5; i++) {    for (int j = 1; j &lt;= 10; j++) {          System.out.print(\"*\");  }      System.out.println();  }    // console**************************************************      ▶ 실습2*******************************************************▷ 중첩 for문으로 출력for (int i = 1; i &lt;= 10; i++) {  for (int j = 1; j &lt;= i; j++) {    System.out.print(\"*\");  }System.out.println();}// console*******************************************************",
        "url": "/4cornerstoneJava6"
    }
    ,
    
    "4cornerstonejava5": {
        "title": "Ch4-13~14. for문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 13. for문  Ch4 - 14. for문 예제Ch4 - 13. for문▶ for문이란?▷ 조건을 만족하는 동안 블럭{}을 반복▷ 반복횟수를 알 때 적합for (①초기화; ②조건식; ④증감식) {// 조건식이 참일 때, ③수행문 수행}   // ⑤조건식이 거짓일 때, for문을 빠져나옴Ch4 - 14. for문 예제▶ 초기값 11; 1씩 증가; 5번 도는 for문?▷ i = 11, 12, 13, 14, 15for (int i = 11; i &lt; 16; i++) {    System.out.printf(\"[%d] \", i);}// consolei = [11] [12] [13] [14] [15]▶ 초기값 1; 2씩 증가; 10번 도는 for문?▷ i = 1, 3, 5, 7, 9, 11, 13, 15, 17, 19for (int i = 1; i &lt; 20; i = i + 2) {    System.out.printf(\"[%d] \", i);}// consolei = [1] [3] [5] [7] [9] [11] [13] [15] [17] [19] ▶ 초기값 1; 2배 씩 증가; 10번 도는 for문?▷ i = 1, 2, 4, 8, 16, 32, 64, 128, 256, 512for (int i = 1; i &lt; 513; i = i * 2) {    System.out.printf(\"[%d] \", i);}// consolei = [1] [2] [4] [8] [16] [32] [64] [128] [256] [512] ▶ 초기값 10; 1씩 감소; 10번 도는 for문?▷ i = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1for (int i = 10; i &gt;= 1; i--) {    System.out.printf(\"[%d] \", i);}// consolei = [10] [9] [8] [7] [6] [5] [4] [3] [2] [1]       i &lt;= 1??  i &lt;= 1 : i가 1보다 작거나 같을 때 까지  i &gt;= 1 : i가 1보다 크거나 같을 때 까지        i = 10; 10 &lt;= 1??  이건 처음부터 false  그래서 i &gt;= 1  ▶ 초기값 i = 1, j = 10; i = 1씩 증가, j = 1씩 감소; 10번 도는 for문?▷ i = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10▷ j = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1for (int i = 1, j = 10; i &lt;= 10; i++, j--) {\t\t\t    System.out.println(\"i = \" + i + \", j = \" + j);}// consolei = 1, j = 10i = 2, j = 9i = 3, j = 8i = 4, j = 7i = 5, j = 6i = 6, j = 5i = 7, j = 4i = 8, j = 3i = 9, j = 2i = 10, j = 1  i와 j의 타입이 같아야 사용가능  i와 j는 for문 내에서만 사용가능 - 외부사용 불가▷ 변수의 범위(scope) : 선언위치부터 선언된 블럭{}의 끝까지  for문 내부에서 변수i 선언      for (int i = 1; i &lt; 10; i++) {  // for () {_} → 변수의 범위  // i의 범위는 여기까지  }  System.out.println(i)   // 에러, 변수의 범위를 벗어남        for문 외부에서 변수j 선언      publid static void main(String args[]) {        int j;  // main() {_} → 변수의 범위              for (j = 1; j &lt; 10; j++) {              }    System.out.println(j) // 사용가능, j의 범위는 여기까지라서  }      변수의 범위는 좁을 수록 좋다변수의 값이 잘못되었을 때 확인해야하는 범위가 좁으니까▶ for문이 무한반복이 되는 경우▷ 조건식 생략▷ for문에 true 값을 넣은 경우▶ sum에 1부터 1씩 커지는 수를 5까지 더하기 → 반복문으로 만들기▷ sum = sum + 1; sum = sum + 2; … sum = sum + 5;public static void main(String[] args) {        int sum = 0;        for (int i = 1; i &lt;= 5; i++) {        System.out.printf(\"%d + \", sum);                sum += i;                System.out.printf(\"%d = %d\\n\", i, sum);    }}// console0 + 1 = 11 + 2 = 33 + 3 = 66 + 4 = 1010 + 5 = 15",
        "url": "/4cornerstoneJava5"
    }
    ,
    
    "4cornerstonejava4": {
        "title": "Ch4-12. Math.random()",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 12. 임의의 정수 만들기 Math.random()Ch4 - 임의의 정수 만들기 Math.random()▶ 임의의 정수 = 난수(亂數) : 어지러운 수 → 난수 만들기란?▷ Math.random() : 0.0과 1.0사이의 임의의 double 값을 반환0.0 &lt;= Math.random() &lt; 1.0▶ 예시▷ 1, 2, 3 정수 출력0.0 &lt;= Math.random() &lt; 1.0  각 변에 × 3(원하는 개별 값의 개수 : 1, 2, 3 = 3개)+ 10.0 * 3 &lt;= Math.random() * 3 &lt; 1.0 * 30.0 * 3 &lt;= Math.random() * 3 &lt; 1.0 * 30.0 &lt;= Math.random() * 3 &lt; 3.0구하고자 하는 건 실수가 아닌 정수  각 변을 int로 형변환+ 1(int)0.0 &lt;= (int)(Math.random() * 3) &lt; (int)3.0 + 10 &lt;= (int)(Math.random() * 3) &lt; 3구하고자 하는 건 0, 1, 2 가 아닌 1, 2, 3  각 변에 + 10 + 1 &lt;= (int)(Math.random() * 3) + 1 &lt; 3 + 11 &lt;= (int)(Math.random() * 3) + 1 &lt; 41, 2, 3을 구함▶ 실습▷ 1 ~ 10 사이의 난수를 20개 출력for (int i = 1; i &lt; 20; i++) {  // for문을 20번 돌고 빠져나옴System.out.println((int)(Math.random() * 10) + 1);  // 이걸 20번 돌림}// console6593297524810510310991 // 20개 수는 실행할 때 마다 달라짐  계산과정(Math.random()) = 0.0 ≤ x &lt; 1.0 = 0.0 ~ 0.999999999999999...구하고 싶은 수는 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 총 10개 → × 10  (Math.random() * 10) = 0.0 ≤ x &lt; 10.0 = 0.0 ~ 9.999999999999999...((int)Math.random() * 10) = 0 ≤ x &lt; 10 = 0 ~ 9((int)Math.random() * 10) + 1 = 1 ≤ x &lt; 11 = 1 ~ 10▷ -5 ~ 5 사이의 난수 20개 출력for (int i = 1; i &lt; 20; i++) {System.out.println((int)(Math.random() * 11) - 5);}// console4-4-5-250-23-4-1404154-5-1-3  계산과정(Math.random()) = 0.0 ≤ x &lt; 1.0 = 0.0 ~ 0.999999999999999...구하고 싶은 수는 -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 총 11개 → × 11  (Math.random() * 11) = 0.0 ≤ x &lt; 11.0 = 0.0 ~ 10.999999999999999...((int)Math.random() * 11) = 0 ≤ x &lt; 11 = 0 ~ 10((int)Math.random() * 11) - 5 = -5 ≤ x &lt; 6 = -5 ~ 6",
        "url": "/4cornerstoneJava4"
    }
    ,
    
    "4cornerstonejava3": {
        "title": "Ch4-9~11. switch문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 9. switch문  Ch4 - 10. switch문의 제약조건  Ch4 - 11. switch문의 제약조건 예제Ch4 - 9. switch문▶ switch문이란?▷ 처리해야하는 경우의 수가 많을 때 유용한 조건문  조건식 계산  조건식의 결과와 일치하는 case문으로 이동  case문 아래의 문장들을 수행  break문 또는 switch문의 끝을 만나면 switch문 전체를 빠져나감      switch (조건식) {      case 값a :      // 조건식의 값이 a일 때, 이 부분(case 값a : _)을 실행          break;  // switch문 빠져나감      case 값b :      // 조건식의 값이 b일 때, 이 부분(case 값b : _)을 실행          break;      default :      // 조건식의 결과가 일치하는 case문이 없을 때, 이 부분(default : _)을 실행      // default문은 생략가능  }      ▶ if문과 switch문▷ 조건식 값  if문 조건식 값 : true or false → 2가지  switch문 조건식 값 : 정수 or 문자열 → 여러가지▷ 조건식  if문 조건식 : 여러 번 → true와 false 밖에 계산을 못해서 식이 많음  switch문 조건식 : 한 번 → case만 추가하면 됨Ch4 - 10. switch문의 제약조건▶ switch문의 제약조건▷ switch문의 조건식 결과는 정수 또는 문자열▷ case문의 값은 정수, 상수(문자포함), 문자열만 가능 - 변수 안됨, 중복 안됨int num, result;final int ONE = 1;switch(result) {    case '1' :  // 가능, 문자 리터럴    case ONE :  // 가능, 정수 상수    case \"YES\" :    // 가능, 문자열 리터럴    case num :  // 불가능, 변수    case 1.0 :  // 불가능, 실수}Ch4 - 11. switch문의 제약조건 예제▶ 월 입력 시, 계절 출력▷ case1 : 봄 3, 4, 5월▷ case2 : 여름 6, 7, 8월▷ case3 : 가을 9, 10, 11월▷ case4 : 겨울 12, 1, 2월System.out.printf(\"지금은 몇 월 인가요? &gt; \");Scanner scanner = new Scanner(System.in);int month = scanner.nextInt();switch (month) {    case 3: case 4: case 5:        System.out.println(\"봄봄봄~\");        break;    case 6: case 7: case 8:        System.out.println(\"여름~!\");        break;    case 9: case 10: case 11:        System.out.println(\"가을...\");        break;    default:        System.out.println(\"겨울~**\");        // console지금은 몇 월 인가요? &gt; 6여름~!case문은 가로로 작성해도 됨",
        "url": "/4cornerstoneJava3"
    }
    ,
    
    "4cornerstonejava2": {
        "title": "Ch4-5~8. 중첩 if문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 5. if - else if문  Ch4 - 6. if - else if문 예제  Ch4 - 7. 중첩 if문  Ch4 - 8. 중첩 if문 예제Ch4 - 5. if - else if문▶ if - else if문이란?▷ 여러 개 중의 하나 : 여러 개의 조건식을 포함한 조건식if (조건식1) {// 조건식1 = true일 때, 이 구역((조건식1) { })을 실행} else if (조건식2) {// 조건식2 = true일 때, 이 구역((조건식1) { })을 실행} else if (조건식3) {// 조건식3 = true일 때, 이 구역((조건식1) { })을 실행} else {// 조건식1, 2, 3 모두 false일 때, 이 구역(else { })을 실행}Ch4 - 6. if - else if문 예제▶ 70점은 몇 학점?int score = 70; // score = 점수 저장char grade = ' ';   // grade = 학점 저장if (score &gt;= 90) {  // ① 70 &gt;= 90 → falsegrade = 'A';} else if (score &gt;= 80) {   // ② 70 &gt;= 80 → falsegrade = 'B';} else if (score &gt;= 70) {   // ③ 70 &gt;= 70 → truegrade = 'C';    // ④ grade = C} else {grade = 'D';}   // ⑤ 조건 - 만족 - 실행 - 조건문 빠져나옴System.out.println(grade);// consoleCif문 : 딱 하나의 문장만 실행하고 빠져나옴▷ else if (score &gt;= 80) = 80 ≤ score &lt; 90 ??  score가 90보다 작아야 하는 게 조건에 입력되지 않음  왜?  if문 : if (score &gt;= 90)에서 이미 90보다 작은 애들 검증 끝  그래서 else if (score &gt;= 80)으로 온 애들은 애초에 다 90보다 작음  그래서 검증이 필요 없음▷ 코드를 줄이기  else문 없애기      int score = 50;  char grade = 'D';   // 초기값으로 'D'를 줌 → else문은 없애기      if (score &gt;= 90) {  // ① 50 &gt;= 90 → false      grade = 'A';  } else if (score &gt;= 80) {   // ② 50 &gt;= 80 → false      grade = 'B';  } else if (score &gt;= 70) {   // ③ 50 &gt;= 70 → false      grade = 'C';  }  // ④ if문에 만족하는 조건 없음 → 그냥 빠져나옴 → grade는 초기값 그대로 'D'      System.out.println(grade);      // console  D      Ch4 - 7. 중첩 if문▶ 중첩 if문이란?▷ if문 안의 if▷ 중첩횟수는 제약이 없다 보면 됨  if문 안에 if문은 1000번 정도 들어감  보통 if문 3~4번 정도 밖에 쓰지 않음      if (조건식1) {      // 조건식1 = true일 때, 이 구역((조건식1) { })을 실행      if (조건식2) {      // 조건식1, 2 = 둘 다 true일 때, 이 구역(중첩 if(조건식2) { })을 실행      } else {      // ① 조건식1 = true ② 조건식2 = flase일 때, 이 구역(중첩 if의 else { })을 실행      }  } else {      // 조건식1 = false일 때, 이 구역(else { })을 실행  }      ▷ 괄호 생략시 주의!  괄호 생략 : 들여쓰기로 구분가능?? → 구분 안됨      if (num &gt;= 0)   // ① if문      if (num != 0)   // ② 중첩 if문          sign = '+';  else    // ① if문의 else?? OR ② 중첩 if문의 else??      sign = '-';        괄호      if (num &gt;= 0) { // ① if문      if (num != 0) { // ② 중첩 if문          sign = '+';      } else {    // ② 중첩 if문의 else      sign = '-';      }  }      Ch4 - 8. 중첩 if문 예제▶ 70점은 몇 학점? + 학점의 + - 추가하기▷ 97 ~ 100 = A+▷ 94 ~ 96 = A▷ 90 ~ 93 = A-▷ 87 ~ 89 = B+▷ 84 ~ 86 = B▷ 80 ~ 83 = B-▷ 70 ~ 79 = Cchar grade = ' ', sign = ' ';\t\tSystem.out.printf(\"점수입력 &gt; \");Scanner scanner = new Scanner(System.in);int score = scanner.nextInt();if (score &gt;= 90) {    grade = 'A';    if (score &gt;= 97) {        sign = '+';    } else if (score &gt;= 93) {        sign = '-';    }} else if (score &gt;= 80) {    grade = 'B';    if (score &gt;= 87) {        sign = '+';    } else if (score &gt;= 83) {        sign = '-';    }} else if (score &gt;= 70) {    grade = 'C';}System.out.printf(\"점수 : %d점\\n학점 : %c%c\", score, grade, sign);// console점수입력 &gt; 97점수 : 97점학점 : A+",
        "url": "/4cornerstoneJava2"
    }
    ,
    
    "4cornerstonejava1": {
        "title": "Ch4-1~4. if문",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter4. 조건문과 반복문  Ch4 - 1. if문  Ch4 - 2. 조건식의 다양한 예  Ch4 - 3. 블럭{}  Ch4 - 4. if - else문Ch4. 조건문과 반복문▶ 조건문과 반복문 = 제어문(flow Control Statement)▷ 흐름을 제어하는 문장▶ 조건문▷ 조건을 만족할 때만 {}를 수행(0~1번)▷ if문, switch문▶ 반복문▷ 조건을 만족하는 동안 {}를 수행(0~n번)▷ for문, while문Ch4 - 1. if문▶ if문이란?▷ 조건식이 참(true)일 때, 괄호{}안의 문장들을 수행if (조건식) {  // 시작}   // 종료▷ 예시int score = 70;if (score &gt; 60) {   // (조건식) = true → {}안 실행    System.out.println(\"합격\");    // console합격Ch4 - 2. 조건식의 다양한 예▶ 90 &lt;= x &amp;&amp; x &lt;= 100▷ 정수 x가 90이상 100이하 일 때▶ x &lt; 0 || x &gt; 100▷ 정수 x가 0보다 작거나 100보다 클 때▶ x%3==0 &amp;&amp; x%2!==0▷ 정수 x가 3의 배수지만 2의 배수는 아닐 때▶ ch=='y' || ch=='Y'▷ 문자 ch가 ‘y’ 또는 ‘Y’일 때▶ ch==' ' || ch=='t' || ch=='\\n'▷ 문자 ch가 공백이거나 탭 또는 개행문자 일 때▶ 'A' &lt;= ch &amp;&amp; ch &lt;='Z'▷ 문자 ch가 대문자일 때▶ 'a' &lt;= ch &amp;&amp; ch &lt;='z'▷ 문자 ch가 소문자일 때▶ '0' &lt;= ch &amp;&amp; ch &lt;='9'▷ 문자 ch가 숫자일 때▶ str.equals(\"yes\")▷ 문자열 str의 내용이 “yes”일 때(대소문자 구분)▶ str.equalsIgnoreCase(\"yes\")▷ 문자열 str의 내용이 “yes”일 때(대소문자 구분X)Ch4 - 3. 블럭{}▶ 블럭이란?▷ 여러 문장을 하나로 묶어주는 것if (조건식) {  // 블럭 시작                    // 탭(tap)에 의한 들여쓰기                    System.out.println(\"hi\")}   // 블럭 종료▷ if문에 속한 문장이 하나면, {} 생략가능if (score &gt; 60)     System.out.println(\"합격\");   // 문장1. if문에 속함    System.out.println(\"축하합니다!\");   // 문장2. if문에 속하지 않음생략은 한 문장일때만 가능Ch4 - 4. if - else문▶ if - else문이란?▷ 둘 중의 하나 : 조건식이 참일 때와 거짓일 때로 나눠서 처리  if문      if (input == 0) {   // 조건식1      System.out.println(\"0\");  }      if (input != 0) {   // 조건식2      System.out.println(\"0이 아니다\");  }        이런 문장은 if - else문으로 처리하는 게 효율적if문은 조건식 2개if - else문은 조건식 1개    if - else문      if (input == 0) {   // 조건식1      System.out.println(\"0\");  } else {      System.out.println(\"0이 아니다\");  }      ",
        "url": "/4cornerstoneJava1"
    }
    ,
    
    "3cornerstonejava9": {
        "title": "Ch3-17~19. 조건 연산자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 17. 조건 연산자 ? :  Ch3 - 18. 대입 연산자 =  Ch3 - 19. 복합 대입 연산자 +=Ch3 - 17. 조건 연산자 ? :▶ 조건 연산자란?▷ 피연산자가 3개▷ 조건식의 결과에 따라 연산결과를 달리함  조건식 결과 = true 일 때      int x = 5, y = 3;      boolean b = x &gt; y;  int result = (x &gt; y) ? x : y;      System.out.println(b);  System.out.println(result);      // console  true  5   // 조건식이 true일 때, 결과값은 x        조건식 결과 = false 일 때    int x = 3, y = 5;          boolean b = x &gt; y;int result = (x &gt; y) ? x : y;  System.out.println(b);System.out.println(result);  // consolefalse5   // 조건식이 flase일 때, 결과값은 y        result = (x &gt; y) ? x : y; → if문으로 작성하면?    if (x &gt;  y)  result = x;else {  result = y;}   // if문은 길다        간단한 if문은 삼항 연산자로!  Ch3 - 18. 대입 연산자 =▶ 대입 연산자란?▷ 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환▷ 모든 연산자는 결과값을 반환▷ 연산방향 : ←▶ lvalue와 rvalue▷ lvalue : 대입 연산자의 왼쪽 피연산자      lvalue는 저장공간변수, 배열… 저장공간만 lvalue가 될 수 있음        lvalue가 저장공간이 아닐 시 에러발생상수, 정수… 저장공간이 아닌 lvalue는 모두 에러    int i = 0;  3 = i + 3;  // 에러, 3 ≠ 저장공간i + 3 = i;  // 에러, i + 3 = 0 + 3 = 3 ≠ 저장공간  final int MAX = 3;  // 변수 앞 final = 상수 ≠ 저장공간MAX = 10; // 에러, MAX = 상수 ≠ 저장공간      ▷ rvalue : 대입 연산자의 오른쪽 피연산자Ch3 - 18. 복합 대입 연산자 +=▶ 복합 대입 연산자란?▷ 대입 연산자와 다른 연산자를 하나로 축약▶ 예시▷ i += 3;  i = i + 3;▷ i -= 3;  i = i - 3;▷ i *= 3;  i = i * 3;▷ i /= 3;  i = i / 3;▷ i %= 3;  i = i % 3;▷ i «= 3;  i = i &lt;&lt; 3;▷ i »= 3;  i = i &gt;&gt; 3;▷ i &amp;= 3;  i = i &amp; 3;▷ i ^= 3;  i = i ^ 3;▷ i |= 3;  i = i | 3;▷ i *= 10 + 3;  피연산자가 2개인 경우 괄호 쳐 주기!  i = i * (10 + 3);",
        "url": "/3cornerstoneJava9"
    }
    ,
    
    "3cornerstonejava8": {
        "title": "Ch3-15~16. 논리 연산자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 15. 논리 연산자 &amp;&amp; || !  Ch3 - 16. 논리 부정 연산자 !Ch3 - 15. 논리 연산자 &amp;&amp; || !▶ 논리 연산자 &amp;&amp; ||란?▷ 조건식을 연결할 때 사용하는 연산자▷ ||(or)   : 피연산자 중 어느 하나가 true면, true!▷ &amp;&amp;(and)  : 피연산자 모두 true가 되면, true!▶ 실습▷ x는 10보다 크고, 20보다 작다  10 &lt; x &lt; 20 // 이런식의 표기는 허용X  논리 연산자를 사용해야 함  ① 10 &lt; x &amp;&amp; x &lt; 20  ② x &gt; 10 &amp;&amp; x &lt; 20  ①, ② 중 하나로 표기▷ x는 10보다 크고, 20보다 작다i는 2의 배수 또는, 3의 배수이다      2의 배수 = i ÷ 2 → 나머지 03의 배수 = i ÷ 3 → 나머지 0    i%2==0 || i%3==0      int i = 8;              System.out.println(i%2==0 || i%3==0);      // console  ture        계산과정  i%2==0 || i%3==0  → 8%2==0 || 8%3==0  → 0==0   || 2==0  → true   || false  → true▷ i는 2의 배수 또는, 3의 배수지만, 6의 배수는 아니다  (i%2==0 || i%3==0) &amp;&amp; 6%0!=0  우선순위 : || &gt; &amp;&amp; → 괄호를 사용하여 우선순위 잡아주기▷ 문자 ch는 숫자(‘0’ ~ ‘9’)이다  '0' &lt;= ch &lt;= '9'  '0' &lt;= ch &amp;&amp; ch &lt;= '9'char ch = '5';System.out.println('0' &lt;= ch &amp;&amp; ch &lt;= '9');// consoletrue  계산과정  '0' &lt;= ch &amp;&amp; ch &lt;= '9'  → 48 &lt;= '5' &amp;&amp; '5' &lt;= 57  → 48 &lt;= 53  &amp;&amp; 53 &lt;= 57  → true▷ 문자 ch는 대문자 또는 소문자이다  'a' &lt;= ch &lt;= 'z'          || 'A' &lt;= ch &lt;= 'Z''a' &lt;= ch &amp;&amp; ch &lt;= 'z'    || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')  || ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')Ch3 - 16. 논리 부정 연산자 !▶ 논리 부정 연산자란?▷ true를 flase로, flase는 true로 바꿈  x = ture  !x = false▷ 논리 부정 연산자 : 대입 연산자, 단항 연산자  단항 연산자의 연산방향 : ←boolean b = true;System.out.println(!b);System.out.println(!!b);// consolefalsetrue▷ 문자 ch는 소문자가 아니다  문자 ch는 소문자다  'a' &lt;= ch &lt;= 'z'  'a' &lt;= ch &amp;&amp; ch &lt;= 'z'  아니다(문자 ch는 소문자다)  !('a' &lt;= ch &amp;&amp; ch &lt;= 'z')",
        "url": "/3cornerstoneJava8"
    }
    ,
    
    "3cornerstonejava7": {
        "title": "Ch3-13~14. 비교 연산자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 13. 비교 연산자  Ch3 - 14. 문자열의 비교Ch3 - 13. 비교 연산자▶  &gt;  &lt;  &gt;=  &lt;=  ==  !=▷ 두 피연산자를 비교해서 ture 또는 false를 반환▶ 연산자의 종류와 연산결과▷ 대소비교▷ 등가비교▶ 실습▷ char : &gt;char ch1 = 'A', ch2 = 'B';System.out.println(ch1 &gt; ch2);// consolefalse  계산과정          char : int 보다 작은 타입  char → int 자동 형변환      ch1 &gt; ch2  'A' = 65, 'B' = 66  'A' &gt; 'B'  65 &gt; 66 false!      Ch3 - 14. 문자열의 비교▶ 문자열을 비교할 때는?▷ 문자열 비교에는 == 대신 equals()를 사용  문자열 비교 : == 사용가능String str1 = \"abc\";String str2 = \"abc\";System.out.println(str1 == str2);System.out.println(str1.equals(str2));// consoletruetrue  문자열 비교 : == 사용불가String str1 = new String(\"abc\");String str2 = new String(\"abc\");System.out.println(str1 == str2);System.out.println(str1.equals(str2));// consolefalsetrue",
        "url": "/3cornerstoneJava7"
    }
    ,
    
    "3cornerstonejava6": {
        "title": "Ch3-11~12. Math.round()",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 11. Math.round()로 반올림하기  Ch3 - 12. 나머지 연산자 %Ch3 - 11. Math.round()로 반올림하기▶ Math.round()란?▷ 실수를 소수점 첫째 자리에서 반올림한 정수를 반환long result = Math.round(4.52);System.out.println(result);// console5▶ 실습▷ double pi = 3.141592;    pi에서 소수점 셋째 자리까지 반올림 하여 3.142를 출력하시오    Math.round() 사용double pi = 3.141592;double thirdUpPi = Math.round(pi * 1000) / 1000.0;System.out.println(thirdUpPi);// console3.142  계산과정Math.round(pi * 1000) / 1000.0→ Math.round(3.141592 * 1000) / 1000.0→ Math.round(3141.592) / 1000.0   // 소수점 첫째자리 5에서 반올림 → 3142→ 3142 / 1000.0(double) // int ÷ double = double→ 3.142(double)▷ double pi = 3.141592;    pi를 3.141로 출력하시오double pi = 3.141592;\t\tdouble thirdUpPi = ((int)(pi * 1000) / 1000.0);// console3.141\t\t  계산과정((int)(pi * 1000) / 1000.0) // (pi * 1000)을 괄호를 사용하여 우선순위→ Math.round(3.141592 * 1000) / 1000.0→ Math.round(3141.592) / 1000.0   // 소수점 첫째자리 5에서 반올림 → 3142→ 3142 / 1000.0(double) // int ÷ double = double→ 3.142(double)Ch3 - 12. 나머지 연산자 %▶ 나머지 연산자 %란?▷ 오른쪽 피연산자로 나누고 남은 나머지를 반환10 ÷ 8 = 1…2  // 몫 = 1, 나머지 = 210/8 = 1 // 몫10%8 = 2 // 나머지System.out.println(10/8);System.out.println(10%8);// console1 // 몫2 // 나머지▶ % : 부호는 무시▷ 10%8 = 10%-8System.out.println(10%8);System.out.println(10%-8);// console22",
        "url": "/3cornerstoneJava6"
    }
    ,
    
    "3cornerstonejava5": {
        "title": "Ch3-9~10. 산술변환",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 9. 사칙 연산자  Ch3 - 10. 산술 변환Ch3 - 9. 사칙 연산자▶ + - * /▷ 10 / 4 = 2?▷ 컴퓨터는 같은 타입끼리만 계산가능▷ 10 ÷ 4 = 2.5▷ 10(int) / 4(int) = 2(int)  // 소수점 이하는 버려짐▷ 10(int) / 4.0f → 10.0f / 4.0f = 2.5f  // 결과를 실수로 얻으려면 피연산자 타입을 실수로 통일int a = 10, b = 4;System.out.printf(\"%d ÷ %d = %d%n\", a, b, a / b);System.out.printf(\"%d ÷ %f = %f%n\", a, (float)b, a / (float)b);// console10 ÷ 4 = 210 ÷ 4.000000 = 2.500000Ch3 - 10. 산술 변환▶ 산술 변환이란?▷ 연산 전에 피연산자의 타입을 일치시키는 것① 두 피연산자의 타입을 같게 일치 - 보다 큰 타입으로 일치long(8 byte) + int(4 byte) → long + long = long   // long &gt; intfloat(4 byte) + int(4 byte) → float + float = float    // float의 범위 ⊃ int의 범위double(8 byte) + float(4 byte) → double + double = double   // double &gt; float② 피연산자의 타입이 int보다 작은 타입이면 int로 변환      int보다 작은 타입 = byte, char, short   · byte : -128 ~127   · char : 0 ~ 6만   · short : ±3만    ‘300 × 300 = 9만’ 이 정도만 계산해도 short의 범위를 넘어버림  오버플로우 발생  그래서 int보다 작은 단위는 오버플로우 방지를 위해 int로 변환byte(1 byte) + short(2 byte) → int + int → intchar(2 byte) + short(2 byte) → int + int → int ▶ 산술 변환 예시▷ char - char → int - int = int'2'(char) - '0'(char) → 50(int) - 48(int) = 2(int) ▷ long = int × int → long = long × intint  a = 1_000_000,\t// 1백만 = 10의 6제곱     b = 2_000_000;\t// 2백만 = 10의 6제곱long c = a * b;\t// 10의6제곱 * 10의6제곱 = 10의 12제곱System.out.println(c);// console-1454759936    // ?? 오버플로우 난듯,,long c = a(int) * b(int)      문제① int의 범위는 10의9제곱 결과값은 10의12제곱, 오버플로우 발생문제② long에 int를 넣으려면 값손실 발생    해결 a나 b 둘 중 하나를 int → long으로 수동 형변환  오버플로우 벗어나는 법  int → long 수동 형변환long c = a * b;long c = (long)a * b;int  a = 1_000_000,\t// 1백만 = 10의 6제곱     b = 2_000_000;\t// 2백만 = 10의 6제곱long c = (long)a * b;\t// 10의6제곱 * 10의6제곱 = 10의 12제곱System.out.println(c);// console2000000000000  계산과정long c = (long)a * b;long c = (long)1000000 * 2000000;long c = 1000000L * 2000000;long c = 1000000L * 2000000L;long c = 2000000000000L;",
        "url": "/3cornerstoneJava5"
    }
    ,
    
    "3cornerstonejava4": {
        "title": "Ch3-7~8. 형변환",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 7. 형변환 연산자  Ch3 - 8. 자동 형변환Ch3 - 7. 형변환 연산자▶ 형변환이란?▷ 변수 또는 상수의 타입을 다른 타입으로 변환하는 것(타입)피연산자▷ double → intdouble d = 85.4;int score = (int)d;System.out.println(score);System.out.println(d);// console85  // score, 형변환85.4    // d, 형변환이 된 건 score안에 들어간 d값이지 변수 d 그 자체가 아님▷ 유니코드 문자표애초에 컴퓨터는 0과 1 밖에 모름사람이 문자로 써도 컴퓨터는 0과 1로 바꿔서 알아들음그래서 애초에 약속 같은 코드 문자표가 존재▷ int → charint i = 65;char ch = (char)i;System.out.println(ch);// consoleA▷ char → intchar ch = 'A';int i = (int)ch;System.out.println(i);// console65▷ float → intfloat f = 1.6f;int i = (int)f;System.out.println(i);// console1   // 형변환 시 반올림 안함, 소수점은 그냥 버림▷ int → floatint i = 10;float f = (float)i;System.out.println(f);// console10.0Ch3 - 8. 자동 형변환▶ 자동 형변환이란?▷ 컴파일러가 자동으로 형변환 해주는 것▶ 변수 타입 &gt; 값 : 자동 형변환 가능float f = 1234;System.out.println(f);// console1234.0▶ 변수 타입 &lt; 값 : 자동 형변환 불가능▷ 값손실 발생int i = 3.14f;  // 에러▷ 수동 형변환 가능int i = (int)3.14f;System.out.println(i);// console3▶ 예시▷ byte → int▷ int → byte▶ 자동 형변환 정리▶ 예외▷ 예외 1. 변수 타입 &lt; 값 : 자동 형변환 불가한 조건지만 가능한 경우byte b = 100;    // byte(-128 ~ 127)의 범위 안에 리터럴(100)이 들어감 → 자동 형변환 가능▷ 예외 1과 비슷하지만 → 자동 형변환 불가한 경우 1int i = 100;byte b = i; // 에러, i는 리터럴이 아닌 변수, 변수 내 값이 바뀔 수 있기 때문에 에러를 냄▷ 예외 1과 비슷하지만 → 자동 형변환 불가한 경우 2byte b = 1000;  // 에러, 1000이 변수 아닌 리터럴이지만 byte(-128 ~ 127)의 범위를 넘어감 → 값손실 발생 → 수동 형변환",
        "url": "/3cornerstoneJava4"
    }
    ,
    
    "3cornerstonejava3": {
        "title": "Ch3-5~6. 증감 연산자",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 5. 증감 연산자 ++와 –  Ch3 - 6. 부호 연산자Ch3 - 5. 증감 연산자 ++와 –▶ 증가 연산자(++)▷ 피연산자의 값을 1 증가 시킴▶ 감소 연산자(–)▷ 피연산자의 값을 1 감소 시킴▶ 전위형 후위형▷ 전위형? 후위형?▷ 증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이 없음int i = 1;\t\tSystem.out.println(i++);System.out.println(++i);// console22▷ 전위형 j = ++i;int i = 1, j = 0;++i;    // ① 전위형은 자기 먼저 더하기, i = 1 + 1 = 2j = i;  // ② 더한 걸 대입, j = 2        System.out.println(j);// console2▷ 후위형 j = i++;int i = 1, j = 0;j = i;  // ① 후위형은 먼저 대입, j = 1i++;    // ② j와 별개로 i만 더해져 있음, i = 2        System.out.println(j);  // j는? 더해진 i를 모름, 더하기 전의 i인 1을 출력// console1Ch3 - 6. 부호 연산자▶ 단항 연산자 - +▷ - : 피연산자의 부호를 반대로 변경▷ + : 아무런 일도 일어나지 않음(실제 사용안함)▶ 실습int i = -10;i = -i;System.out.println(i);// console10",
        "url": "/3cornerstoneJava3"
    }
    ,
    
    "3cornerstonejava2": {
        "title": "Ch3-3~4. 연산자 순위·규칙",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 3. 연산자의 우선순위  Ch3 - 4. 연산자의 결합규칙Ch3 - 3. 연산자의 우선순위▶ 연산자의 우선순위란?▷ 하나의 식(expression)에 연산자가 둘 이상 있을 때,     어떤 연산을 먼저 수행할지를 자동 결정하는 것▷ () : 수동결정▷ 그러나 계속 수동결정을 통해 우선순위를 줄 순 없음▷ 우선순위를 상식적으로 생각Ch3 - 4. 연산자의 결합규칙▶ 결합규칙이란?▷ 우선순위가 같은 연산자가 있을 때,     어떤 것을 먼저 연산할 것인가?▷ 대입·단항 연산자 = 왼쪽 ← 오른쪽▷ 대입·단항 연산자 외 모든 연산자 = 왼쪽 → 오른쪽&lt;연산자의 우선순위와 결합법칙 결론 3가지&gt;1. 산술 &gt; 비교 &gt; 논리 &gt; 대입2. 단항 &gt; 이항 &gt; 삼항3. 왼쪽 -&gt; 오른쪽(단항·대입 연산자 제외)",
        "url": "/3cornerstoneJava2"
    }
    ,
    
    "3cornerstonejava1": {
        "title": "Ch3-1~2. 연산자 종류",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter3. 연산자  Ch3 - 1. 연산자와 피연산자  Ch3 - 2. 연산자의 종류Ch3 - 1. 연산자와 피연산자▶ 연산자란?▷ 연산을 수행하는 기호 : + - × ÷▶ 피연산자란?▷ 연산자의 연산 수행 대상모든 연산자는 연산결과를 반환한다int x = 5;\t\tSystem.out.println(4 * x + 3);  // 4 * 5 + 3 → 20 + 3// console23  // 연산결과Ch3 - 2. 연산자의 종류▶ 산술 연산자▷ + - * / : 사칙 연산▷ % : 나머지 연산▶ 비교 연산자▷ &gt; &lt; : 큼 작음▷ &gt;= &lt;= : 크거나 같음 작거나 같음▷ == != : 같음 다름▶ 논리 연산자▷ &amp;&amp; : and(둘 다)x &gt; 3 &amp;&amp; x &lt; 5 // x는 3보다 크고 5보다 작다▷ || : or(둘 중 하나)x &gt; 3 || x &lt; 5 // x는 3보다 크거나 5보다 작다▷ ! : not!(x &gt; 3) // x는 3보다 작거나 같다▶ 대입 연산자▷ = : 우변의 값을 좌변에 저장result = x + y▶ 기타 연산자▷ (type) : 형변환 연산자▷ ?: : 삼항 연산자▷ instanceof : instanceof 연산자",
        "url": "/3cornerstoneJava1"
    }
    ,
    
    "2cornerstonejava19": {
        "title": "Ch2-17. 타입 간 변환",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 17. 타입 간의 변환방법Ch2 - 17. 타입 간의 변환방법▶ 문자와 숫자간의 변환▷ 숫자 → 문자 = 문자 ‘0’을 더함3 + '0' = '3'▷ 문자 → 숫자 = 문자 ‘0’을 뺌'3' - '0' = 3▶ 문자열로 변환▷ 숫자 → 문자열 = “ “을 더함3 + \"\" = \"3\"▷ 문자 → 문자열 = “ “을 더함'3' + \"\" = \"3\"▶ 문자열을 숫자로 변환▷ 문자열 → 숫자(정수) = Integer.parseIntInteger.parseInt(\"3\") = 3▷ 문자열 → 숫자(실수) = Double.parseDoubleDouble.parseDouble(\"3.4\") = 3.4▷ 문자열 → 문자 = charAt\"3\".charAt(0) = '3'▶ 실습▷ ‘문자 3’을 ‘숫자 3’으로 변환System.out.println('3' - '0');// console3▷ ‘3’ - ‘0’ + 1 = ?System.out.println('3' - '0' + 1);  // '3' - '0' = 3(숫자)// console4▷ Integer.parseInt(“3”) + 1 = ?System.out.println(Integer.parseInt(\"3\") + 1);  // Integer.parseInt(\"3\") = 3// console4",
        "url": "/2cornerstoneJava19"
    }
    ,
    
    "2cornerstonejava18": {
        "title": "Ch2-15~16. 오버플로우",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 15. 정수형의 오버플로우  Ch2 - 16. 부호있는 정수의 오버플로우Ch2 - 15. 정수형의 오버플로우▶ 오버플로우란?▷ 표현가능한 범위를 넘어가는 것최대값 + 1 = 최소값최소값 - 1 = 최대값▶ 부호없는 정수 char▷ char = 2 byte = 16bit▷ 216 = 65536▷ 0 ~ 65536Ch2 - 16. 부호있는 정수의 오버플로우▶ 부호있는 정수 short▷ short = 2 byte = 16bit▷ 216 = 65536▷ -32768 ~ 32767",
        "url": "/2cornerstoneJava18"
    }
    ,
    
    "2cornerstonejava17": {
        "title": "Ch2-14. 화면 → 입력",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 14. 화면으로부터 입력받기Ch2 - 14. 화면으로부터 입력받기▶ Scanner란?▷ 화면으로부터 데이터를 입력받는 기능을 제공하는 클래스· 클래스 = 기능을 제공하는 역할▶ Scanner를 사용하려면?▷ import문 추가import java.util.*;▷ Scanner 객체의 생성Scanner scanner = new Scanner(System.in);System.in : 화면입력▷ Scanner 객체를 사용int num = scanner.nextInt();    // 화면에서 입력받은 정수를 num에 저장String input = scanner.nextLine();    // 화면에서 입력받은 한 줄을 input에 저장int num = Integer.parseInt(input);    // 문자열(input)을 숫자(num)로 변환· 숫자 → 문자열 / 문자열 → 숫자▶ 실습▷  scanner.nextInt 사용하여 ‘100’, ‘200’ 출력import java.util.*; // 1. import문 추가public class ScanfEx21 {\tpublic static void main(String[] args) {        // 2. Scanner 클래스 객체 생성\t\tScanner scanner = new Scanner(System.in);\t\t\t\tint num = scanner.nextInt();\t\tint num2 = scanner.nextInt();\t\t\t\tSystem.out.println(num);\t\tSystem.out.println(num2);\t}}// console100 // 입력 값(화면에서 입력)200100 // 출력 값200▷ scanner.nextLine 사용하여 ‘100’ 출력import java.util.*;public class ScanfEx21 {\tpublic static void main(String[] args) {\t\tScanner scanner = new Scanner(System.in);\t\t\t\tString input = scanner.nextLine();\t\tint num = Integer.parseInt(input);\t\tSystem.out.println(num);\t}}// console100100‘100’을 출력할 경우 nextInt로 한 줄로 코딩 가능, 굳이 2줄로 코딩하지 않아도 됨",
        "url": "/2cornerstoneJava17"
    }
    ,
    
    "2cornerstonejava16": {
        "title": "Ch2-12~13. printf()",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 12. printf를 이용한 출력  Ch2 - 13. printf를 이용한 출력 예제Ch2 - 12. printf를 이용한 출력▶ println()의 단점 - 출력형식 지정불가▷ 실수의 자리수 조정불가 - 소수점 n자리만 출력하려면?· 정수 ÷ 정수 = 정수System.out.println(10/3); // console3· 실수 ÷ 정수 = 실수System.out.println(10.0/3);// console3.33333333...▷ 10진수로만 출력 - 8진수, 16진수로 출력하려면?System.out.println(0x1A);// console26▶ printf()로 출력형식 지정가능▷ “%.2f” : 소수점 둘째자리까지 출력System.out.printf(\"%.2f\", 10.0/3);// console3.33▷ “%d” : 10진수로 출력System.out.printf(\"%d\", 0x1A);// console26▷ “%x” : 16진수로 출력System.out.printf(\"%x\", 0x1A);// console1a▶ printf()의 지시자 1▷ 개행문자 : %n과 /n%n은 OS 상관 없이 됨System.out.printf(\"age:%d year:%d%n줄바꿈ok?\", 14, 2017);// consoleage:14 year:2017줄바꿈ok?/n은 OS별로 조금 다를 수 있음System.out.printf(\"age:%d year:%d\\n줄바꿈ok?\", 14, 2017);\t// console\tage:14 year:2017줄바꿈ok?▶ printf()의 지시자 2▷ 정수 ‘15’를 10진수로 출력System.out.printf(\"%d\", 15);\t\t// console15\t\t▷ 정수 ‘15’를 8진수로 출력System.out.printf(\"%o\", 15);\t\t// console17  // 일칠 10진수에서 1은 8을 의미▷ 정수 ‘15’를 16진수로 출력System.out.printf(\"%x\", 15);\t\t// consolef ▷ toBinaryString : 정수를 2진 문자열로 변환System.out.printf(\"%s\", Integer.toBinaryString(15));\t// console1111▷ 8진수와 16진수에 접두사 붙이기#을 붙여주기System.out.printf(\"%#o%n\", 15);System.out.printf(\"%#x%n\", 15);System.out.printf(\"%#X%n\", 15); // X를 대문자로 사용하면 접두사도 대문자로 출력// console0170xf0XF▷ 실수 출력 지시자 %f+ 지수형식 %efloat f = 123.4567890f;System.out.printf(\"%f%n\", f);System.out.printf(\"%e%n\", f);// console123.456787  // f는 정밀도 7자리 123.4567 = 총 7자리 그 외 87 두 자리는 의미 없는 수1.234568e+02    // 8e+02 = ① 8은 반올림 ② e+02는 10² → 지수형식+ 간략한 형식 %gSystem.out.printf(\"%g%n\", 123.456789);System.out.printf(\"%g%n\", 0.00000001);// console123.457 // 간단한 형식 - 7자리 내로 표현 %f1.00000e-08 // 간단한 형식 - 지수 형식 %e▶ printf()의 지시자 3▷ 지정한 자리수만큼 출력 : %5d(지정한 자리수는 5자리)System.out.printf(\"[%5d]\", 10);// console[   10] // 출력 수 = 10(두 자리) / 지정 수 = 5자리 → 앞 3자리는 비움▷ 왼쪽정렬 : %-dSystem.out.printf(\"[%-5d]\", 10);// console[10   ]▷ 공백 채우기 : %05d(5자리에서 공백인 자리는 0으로 채움)System.out.printf(\"[%05d]\", 10);// console[00010]▷ %전체자리 수.소수점아래자리 수fdouble d = 123.456789;System.out.printf(\"d=%14.10f\", d);// consoled=123.4567890000    // '.'포함 하여 총 14자리, 소수점 아래는 총 10자리, 빈자리는 0으로 채움▷ 문자열 출력 : %sString url = \"100jran.github.io\";System.out.printf(\"%s\", url);// console100jran.github.io▷ 지정한 자리수만큼 출력 : %20s(지정한 자리수는 20자리)String url = \"100jran.github.io\";\t\tSystem.out.printf(\"[%20s]\", url);// console[   100jran.github.io]▷ 왼쪽 정렬 : %-20sString url = \"100jran.github.io\";\t\tSystem.out.printf(\"[%-20s]\", url);// console[100jran.github.io   ]▷ 부분 출력 : %.8s(전체 중 8자리만 출력)String url = \"100jran.github.io\";System.out.printf(\"[%.8s]\", url);// console[100jran.]  // '.'포함 총 8자리Ch2 - 3. printf를 이용한 출력 예제▶ 정수 출력▷ 10진수 ‘10’ 출력System.out.printf(\"%d\", 10);// console10▷ 10진수 ‘10’을 8진수로 출력System.out.printf(\"%o\", 10);// console12▷ 10진수 ‘10’을 16진수로 출력System.out.printf(\"%x\", 10);// consolea▷ 10진수 ‘10’을 10진수, 8진수, 16진수로 접두사 붙여 출력System.out.printf(\"%d%n\", 10);System.out.printf(\"%#o%n\", 10);System.out.printf(\"%#x%n\", 10);// console100120xa▷ 10진수 ‘10’을 2진수 문자열로 출력System.out.printf(\"%s\", Integer.toBinaryString(10));\t// console1010▶ 실수 출력▷ float 타입으로 ‘123.456789’ 출력float f = 123.456789f;System.out.printf(\"%f\", f);\t// console123.456787  // float 타입은 끝 두자리 수 87 = 의미없는 수(정밀도가 7자리까지 7자리 이후 수는 의미無)▷ double 타입으로 ‘123.456789’ 출력double f = 123.456789;System.out.printf(\"%f\", f);// console123.456789  // double 타입 끝 두자리 89 = 의미있는 수(정밀도가 15자리까지 15자리까지의 수는 의미有)▷ double 타입의 ‘123.456789’를 %e로 출력double f = 123.456789;System.out.printf(\"%e\", f);// console1.234568e+02▷ double 타입의 ‘123.456789’를 %g로 출력double f = 123.456789;System.out.printf(\"%g\", f);// console123.457▶ 지정 출력▷ 지정자리 10자리 → ‘10’ 출력System.out.printf(\"[%10d]\", 10);// console[        10]지정자리 수가 출력할 값 보다 크다면?지정자리 수 무시 → 값 출력System.out.printf(\"[%2d]\", 12345);// console[12345]▷ 지정자리 10자리 + 왼쪽 정렬로 → ‘10’ 출력System.out.printf(\"[%-10d]\", 10);// console[10        ]▷ 지정자리 10자리 + 공백은 0으로 채워 → ‘10’ 출력System.out.printf(\"[%010d]\", 10);// console[0000000010]▷ 전체 16자리 + 소수점 아래는 10자리로 → ‘1.23456789’ 출력System.out.printf(\"[%16.10f]\", d);// console[    1.2345678900]▷ 지정자리 20자리 + 왼쪽정렬 → ‘100jran.github.io’ 출력String url = \"100jran.github.io\";System.out.printf(\"[%20s]\", url);// console[100jran.github.io   ]▷ ‘100jran.github.io’ 출력 → 10자리만 출력System.out.printf(\"[%.10s]\", url);// console[100jran.gi]",
        "url": "/2cornerstoneJava16"
    }
    ,
    
    "2cornerstonejava15": {
        "title": "Ch2-11. 기본형",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 11. 기본형의 종류와 범위Ch2 - 11. 기본형의 종류와 범위▶ 논리형 - boolean▷ 값 : true와 false 중 하나▷ 조건식과 논리적 계산에 사용▶ 문자형 - char▷ 값 : 문자▷ 변수 당 하나의 문자만 저장 가능▷ 변수 당 여러 문자를 저장하려면 String(참조형) 사용▶ 정수형 - int, long, byte, short▷ 값 : 정수▷ 정수형의 디폴트타입(주로 사용하는 타입) = int▷ 아주 큰 정수는 long▷ byte는 이진 데이터(이미지 파일…)를 다루는데 사용▷ short는 c언어와의 호환을 위해 추가(활용도 낮음)▶ 실수형 - float, double▷ 값 : 실수▷ float - floating point에서 저장▷ double - float 타입의 정밀도가 2배▷ 실수형의 디폴트타입 = double▶ 기본형의 종류와 크기▶ 기본형 - 표현범위 1▷ 변수의 타입마다 표현하는 방식이 다름▷ byte 타입을 예로 들면,byte b;b = 3;▷ n비트로 표현할 수 있는 값의 개수 : 2ⁿ개▷ n비트로 표현할 수 있는 부호없는 정수(양수)의 범위 : 0 ~ 2n - 1byte로 예를 들면2n =  28 = 256개양수 = 1 ~ 2ⁿ = 256개그러나 0을 포함시켜야 함으로0 ~ 2ⁿ - 1 = 256개그래서 1 ~ 256 0 ~ 255 = 256개▷ n비트로 표현할 수 있는 부호있는 정수(음/양수)의 범위 : -2n-1 ~ 2n-1 - 1▶ 기본형 - 표현범위 2▷ byte-27 ~ 27 - 1▷ short-215 ~ 215 - 1▷ char0 ~ 216 - 1▷ int-231 ~ 231 - 1▷ long-263 ~ 263 - 1  800경 보다 더 많은 수를 입력해야한다면?  Bit Integer 클래스 사용▶ 기본형 - 표현범위 3▷ float▷ double  정밀도가 float의 2배라서 double  정밀도가 2배인 만큼 정확도가 더 큼  그래서 실수형의 디폴트타입이 double",
        "url": "/2cornerstoneJava15"
    }
    ,
    
    "2cornerstonejava14": {
        "title": "Ch2-10. 기본형과 참조형",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 10. 기본형과 참조형Ch2 - 10. 기본형과 참조형▶ 기본형 Primitive type▷ 오직 8개  문자 - char(문자)  숫자          정수 - byte, short, int,long(20억이 넘는 정수는 long으로)      실수 - float(오차없이 7자리), double(15자리)        논리 - boolean(true와 false를 저장)▷ 실제 값을 저장▶ 참조형 Reference type▷ 객체의 주소를 저장 - 4 byte, 0x00000000~0xffffffffDate today; // 참조형 변수 today를 선언today = new Date(); // today에 객체의 주소를 저장▷ 기본형을 제외한 나머지 - String, System 등▷ 메모리 주소를 저장 (4 byte 또는 8 byte)※ 32bit JVM의 경우, 참조형의 크기는 4 byte    (MAX = 40억 byte = 4GB / 실사용량 = 2GB)※ 64bit JVM의 경우, 참조형의 크기는 8 byte    (MAX = 40억×40억 = 160경 byte = 160만TB / 실사용량 = TB단위 정도..)",
        "url": "/2cornerstoneJava14"
    }
    ,
    
    "2cornerstonejava13": {
        "title": "Ch2-9. 변수 값 바꾸기",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 9. 두 변수의 값 바꾸기Ch2 - 9. 두 변수의 값 바꾸기▶ x와 y값 바꾸기▷ x, y▷ x, y, tmp▶ 실습int x = 2, y = 4;int tmp;tmp = x;x = y;y = tmp;System.out.println(\"x = \" + x);System.out.println(\"y = \" + y);//consolex = 4y = 2",
        "url": "/2cornerstoneJava13"
    }
    ,
    
    "2cornerstonejava12": {
        "title": "Ch2-7~8. 문자·문자열",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 7. 문자 리터럴과 문자열 리터럴  Ch2 - 8. 문자열 결합Ch2 - 7. 문자 리터럴과 문자열 리터럴▶ 문자▷ char ch = 'A';▷ char ch = 'AB';   // 에러▷ char ch = ''; // 에러▶ 문자열▷ String s = \"AB\";▷ String s1 = \"AB\";  String은 자바에서 제공하는 클래스  클래스를 사용하기 위해서는 new 연산자를 통해 객체생성 해야함String s2 = new String(\"AB\");  그러나 String은 자주 사용하는 클래스 임으로 생략가능▷ String s = \"\";    // 빈 문자열▷ String s1 = \"A\" + \"B\" // 문자열 결합 = \"AB\"Ch2 - 8. 문자열 결합▶ 문자열 + anytype▷ 빈 문자열 + 숫자 = 숫자 → 문자열\"\" + 7 → \"\" + \"7\" → \"7\"(문자열)▷ 빈 문자열 + 숫자 + 숫자= 숫자 → 문자열\"\" + 7 + 7 → \"7\" + 7 → \"7\" + \"7\" → \"77\"(문자열)▷ 숫자 + 숫자 + 빈 문자열 = 숫자 → 문자열7 + 7 + \"\" → 14 + \"\" → \"14\" + \"\" → \"14\"(문자열)문자열 + anytype → 문자열anytype + 문자열 → 문자열▶ 실습int i = 'A';    // 문자코드 A의 값인 65가 출력 System.out.println(i);// console65String string = \"\";String str2 = \"ABCD\";String str3 = \"123\";String str4 = str2 + str3;System.out.println(str4);// consoleABCD123System.out.println(\"\" + 7 + 7);System.out.println(7 + 7 + \"\");// console7714",
        "url": "/2cornerstoneJava12"
    }
    ,
    
    "2cornerstonejava11": {
        "title": "Ch2-6. 접미사·접두사",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 6. 리터럴의 타입과 접미사Ch2 - 6. 리터럴의 타입과 접미사▶ 정리0x-참고▶ 예시▷ boolean power = true;▷ char ch = 'A';▷ String str = \"ABC\";▷ byte b = 127;▷ long l = 10000000000L▷ float f = 3.14f▷ float f = 100f▷ int hex = 0x100;▷ short s = 32767;▷ double d = 3.14d▶ 10.▷ 10.0▶ .10▷ 0.10▶ 10f▷ 10.0f▶ 3.14e3f▷ 3.140.0f▶ 1e1▷ 10.0",
        "url": "/2cornerstoneJava11"
    }
    ,
    
    "2cornerstonejava10": {
        "title": "Ch2-5. 변수·상수·리터럴",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 5. 변수, 상수, 리터럴Ch2 - 5. 변수, 상수, 리터럴▶ 변수(variable) - 변경가능▷ 하나의 값을 저장하기 위한 공간▶ 상수(constant) - 변경불가▷ 한 번만 값을 저장할 수 있는 변수▶ 리터럴(literal)▷ 그 자체로 값을 의미하는 것int score = 100;score = 200;final int MAX = 100; // MAX는 상수MAX = 200; // 에러char ch = 'A';String str = \"abc\";▶ 상수 / 변수 / 리터럴 구분",
        "url": "/2cornerstoneJava10"
    }
    ,
    
    "2cornerstonejava9": {
        "title": "Ch2-4. 변수 타입",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 4. 변수의 타입Ch2 - 4. 변수의 타입▶ 변수의 타입▷ 변수의 타입은 저장할 값의 타입에 의해 결정int age = 25;   // int(정수타입) --일치-- 25(정수) → 변수선언int age = 3.14; // int(정수타입) --불일치-- 3.14(실수) → 변수선언불가 ▷ 저장할 값의 타입과 일치하는 타입으로 변수 선언char ch = '가';    // char(문자타입) --일치-- 가(문자) → 변수선언double pi = 3.14; // double(실수타입) --일치-- 3.14(실수) → 변수선언▶ 값의 타입▷ 값 - 변수의 타입(기본형 Primitive type)  문자 - char(문자)  숫자          정수 - byte, short, int,long(20억이 넘는 정수는 long으로)      실수 - float(오차없이 7자리), double(15자리)        논리 - boolean(true와 false를 저장)",
        "url": "/2cornerstoneJava9"
    }
    ,
    
    "2cornerstonejava8": {
        "title": "Ch2-3. 변수 선언·저장",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 3. 변수의 선언과 저장Ch2 - 3. 변수의 선언과 저장▶ 변수(variable)란?▷ 하나의 값을 저장할 수 있는 메모리 공간▶ 변수의 선언▷ 변수의 선언 이유  값(data)을 저장할 공간을 마련하기 위해▷ 변수의 선언 방법  변수타입 변수이름;    int age; // 정수(int)타입의 변수 age를 선언          ▶ 변수에 값 저장하기▷ 변수에 값 저장하기 (‘=’은 등호 X 대입 O)int age; // 정수(int)타입의 변수 age를 선언age = 25; // 변수 age에 25를 저장 / age에 25를 대입int age = 25; // 위의 두 줄을 한 줄로 선언▷ 변수의 초기화 - 변수에 처음으로 값을 저장int x = 0; // 변수 x 선언 후, 0 으로 초기화int y = 5; // 변수 y 선언 후, 5 로 초기화int x = 0, y = 5; // 위으 두 줄을 한 줄로 선언▷ 변수의 종류 - 간략  클래스 변수  인스턴스 변수  지역 변수※ 지역 변수는 읽기 전에 꼭 초기화 해 주어야 함!▶ 변수의 값 읽어오기▷ 변수의 값이 필요한 곳에 변수의 이름을 작성int year = 0, age = 14;year = age + 2000;// year = 14 + 2000;// year = 2014;age = age + 1;// age = 14 + 1;// age = 15;System.out.println(age);// System.out.println(15);// 15가 화면에 출력▶ 실습int x = 4, y = 2;System.out.println(x + y);System.out.println(x - y);System.out.println(x * y);System.out.println(x / y);6282",
        "url": "/2cornerstoneJava8"
    }
    ,
    
    "2cornerstonejava7": {
        "title": "Ch2-1~2. 출력",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter2. 변수  Ch2 - 1. 화면에 글자 출력하기  Ch2 - 2. 덧셈 뺄셈 계산하기Ch2 - 1. 화면에 글자 출력하기▶ 프로젝트 + 클래스 생성▶ print()▷ 출력 후 줄바꿈 XSystem.out.print(\"Hello\");System.out.print(\"Hello\");System.out.print(\"Hello\");HelloHelloHello▶ println()▷ 출력 후 줄바꿈 OSystem.out.print(\"Hello\");System.out.print(\"Hello\");System.out.print(\"Hello\");HelloHelloHelloCh2 - 2. 덧셈 뺄셈 계산하기▶ “3 + 5”▷ “” 안에 있는 건 문자로 인식하여 입력한 그대로 출력System.out.print(\"3 + 5\");3 + 5▶ 3 + 5▷ 입력한 숫자와 기호를 계산하여 출력System.out.print(3 + 5);8",
        "url": "/2cornerstoneJava7"
    }
    ,
    
    "cornerstonejava6": {
        "title": "Ch1-17~19. 가져오기·내보내기",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 17. 깃허브에서 전체파일 다운  Ch1 - 18. 이클립스로 소스파일 가져오기  Ch1 - 19. 이클립스에서 소스파일 내보내기Ch1 - 17. 깃허브에서 전체파일 다운▶ 깃허브 &gt; 검색창 &gt; javajungsuk_basicCh1 - 18. 이클립스로 소스파일 가져오기▶ import 하기Ch1 - 19. 이클립스에서 소스파일 내보내기▶ export 하기▷ ch4 파일만 빼내기",
        "url": "/cornerstoneJava6"
    }
    ,
    
    "cornerstonejava5": {
        "title": "Ch1-13~16. 이클립스 단축키",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 13. 이클립스 단축키  Ch1 - 14. 단축키 설정 변경  Ch1 - 15. 자동완성 설정 변경  Ch1 - 16. 자동완성 목록 설정Ch1 - 13. 이클립스 단축키▶ Ctrl + Shift + L▷ 단축키 전체 목록 보기▶ Ctrl + ‘+’ / ‘-‘▷ 폰트 크기 증가 / 감소▶ Ctrl + D▷ 한 줄 삭제▶ Ctrl + alt + ↓▷ 한 줄 복사▶ alt + shift + A▷ 멀티컬럼 편집▶ alt + ‘↑’ / ‘↓’▷ 한 줄 이동▶ Ctrl + I▷ 자동 들여쓰기▶ Ctrl + /▷ 한 줄 주석(토글)  토글?한 번 눌리면 생기고 또 한 번 눌리면 없어지고 하는 것▶ 주석처리 할 부분 드래그 + Ctrl + Shift + /▷ 블록 주석▶ Ctrl + Shift + \\▷ 블록 주석 제거▶ /** + Enter▷ 주석 템플릿▶ Ctrl + space▷ 자동완성Ch1 - 14. 단축키 설정 변경▶ Window &gt; Preferences &gt; General &gt; keys▷ 한 줄 복사 단축키 변경 해 보기Ch1 - 15. 자동완성 설정 변경▶ Window &gt; Preferences &gt; Java &gt; Editor &gt; Templates▷ sysout 자동완성을 sop 으로 변경 해 보기Ch1 - 16. 자동완성 목록 설정▶ Window &gt; Preferences &gt; Java &gt; Editor &gt; Content Assist▷ 소문자 입력하면 자동으로 자동완성 목록이 나오게 하기",
        "url": "/cornerstoneJava5"
    }
    ,
    
    "cornerstonejava4": {
        "title": "Ch1-10~12. 이클립스",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 10. 이클립스 설치  Ch1 - 11. 이클립스로 자바프로그램 작성  Ch1 - 12. Build 관련 메뉴 설명Ch1 - 10. 이클립스 설치Ch1 - 11. 이클립스로 자바프로그램 작성▶ 프로젝트 생성▷ 방법1) 메뉴 File &gt; New &gt; Java Project▷ 방법2) Ctrl + N &gt; java p &gt; Java Project▶ 클래스 생성▷ 방법1) 프로젝트명 우클릭 &gt; New &gt; Class▷ 방법2) Ctrl + N &gt; class &gt; Java Class▶ .java 파일 작성 후 저장 &gt; 자동 컴파일 됨▶ 실행▷ 메뉴 Run &gt; Run▶ 자동 컴파일?Ch1 - 12. Build 관련 메뉴 설명▶ Build란?▷ 소스파일(.java)로부터 프로그램을 만들어내는 전 과정▶ Project &gt; Build All▷ workspace의 모든 므로젝트를 빌드▶ Project &gt; Build Project▷ 현재 프로젝트를 빌드 - 변경 된 소스파일만 새로 컴파일▶ Project &gt; Clean▷ 이전 빌드의 정보를 모두 삭제 - 모든 소스파일을 새로 컴파일▶ Project &gt; Build Automatically▷ 소스파일을 변경 후, 저장할 때마다 자동 컴파일",
        "url": "/cornerstoneJava4"
    }
    ,
    
    "cornerstonejava3": {
        "title": "Ch1-8~9. 자바 프로그램",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 8. 첫 번째 자바 프로그램 작성  Ch1 - 9. 자바 프로그램의 실행과정Ch1 - 8. 첫 번째 자바 프로그램 작성▶ Hello.java 생성▶ Hello.java 입력컴파일?▶ Hello.java 오류해결문제2해결-참고▶ 컴파일이 바로 되지 않는다면?▶ 경로 적지 않고 컴파일 하기▶ cmd창 새로 켜서 확인 해 보기 - 경로미작성Ch1 - 9. 자바 프로그램의 실행과정▶ .class / .java.class? .java?▶ 컴파일러 / 인터프리터컴파일러?인터프리터?▶ 클래스▷ 자바 프로그램의 단위▷ 자바 프로그램은 클래스들로 구성모든 문장은 클래스의 {} 안에 있어야 한다!class 클래스이름 { → 클래스 시작} → 클래스 끝▶ main 메서드▷ 자바 프로그램의 시작점▷ main 메서드 없이 프로그램 실행 불가class 클래스이름 {     public static void main(String[] args) { → main 메서드 시작        실행 할 문장을 넣기 - 첫 문장부터 순서대로 실행    } → main 메서드 끝}",
        "url": "/cornerstoneJava3"
    }
    ,
    
    "cornerstonejava2": {
        "title": "Ch1-5~7. JDK",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 5. JDK 설치  Ch1 - 6. JDK 설정  Ch1 - 7. 자바 API 문서 설치Ch1 - 5. JDK 설치▶ JDK = Java Development KitCh1 - 6. JDK 설정Ch1 - 7. 자바 API 문서 설치▶ Java API란?▷ Java로 프로그램을 만드는데 필요한 주요기능을 미리 만들어 둔 것▶ Java API 문서란?▷ Java API가 제공하는 기능에 대한 상세정보 제공 - .html▶ Java API 문서 설치▶ Java API 문서 사용법",
        "url": "/cornerstoneJava2"
    }
    ,
    
    "cornerstonejava": {
        "title": "Ch1-1~4. 자바",
            "author": "JungRan-Baek",
            "category": "",
            "content": "자바의 정석 기초편0. 목차  Chapter1. 자바를 시작하기 전에  Ch1 - 1. 자바란?  Ch1 - 2. 자바의 역사  Ch1 - 3. 자바의 특징  Ch1 - 4. 자바 가상머신(JVM)Ch1 - 1. 자바란?▶ 자바란?▷ 프로그래밍 언어▷ 애플리케이션을 만드는데 사용▷ 실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)▶ 자바의 쓰임?▷ 애플리케이션 - PC, 웹, 모바일(안드로이드)▷ 빅데이터▷ 게임 ···등Ch1 - 2. 자바의 역사▶ 자바 버전▷ JDK 1.0 (1996)▷ JDK 1.1 (1996)▷ J2SE 1.2 (1998)  J2SE : 스탠다드  J2ME : 마이크로(소형기계)  J2EE : 엔터프라이즈(대기업)▷ J2SE 1.3 (2000)▷ J2SE 1.4 (2002)▷ J2SE 5.0 (2004)▷ JAVA SE 6 (2006)▷ JAVA SE 7 (2011)▷ JAVA SE 8 (2014)▷ JAVA SE 9 (2017)▷ JAVA SE 10 (2018)▷ JAVA SE 11 (2018)▷ JAVA SE 12 (2019)▷ JAVA SE 13 (2019)안정성을 중요시 여기던 JAVA최신버전을 반영하기 위해 업데이트 주기가 짧아짐Ch1 - 3. 자바의 특징▷ 객체지향 언어▷ 자동 메모리 관리 - Garbage Collection(GC)▷ 멀티 쓰레드 지원▷ 풍부한 라이브러리로 쉽게 개발가능▷ 운영체제에 독립적 - JVM관련Ch1 - 4. 자바 가상머신(JVM)JVM 설명",
        "url": "/cornerstoneJava"
    }
    ,
    
    "calculator2": {
        "title": "calculator 2",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습박재성님의 자바 플레이그라운드 - 30. 목차  5. 메서드로 기능 분리  6. 클래스로 기능 분리  7. 사칙연산 - 문자열로 입력받기1. 메서드로 기능 분리▶ 기능분리▷ 메서드package baek.Calculator;import java.util.Scanner;public class Calculator {\tstatic int getFirstValue(Scanner scan) {\t\tSystem.out.println(\"값을 입력하세요.\");\t\tSystem.out.print(\"NUM&gt; \");\t\tint numOne = scan.nextInt();\t\tSystem.out.println();\t\treturn numOne;\t}\tstatic String getSymbol(Scanner scan) {\t\tSystem.out.println(\"연산기호를 입력하세요.(+, -, *, /, q=종료)\");\t\tSystem.out.print(\"SYMBOL&gt; \");\t\tString symbol = scan.next();\t\tSystem.out.println();\t\treturn symbol;\t}\tstatic int getSecondValue(Scanner scan) {\t\tSystem.out.println(\"값을 입력하세요.\");\t\tSystem.out.print(\"NUM&gt; \");\t\tint numTwo = scan.nextInt();\t\tSystem.out.println();\t\treturn numTwo;\t}\tstatic int getCalculater(int result, String symbol, int numTwo) {\t\tif (symbol.equals(\"+\")) {\t\t\tSystem.out.printf(\"%d + %d = \", result, numTwo);\t\t\tresult = result + numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"-\")) {\t\t\tSystem.out.printf(\"%d - %d = \", result, numTwo);\t\t\tresult = result - numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"*\")) {\t\t\tSystem.out.printf(\"%d × %d = \", result, numTwo);\t\t\tresult = result * numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"/\")) {\t\t\tSystem.out.printf(\"%d ÷ %d = \", result, numTwo);\t\t\tresult = result / numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else {\t\t\tSystem.err.println(\"사칙연산 기호가 아닙니다!\");\t\t\tSystem.out.println();\t\t}\t\treturn result;\t}\tstatic void print(int result) {\t\tSystem.out.printf(\"최종 값 = %d\\n\", result);\t}\tpublic static void main(String[] args) {\t\tScanner scanner = new Scanner(System.in);\t\tint numOne = getFirstValue(scanner);\t\tint result = numOne;\t\twhile (true) {\t\t\tString symbol = getSymbol(scanner);\t\t\t\t\t\tif (symbol.equals(\"q\")) {\t\t\t\tprint(result);\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\tint second = getSecondValue(scanner);\t\t\tresult = getCalculater(result, symbol, second);\t\t}\t\t\t\tSystem.out.println(\"종료\");\t}}값을 입력하세요.NUM&gt; 9연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; -값을 입력하세요.NUM&gt; 29 - 2 = 7연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; *값을 입력하세요.NUM&gt; 27 × 2 = 14연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; +값을 입력하세요.NUM&gt; 114 + 1 = 15연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; q최종 값 = 15종료▷ 메서드1 - 첫번째 값 입력static int getFirstValue(Scanner scan)▷ 메서드2 - 연산기호 입력static String getSymbol(Scanner scan)▷ 메서드3 - 두번째 값 입력static int getSecondValue(Scanner scan)▷ 메서드4 - 계산static int getCalculater(int result, String symbol, int numTwo)▷ 메서드5 - 결과 출력static void print(int result)2. 클래스로 기능 분리▶ 기능분리▷ 클래스▷ 클래스1 - 계산// Calculatepublic class Calculate {\tstatic int getCalculater(int result, String symbol, int numTwo) {\t\tif (symbol.equals(\"+\")) {\t\t\tSystem.out.printf(\"%d + %d = \", result, numTwo);\t\t\tresult = result + numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"-\")) {\t\t\tSystem.out.printf(\"%d - %d = \", result, numTwo);\t\t\tresult = result - numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"*\")) {\t\t\tSystem.out.printf(\"%d × %d = \", result, numTwo);\t\t\tresult = result * numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else if (symbol.equals(\"/\")) {\t\t\tSystem.out.printf(\"%d ÷ %d = \", result, numTwo);\t\t\tresult = result / numTwo;\t\t\tSystem.out.println(result);\t\t\tSystem.out.println();\t\t} else {\t\t\tSystem.err.println(\"사칙연산 기호가 아닙니다!\");\t\t\tSystem.out.println();\t\t}\t\treturn result;\t}}▷ 클래스2 - 명령// Commandimport java.util.Scanner;public class Command {\tpublic static void main(String[] args) {\t\tScanner scanner = new Scanner(System.in);\t\tint numOne = Input.getFirstValue(scanner);\t\tint result = numOne;\t\twhile (true) {\t\t\tString symbol = Input.getSymbol(scanner);\t\t\tif (symbol.equals(\"q\")) {\t\t\t\tOutput.print(result);\t\t\t\tbreak;\t\t\t}\t\t\tint second = Input.getSecondValue(scanner);\t\t\tresult = Calculate.getCalculater(result, symbol, second);\t\t}\t\tSystem.out.println(\"종료\");\t}}▷ 클래스3 - 입력// Inputimport java.util.Scanner;public class Input {\tstatic int getFirstValue(Scanner scan) {\t\tSystem.out.println(\"값을 입력하세요.\");\t\tSystem.out.print(\"NUM&gt; \");\t\tint numOne = scan.nextInt();\t\tSystem.out.println();\t\treturn numOne;\t}\tstatic String getSymbol(Scanner scan) {\t\tSystem.out.println(\"연산기호를 입력하세요.(+, -, *, /, q=종료)\");\t\tSystem.out.print(\"SYMBOL&gt; \");\t\tString symbol = scan.next();\t\tSystem.out.println();\t\treturn symbol;\t}\tstatic int getSecondValue(Scanner scan) {\t\tSystem.out.println(\"값을 입력하세요.\");\t\tSystem.out.print(\"NUM&gt; \");\t\tint numTwo = scan.nextInt();\t\tSystem.out.println();\t\treturn numTwo;\t}}▷ 클래스3 - 출력// Outputpublic class Output {\tstatic void print(int result) {\t\tSystem.out.printf(\"최종 값 = %d\\n\", result);\t}}3. 사칙연산 - 문자열로 입력받기▶ 사칙연산▷ 문자열로 입력 scanner - nextLinepackage baek.Calculator;import java.util.Scanner;public class StringCommand {\tpublic static void main(String[] args) {\t\tScanner scanner = new Scanner(System.in);\t\tSystem.out.println(\"계산식을 입력하세요.\");\t\tString input = scanner.nextLine();\t\tString[] inputS = input.split(\" \");\t\tint numOne = Integer.parseInt(inputS[0]);\t\tint result = numOne;\t\tfor (int i = 1; i &lt; inputS.length; i += 2) {\t\t\tString symbol = inputS[i];\t\t\tint numTwo = Integer.parseInt(inputS[i + 1]);\t\t\tresult = Calculate.getCalculater(result, symbol, numTwo);\t\t}\t\t\t\tOutput.print(result);\t\tscanner.close();\t}\t}계산식을 입력하세요.3 + 2 * 3 / 2 + 103 + 2 = 55 × 3 = 1515 ÷ 2 = 77 + 10 = 17최종 값 = 17▷ nextLinenextLine은‘3 + 2 * 3 / 2 + 10’ 이렇게 입력하면이걸 통째로 받아옴▷ String[] inputS = input.split(“ “);nextLine으로 받아온 내용을 “ “ 한 칸 띄운 것을 기준으로하나씩 배열로 담음▷ int numOne = Integer.parseInt(inputS[0]);첫번째 값은 첫번째 배열에 담겨있음numOne에 첫번째 배열 값을 넣음이 때, nextLine은 String으로 받아왔기 때문에첫번째 값을 parseInt를 통해 Int으로 바꿔서 넣어 줌▷ symbol과 numTwo 입력받기i = 1로 시작해서 i += 2로 돌게 하면inputS[i]는 배열 1, 3, 5, 7, 9에 있는 걸 꺼내줌그래서 연산기호만 나오게 됨연산기호 + 1 = 연산기호 다음에 오는 것 = 숫자그래서 numTwo는 inputS[i + 1]로 꺼낼 수 있음for (int i = 1; i &lt; inputS.length; i += 2) {\t\t\tString symbol = inputS[i];\t\t\tint numTwo = Integer.parseInt(inputS[i + 1]);\t\t\tresult = Calculate.getCalculater(result, symbol, numTwo);\t\t}",
        "url": "/calculator2"
    }
    ,
    
    "calculator": {
        "title": "calculator 1",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습박재성님의 자바 플레이그라운드 - 30. 목차  1. 사칙연산 - printf  2. 사칙연산 - 값 2개 입력받기  3. 사칙연산 - 연산기호 입력받기  4. 사칙연산 - 종료 시 최종값 출력1. 사칙연산 - printf▶ 사칙연산▷ printfpublic class Calculator {\tpublic static void main(String[] args) {\t\t\t\tSystem.out.printf(\"더하기 : %d\\n\", 2 + 1);\t\tSystem.out.printf(\"빼기 : %d\\n\", 2 - 1);\t\tSystem.out.printf(\"곱하기 : %d\\n\", 2 * 1);\t\tSystem.out.printf(\"나누기 : %d\\n\", 2 / 1);\t}}더하기 : 3빼기 : 1곱하기 : 2나누기 : 22. 사칙연산 - 값 2개 입력받기▶ 사칙연산▷ 값 입력 scanner - nextIntimport java.util.Scanner;public class Calculator {\tpublic static void main(String[] args) {\t\tScanner scan = new Scanner(System.in);\t\t\t\tSystem.out.printf(\"두 수를 입력하세요.\\n\\n\");\t\t\t\tSystem.out.println(\"첫번째 입력 값을 입력하세요.\");\t\tSystem.out.print(\"FIRST NUM&gt; \");\t\tint numOne = scan.nextInt();\t\tSystem.out.println();\t\t\t\tSystem.out.println(\"두번째 입력 값을 입력하세요.\");\t\tSystem.out.print(\"SECOND NUM&gt; \");\t\tint numTwo = scan.nextInt();\t\tSystem.out.println();\t\tSystem.out.println(\"사칙연산 결과\");\t\tSystem.out.printf(\"+ : %d + %d = %d\\n\", numOne, numTwo, numOne + numTwo);\t\tSystem.out.printf(\"- : %d - %d = %d\\n\", numOne, numTwo, numOne - numTwo);\t\tSystem.out.printf(\"× : %d × %d = %d\\n\", numOne, numTwo, numOne * numTwo);\t\tSystem.out.printf(\"÷ : %d ÷ %d = %d\\n\", numOne, numTwo, numOne / numTwo);\t}}두 수를 입력하세요.첫번째 입력 값을 입력하세요.FIRST NUM&gt; 3두번째 입력 값을 입력하세요.SECOND NUM&gt; 4사칙연산 결과+ : 3 + 4 = 7- : 3 - 4 = -1× : 3 × 4 = 12÷ : 3 ÷ 4 = 03. 사칙연산 - 연산기호 입력받기▶ 사칙연산▷ 연산기호 입력 scanner - nextIntimport java.util.Scanner;public class Calculator {\tpublic static void main(String[] args) {\t\tScanner scan = new Scanner(System.in);\t\tSystem.out.printf(\"두 수를 입력하세요.\\n\\n\");\t\tSystem.out.println(\"첫번째 입력 값을 입력하세요.\");\t\tSystem.out.print(\"FIRST NUM&gt; \");\t\tint numOne = scan.nextInt();\t\tSystem.out.println();\t\tSystem.out.println(\"두번째 입력 값을 입력하세요.\");\t\tSystem.out.print(\"SECOND NUM&gt; \");\t\tint numTwo = scan.nextInt();\t\tSystem.out.println();\t\tSystem.out.println(\"연산기호를 입력하세요.(+, -, *, /)\");\t\tSystem.out.print(\"CAL&gt; \");\t\tString cal = scan.next();\t\tSystem.out.println();\t\tif (cal.equals(\"+\")) {\t\t\tSystem.out.printf(\"+ : %d + %d = %d\\n\", numOne, numTwo, numOne + numTwo);\t\t}\t\telse if (cal.equals(\"-\")) {\t\t\tSystem.out.printf(\"- : %d - %d = %d\\n\", numOne, numTwo, numOne - numTwo);\t\t}\t\telse if (cal.equals(\"*\")) {\t\t\tSystem.out.printf(\"× : %d × %d = %d\\n\", numOne, numTwo, numOne * numTwo);\t\t}\t\telse if (cal.equals(\"/\")) {\t\t\tSystem.out.printf(\"÷ : %d ÷ %d = %d\\n\", numOne, numTwo, numOne / numTwo);\t\t} else {\t\t\tSystem.err.println(\"사칙연산 기호가 아닙니다!\");\t\t}\t}}두 수를 입력하세요.첫번째 입력 값을 입력하세요.FIRST NUM&gt; 4두번째 입력 값을 입력하세요.SECOND NUM&gt; 5연산기호를 입력하세요.(+, -, *, /)CAL&gt; *× : 4 × 5 = 204. 사칙연산 - 종료 시 최종값 출력▶ 사칙연산▷ 종료조건, 변수import java.util.Scanner;public class Calculator {\tpublic static void main(String[] args) {\t\tScanner scan = new Scanner(System.in);\t\tSystem.out.println(\"값을 입력하세요.\");\t\tSystem.out.print(\"NUM&gt; \");\t\tint numOne = scan.nextInt();\t\tSystem.out.println();\t\tint result = numOne;\t\twhile (true) {\t\t\tSystem.out.println(\"연산기호를 입력하세요.(+, -, *, /, q=종료)\");\t\t\tSystem.out.print(\"SYMBOL&gt; \");\t\t\tString symbol = scan.next();\t\t\tSystem.out.println();\t\t\t\t\t\tif (symbol.equals(\"q\")) {\t\t\t\tSystem.out.printf(\"최종 값 = %d\\n\", result);\t\t\t\tbreak;\t\t\t}\t\t\tSystem.out.println(\"값을 입력하세요.\");\t\t\tSystem.out.print(\"NUM&gt; \");\t\t\tint num = scan.nextInt();\t\t\tSystem.out.println();\t\t\tif (symbol.equals(\"+\")) {\t\t\t\tSystem.out.printf(\"%d + %d = \", result, num);\t\t\t\tresult = result + num;\t\t\t\tSystem.out.println(result);\t\t\t\tSystem.out.println();\t\t\t} else if (symbol.equals(\"-\")) {\t\t\t\tSystem.out.printf(\"%d - %d = \", result, num);\t\t\t\tresult = result - num;\t\t\t\tSystem.out.println(result);\t\t\t\tSystem.out.println();\t\t\t} else if (symbol.equals(\"*\")) {\t\t\t\tSystem.out.printf(\"%d × %d = \", result, num);\t\t\t\tresult = result * num;\t\t\t\tSystem.out.println(result);\t\t\t\tSystem.out.println();\t\t\t} else if (symbol.equals(\"/\")) {\t\t\t\tSystem.out.printf(\"%d ÷ %d = \", result, num);\t\t\t\tresult = result / num;\t\t\t\tSystem.out.println(result);\t\t\t\tSystem.out.println();\t\t\t} else {\t\t\t\tSystem.err.println(\"사칙연산 기호가 아닙니다!\");\t\t\t\tSystem.out.println();\t\t\t}\t\t}\t\t\t\tSystem.out.println(\"종료\");\t\tscan.close();\t}}값을 입력하세요.NUM&gt; 3연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; -값을 입력하세요.NUM&gt; 23 - 2 = 1연산기호를 입력하세요.(+, -, *, /, q=종료)SYMBOL&gt; q최종 값 = 1종료",
        "url": "/calculator"
    }
    ,
    
    "calender2": {
        "title": "Calender 2",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습코드스쿼드 자바 플레이그라운드 캘린더 만들기0. 목차  6. 가상의 달력 찍기1  7. 가상의 달력 찍기2 - 윤년  8. 시작일 설정 달력 찍기  9. 진짜 달력 자동으로 찍기1. 가상의 달력 찍기1▶ Mission.▷ 월을 입력하면 해당월의 달력을 출력한다.▷ 달력은 모양은 1단계에서 작성한 모양으로 만든다.▷ 1일은 일요일로 정해도 무방하다.▷ -1을 입력받기 전까지 반복 입력받는다.▷ 프롬프트를 출력한다.월을 입력하세요.&gt; 3일 월 화 수 목 금 토-------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 2829 30 31월을 입력하세요.&gt; -1Bye~▶ 혼자 Mission 해보기package baek.calender;import java.util.Scanner;public class Calender {\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tString PROMPT = \"cal&gt; \";\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\t\twhile(true) {\t\t\t\t\t\tSystem.out.printf(\"월을 입력하세요.\\n\");\t\t\tSystem.out.print(PROMPT);\t\t\tint month = scanner.nextInt();\t\t\t\t\t\tString b = \"\";\t\t\tString i = \"31\";\t\t\tString j = \"30 \";\t\t\tString t = \"29 \";\t\t\tString k = \" 28 \";\t\t\t\t\t\tif(month == 1) {\t\t\t\tb = t + j + i;\t\t\t} else if(month == 2) {\t\t\t\tb = \"\";\t\t\t} else if(month == 3) {\t\t\t\tb = t + j + i;\t\t\t} else if(month == 5) {\t\t\t\tb = t + j + i;\t\t\t} else if(month == 7) {\t\t\t\tb = t + j + i;\t\t\t} else if(month == 8) {\t\t\t\tb = t + j + i;\t\t\t} else if(month == 10) {\t\t\t\tb = t + j + i;\t\t\t} else {\t\t\t\tb = t + j;\t\t\t}\t\t\t\t\t\tSystem.out.println(\"일 월 화 수 목 금 토\");\t\t\tSystem.out.println(\"---------------------\");\t\t\tSystem.out.println(\" 1  2  3  4  5  6  7\");\t\t\tSystem.out.println(\" 8  9 10 11 12 13 14\");\t\t\tSystem.out.println(\"15 16 17 18 19 20 21\");\t\t\tSystem.out.println(\"22 23 24 25 26 27\" + k);\t\t\tSystem.out.println(b);\t\t\t\t\t\tif(month == -1) {\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\tif(month &gt; 12) {\t\t\t\tcontinue;\t\t\t}\t\t\t\t\t\tSystem.out.printf(\"\\n%d월은 %d일까지 있습니다.\\n\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\t\t\tSystem.out.println(\"Have a nice day!\");\t\tscanner.close();\t}}월을 입력하세요.cal&gt; 10일 월 화 수 목 금 토--------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 28 29 30 3110월은 31일까지 있습니다.월을 입력하세요.cal&gt; -1일 월 화 수 목 금 토--------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 28 29 30 Have a nice day!▶ 해설 보고 Mission 해보기 - 1▷ Prompt 클래스 생성 - 기능분리package baek.calender;import java.util.Scanner;public class Prompt {\t\tprivate final static String PROMPT = \"cal&gt; \";\t\tpublic void runPrompt() {\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\t\tint month = 1;\t\twhile(true) {\t\t\tSystem.out.println(\"월을 입력하세요.\");\t\t\tSystem.out.print(PROMPT);\t\t\tmonth = scanner.nextInt();\t\t\t\t\t\tif(month == -1) {\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\tif(month &gt; 12) {\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.printf(\"%d월은 %d일 까지 있습니다.\\n\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\t\tSystem.out.println(\"repeat 종료\");\t\tscanner.close();\t}\tpublic static void main(String[] args) {\t\tPrompt p = new Prompt();\t\tp.runPrompt();\t}}월을 입력하세요.cal&gt; 55월은 31일 까지 있습니다.월을 입력하세요.cal&gt; 22월은 28일 까지 있습니다.월을 입력하세요.cal&gt; 33월은 31일 까지 있습니다.월을 입력하세요.cal&gt; -1repeat 종료★ 기능별로 분리하는 습관!▶ 해설 보고 Mission 해보기 - 2▷ 실제 달력모양 출력일수 출력이 아닌 달력모양 출력이므로Calender 클래스에 있는 printCalender 메서드를Prompt 클래스에서 호출//Calenderpublic void printCalender(int year, int month) {\t\tSystem.out.printf(\"   &lt;&lt;%4d %3d&gt;&gt;\\n\", year, month);\t\tSystem.out.println(\"SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"--------------------\");\t\tSystem.out.println(\" 1  2  3  4  5  6  7\");\t\tSystem.out.println(\" 8  9 10 11 12 13 14\");\t\tSystem.out.println(\"15 16 17 18 19 20 21\");\t\tSystem.out.println(\"22 23 24 25 26 27 28\");\t}//Promptcal.printCalender(2021, month);package baek.calender;import java.util.Scanner;public class Prompt {\t\tprivate final static String PROMPT = \"cal&gt; \";\t\tpublic void runPrompt() {\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal \t= new Calender();\t\t\t\tint month = 1;\t\twhile(true) {\t\t\tSystem.out.println(\"월을 입력하세요.\");\t\t\tSystem.out.print(PROMPT);\t\t\tmonth = scanner.nextInt();\t\t\t\t\t\tif(month == -1) {\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\tif(month &gt; 12) {\t\t\t\tcontinue;\t\t\t}\t\t\tcal.printCalender(2021, month);\t\t}\t\t\tSystem.out.println(\"repeat 종료\");\t\tscanner.close();\t}\tpublic static void main(String[] args) {\t\tPrompt p = new Prompt();\t\tp.runPrompt();\t}}월을 입력하세요.cal&gt; 3   &lt;&lt;2021   3&gt;&gt;SU MO TU WE TH FR SA-------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 28월을 입력하세요.cal&gt; ▶ 해설 보고 Mission 해보기 - 3▷ 실제 달력모양 출력▷ 같은모양 다른코딩 - 반복문public void printCalender(int year, int month) {\t\tSystem.out.printf(\"   &lt;&lt;%4d %3d&gt;&gt;\\n\", year, month);\t\tSystem.out.println(\"SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"--------------------\");\t\tSystem.out.println(\" 1  2  3  4  5  6  7\");\t\tSystem.out.println(\" 8  9 10 11 12 13 14\");\t\tSystem.out.println(\"15 16 17 18 19 20 21\");\t\tSystem.out.println(\"22 23 24 25 26 27 28\");\t}\tpublic void printCalender(int year, int month) {\t\tSystem.out.printf(\"   &lt;&lt;%4d %3d&gt;&gt;\\n\", year, month);\t\tSystem.out.println(\"SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"--------------------\");\t\t\t\tint maxDays = maxDaysOfMonth(month);\t\t\t\tfor(int i = 1; i &lt;= maxDays; i++) {\t\t\tSystem.out.printf(\"%3d\", i);\t\t\t\t\t\tif(i % 7 == 0) {\t\t\t\tSystem.out.println();\t\t\t}\t\t}\t\tSystem.out.println();\t}월을 입력하세요.cal&gt; 3   &lt;&lt;2021   3&gt;&gt;SU MO TU WE TH FR SA--------------------  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31월을 입력하세요.cal&gt; 2   &lt;&lt;2021   2&gt;&gt;SU MO TU WE TH FR SA--------------------  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28월을 입력하세요.cal&gt; -1repeat 종료2. 가상의 달력 찍기2 - 윤년▶ Mission.▷ 윤년의 경우 29일까지 찍는 로직을 구현  윤년1.서력 기원 연수가 4로 나누어 떨어지는 해는 윤년으로 한다.2.서력 기원 연수가 4, 100으로 나누어 떨어지는 해는 평년으로 한다.3.서력 기원 연수가 4, 100, 400으로 나누어 떨어지는 해는 윤년으로 둔다.  윤년이 되는 경우  1) 4 ÷ 년도 == 0  2) 4 ÷ 년도 == 0 &amp;&amp; 400 ÷ 년도 == 0  3) 4 ÷ 년도 == 0 &amp;&amp; 400 ÷ 년도 == 0 &amp;&amp; 100 ÷ 년도 == 0  4 ÷ 년도 == 0 &amp;&amp; 100 ÷ 년도 == 0※ 이건 윤년 아님! 이건 평년!▶ 해설 보고 Mission 해보기▷ 윤년의 최대일수를 구하는 메서드 추가생성▷ 윤년을 계산하는 메서드 생성▷ month 뿐만 아니라 year 까지 입력받기//Calenderpackage baek.calender;public class Calender {\t\tpublic static final int[] MAX_DAYS \t\t= {31,28,31,30,31,30,31,31,30,31,30,31};\tpublic static final int[] LEAP_MAX_DAYS\t= {31,29,31,30,31,30,31,31,30,31,30,31};\t\tpublic int maxDaysOfMonth(int year, int month) {\t\tif(isLeapYear(year)) {\t\t\treturn LEAP_MAX_DAYS[month - 1];\t\t}else {\t\t\treturn MAX_DAYS[month - 1];\t\t}\t}\t\tpublic boolean isLeapYear(int year) {\t\tif(year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)) {\t\t\treturn true;\t\t}else {\t\t\treturn false;\t\t}\t\t}\t\tpublic void printCalender(int year, int month) {\t\tSystem.out.printf(\"   &lt;&lt;%4d %3d&gt;&gt;\\n\", year, month);\t\tSystem.out.println(\"SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"--------------------\");\t\t\t\tint maxDays = maxDaysOfMonth(year, month);\t\t\t\tfor(int i = 1; i &lt;= maxDays; i++) {\t\t\tSystem.out.printf(\"%3d\", i);\t\t\t\t\t\tif(i % 7 == 0) {\t\t\t\tSystem.out.println();\t\t\t}\t\t}\t\tSystem.out.println();\t}}//Promptpackage baek.calender;import java.util.Scanner;public class Prompt {\t\tpublic void runPrompt() {\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal \t= new Calender();\t\t\t\tint month \t= 1;\t\tint year \t= 1;\t\twhile(true) {\t\t\tSystem.out.println(\"년을 입력하세요.\");\t\t\tSystem.out.print(\"YEAR&gt; \");\t\t\tyear = scanner.nextInt();\t\t\tSystem.out.println(\"월을 입력하세요.\");\t\t\tSystem.out.print(\"MONTH&gt; \");\t\t\tmonth = scanner.nextInt();\t\t\t\t\t\tif(month == -1) {\t\t\t\tbreak;\t\t\t}\t\t\tif(month &gt; 12) {\t\t\t\tcontinue;\t\t\t}\t\t\tcal.printCalender(year, month);\t\t}\t\t\tSystem.out.println(\"repeat 종료\");\t\tscanner.close();\t}\tpublic static void main(String[] args) {\t\tPrompt p = new Prompt();\t\tp.runPrompt();\t}}년을 입력하세요.YEAR&gt; 20월을 입력하세요.MONTH&gt; 2   &lt;&lt;  20   2&gt;&gt;SU MO TU WE TH FR SA--------------------  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29년을 입력하세요.YEAR&gt; 21월을 입력하세요.MONTH&gt; 2   &lt;&lt;  21   2&gt;&gt;SU MO TU WE TH FR SA--------------------  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28년을 입력하세요.YEAR&gt; 10000월을 입력하세요.MONTH&gt; 2   &lt;&lt;10000   2&gt;&gt;SU MO TU WE TH FR SA--------------------  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29년을 입력하세요.YEAR&gt; -1월을 입력하세요.MONTH&gt; -1repeat 종료[알게 된 점]참고  1. boolean  데이터 타입ture/false 값을 가지는 데이터 타입  2. %4d  printf에서 %d는 정수%4d는 정수가 4칸 차지한다는 뜻년도는 현재 통상적으로 4자리 수 ex)2021년%4d로 설정 해 두고 21을 넣으면 __21 이렇게 나옴(__은 빈자리)  3. &amp;&amp;  A &amp;&amp; BA and BA 와 B == true둘 다 true면 true  4. ||  A || BA or BA 아니면 B == true둘 중 하나 true면 true3. 시작일 설정 달력 찍기▶ Mission.▷ 월을 입력받는다.▷ 1일의 요일을 입력받는다.▷ 출력한다.년도를 입력하세요.YEAR&gt; 2017달을 입력하세요.MONTH&gt; 3첫번째 요일을 입력하세요. (SU, MO, WE, TH, FR, SA)WEEKDAY&gt; WE    &lt;&lt;2017년  3월&gt;&gt; SU MO TU WE TH FR SA---------------------           1  2  3  4  5  6  7  8  9 10 11  ...▶ 해설보고 Mission 해보기//Calendarpublic class Calendar {\tpublic int weekday_Start(String weekday_Str) {\t\tif (weekday_Str.equals(\"SU\")) {\t\t\treturn 0;\t\t} else if (weekday_Str.equals(\"MO\")) {\t\t\treturn 1;\t\t} else if (weekday_Str.equals(\"TU\")) {\t\t\treturn 2;\t\t} else if (weekday_Str.equals(\"WE\")) {\t\t\treturn 3;\t\t} else if (weekday_Str.equals(\"TH\")) {\t\t\treturn 4;\t\t} else if (weekday_Str.equals(\"FR\")) {\t\t\treturn 5;\t\t} else if (weekday_Str.equals(\"SA\")) {\t\t\treturn 6;\t\t} else {\t\t\treturn 0;\t\t}\t}\tprivate static final int[] maxDayOfMonth = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\tprivate static final int[] leap_maxDayOfMonth = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\tpublic int get_maxDayOfMonth(int year, int month, int weekday) {\t\tif (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) {\t\t\treturn leap_maxDayOfMonth[month];\t\t}\t\treturn maxDayOfMonth[month];\t}\tpublic void printCalendar(int year, int month, int weekday) {\t\tint days = get_maxDayOfMonth(year, month, weekday);\t\tint count = 7 - weekday;\t\tint delim = count &lt; 7 ? count : 0;\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"---------------------\");\t\tfor (int i = 0; i &lt; weekday; i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tfor (int i = 1; i &lt;= days; i++) {\t\t\tSystem.out.printf(\"%3d\", i);\t\t\tif (i % 7 == delim) {\t\t\t\tSystem.out.println();\t\t\t}\t\t}\t\tSystem.out.printf(\"\\n\\n\");\t}\tpublic static void main(String[] args) {\t}}//Promptimport java.util.Scanner;public class Prompt {\tpublic static void main(String[] args) {\t\tScanner scanner = new Scanner(System.in);\t\tCalendar cal = new Calendar();\t\tint year = 0;\t\tint month = 0;\t\tint weekday = 0;\t\twhile (true) {\t\t\tSystem.out.println(\"년도를 입력하세요.(EXIT : -1)\");\t\t\tSystem.out.print(\"YEAR&gt; \");\t\t\tyear = scanner.nextInt();\t\t\tif (year == -1) {\t\t\t\tbreak;\t\t\t}\t\t\tSystem.out.println(\"월을 입력하세요.\");\t\t\tSystem.out.print(\"MONTH&gt; \");\t\t\tmonth = scanner.nextInt();\t\t\tif (month &gt; 12 || month &lt; 1) {\t\t\t\tSystem.out.println(\"입력오류\");\t\t\t\tSystem.out.println();\t\t\t\tcontinue;\t\t\t}\t\t\tSystem.out.println(\"요일을 입력하세요.(SU MO TU WE TH FR SA)\");\t\t\tSystem.out.print(\"DAY&gt; \");\t\t\tString weekday_Str = scanner.next();\t\t\tweekday = cal.weekday_Start(weekday_Str);\t\t\tcal.printCalendar(year, month, weekday);\t\t}\t\tSystem.out.println(\"종료\");\t\tscanner.close();\t}}년도를 입력하세요.(EXIT : -1)YEAR&gt; 2020월을 입력하세요.MONTH&gt; 5요일을 입력하세요.(SU MO TU WE TH FR SA)DAY&gt; MO SU MO TU WE TH FR SA---------------------     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31년도를 입력하세요.(EXIT : -1)YEAR&gt; [시작일 설정 방법]월마다 시작하는 요일이 다 다름그 때 마다 달력모양에서는 시작하는 부분을 맞춰줘야 함맞춰주기 위해서는 앞부분과 뒷부분을 생각해야함앞부분 - 띄어쓰기일요일은 띄어쓰기 없음월요일은 띄어쓰기 한 번화요일은 띄어쓰기 두 번이런 식으로 맞춰주어야 함이 설정을 weekday_Start에서 해 줌weekday_Start 이걸 불러다가 쓰면앞부분 띄어쓰기 설정은 완료weekday 설정 경로weekday_Str로 시작요일 입력받음 - SU MO TU WE TH FR SA→ cal.weekday_Start(weekday_Str)→ 요일에 해당하는 return 값을 받음→ weekday에 담음for (int i = 0; i &lt; weekday; i++) {System.out.print(\"   \");}weekday만큼 띄어쓰기 세 칸을 띄어쓰기 해 줌for (int i = 1; i &lt;= days; i++) {System.out.printf(\"%3d\", i);}해당 월의 일수를 3칸에 걸쳐 적어 줌뒷부분 - 줄바꿈앞부분을 띄어쓰기 해 놓으면 뒷부분은 자동 줄바꿈 되나?안 됨그래서 그것도 설정을 해 주어야 함줄바꿈은 숫자 7개를 쓰는 것으로 설정 해 둠그런데 첫 줄은 띄어쓰기 설정하면 일요일 제외 숫자 7개가 안됨그래서 7에서 띄어쓰기 한 수만큼 빼준 수를 기준으로 줄바꿈 설정 해야함띄어쓰기 한 수 = weekday7 - weekday를 설정int count = 7 - weekday;&lt;br/&gt;※ 근데 일요일은 7 - 0 이라서 7이 됨이런 경우는 줄바꿈을 아예 안하는 것으로 인식 됨일요일을 위해 delim을 하나 만들기int delim = count &lt; 7 ? count : 0;&lt;br/&gt;=delim=if (count &lt; 7) → return count;else → return 0;delim 설정을 해 주고일수(i)를 7로 나눈 나머지가 delim과 같다면 줄바꿈 해라!if (i % 7 == delim) {  System.out.println();}이렇게 작성을 해 주면 뒷 부분 줄바꿈도 설정 됨4. 진짜 달력 자동으로 찍기▶ Mission.▷ 년도와 월만 입력받는다.▷ 진짜 캘린더에서 나오는 달력과 똑같은 모양의 달력을 출력한다.년도를 입력하세요.&gt; 2017월을 입력하세요.&gt; 62017년 6월일 월 화 수 목 금 토       1  2  34  5  6  7  8  9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30년도를 입력하세요.&gt; -1Bye  ▶ 해설 보고 Mission 해보기//Promptimport java.util.Scanner;public class Prompt {\tpublic void runPrompt() {\t\tScanner scanner = new Scanner(System.in);\t\tCalendar cal = new Calendar();\t\tint year = 0;\t\tint month = 0;\t\twhile (true) {\t\t\tSystem.out.println(\"년도를 입력하세요.(EXIT : -1)\");\t\t\tSystem.out.print(\"YEAR&gt; \");\t\t\tyear = scanner.nextInt();\t\t\tif (year == -1) {\t\t\t\tbreak;\t\t\t}\t\t\tSystem.out.println(\"월을 입력하세요.\");\t\t\tSystem.out.print(\"MONTH&gt; \");\t\t\tmonth = scanner.nextInt();\t\t\tSystem.out.println();\t\t\tif (month &gt; 12 || month &lt; 1) {\t\t\t\tSystem.out.println(\"입력오류\");\t\t\t\tSystem.out.println();\t\t\t\tcontinue;\t\t\t}\t\t\tcal.printCalendar(year, month);\t\t}\t\tSystem.out.println(\"종료\");\t\tscanner.close();\t}\tpublic static void main(String[] args) {\t\tPrompt prt = new Prompt();\t\tprt.runPrompt();\t}}//Calendarpublic class Calendar {\tprivate static final int[] maxDayOfMonth \t\t\t= { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\tprivate static final int[] leap_maxDayOfMonth \t\t\t= { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\tpublic boolean isLeapYear(int year) {\t\t\t\tif (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) {\t\t\treturn true;\t\t} else {\t\t\treturn false;\t\t}\t}\t\tpublic int get_maxDayOfMonth(int year, int month) {\t\tif (isLeapYear(year)) {\t\t\treturn leap_maxDayOfMonth[month];\t\t}\t\treturn maxDayOfMonth[month];\t}\tpublic void printCalendar(int year, int month) {\t\tSystem.out.printf(\"     -%4d년 %d월-\\n\", year, month);\t\tSystem.out.println(\" SU MO TU WE TH FR SA\");\t\tSystem.out.println(\"---------------------\");\t\tint weekday = get_weekday(year, month, 1);\t\tfor (int i = 0; i &lt; weekday; i++) {\t\t\tSystem.out.print(\"   \");\t\t}\t\tint days = get_maxDayOfMonth(year, month);\t\tint count = 7 - weekday;\t\tint delim = count &lt; 7 ? count : 0;\t\tfor (int i = 1; i &lt;= days; i++) {\t\t\tSystem.out.printf(\"%3d\", i);\t\t\tif (i % 7 == delim) {\t\t\t\tSystem.out.println();\t\t\t}\t\t}\t\tSystem.out.printf(\"\\n\\n\");\t}\t\tpublic int get_weekday(int year, int month, int day) {\t\tint standard_Year \t\t\t= 1970;\t\tfinal int STANDAD_WEEKDAY \t= 4;\t\tint count = 0;\t\tfor (int y = standard_Year; y &lt; year; y++) {\t\t\t\t\t\tint year_Delta = isLeapYear(y) ? 366 : 365;\t\t\tcount += year_Delta;\t\t}\t\tfor (int m = 1; m &lt; month; m++) {\t\t\t\t\t\tint month_Delta = get_maxDayOfMonth(year, m);\t\t\tcount += month_Delta;\t\t}\t\t\t\tcount += day - 1;\t\t\t\tint weekday = (count + STANDAD_WEEKDAY) % 7;\t\treturn weekday;\t}}년도를 입력하세요.(EXIT : -1)YEAR&gt; 2021월을 입력하세요.MONTH&gt; 2     -2021년 2월- SU MO TU WE TH FR SA---------------------     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28년도를 입력하세요.(EXIT : -1)YEAR&gt; 2020월을 입력하세요.MONTH&gt; 2     -2020년 2월- SU MO TU WE TH FR SA---------------------                    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29년도를 입력하세요.(EXIT : -1)YEAR&gt; -1종료▷ 기준 = 1970.01.01.목일=0월=1화=2수=3목=4 → 기준! STANDAD_WEEKDAYint standard_Year \t\t\t= 1970;final int STANDAD_WEEKDAY \t= 4;▷ 년1970년도를 기준으로1년 씩 365를 더하기※ 윤년은 366을 더하기ex)1971년 = 3651972년 = 365 + 365for (int y = standard_Year; y &lt; year; y++) {  int year_Delta = isLeapYear(y) ? 366 : 365;  count += year_Delta;}▷ 월년도에 일수를 더함ex)1971년 2월 = 365 + 31(1월 것 까지)1972년 2월 = 365 + 365 + 31(1월 것 까지)for (int m = 1; m &lt; month; m++) {  int month_Delta = get_maxDayOfMonth(year, m);  count += month_Delta;}▷ 일day는 호출 받을 때 1로 받음이걸 카운트에서 빼 줘야 함//호출int weekday = get_weekday(year, month, 1);public int get_weekday(int year, int month, int day)년, 월의 일수를 받았다면기준요일인 목요일의 4만큼 띄어쓰기 해 준것도 카운트다 카운트하고 7로 나눠 준 것의 나머지 값만큼띄어쓰기 하면서 돌아가게 weekday로 넣어줌count += day - 1;  int weekday = (count + STANDAD_WEEKDAY) % 7;  return weekday;",
        "url": "/calender2"
    }
    ,
    
    "calender": {
        "title": "Calender 1",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습코드스쿼드 자바 플레이그라운드 캘린더 만들기0. 목차  1. 달력구현  2. 두 수의 합 출력  3. 입력받은 월의 일수 출력  4. 반복입력 프로그램 설정   5. 종료 조건을 이용해 반복하기1. 달력구현▶ Mission.▷ 아래 내용을 그대로 출력하는 프로그램을 작성해 본다.일 월 화 수 목 금 토-------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 28▶ 혼자 Mission 해보기 - 1package baek.calender;public class Calender {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"일 월 화 수 목 금 토\");\t\tSystem.out.println(\"---------------------\");\t\tSystem.out.println(\" 1  2  3  4  5  6  7\");\t\tSystem.out.println(\" 8  9 10 11 12 13 14\");\t\tSystem.out.println(\"15 16 17 18 19 20 21\");\t\tSystem.out.println(\"22 23 24 25 26 27 28\");\t\tSystem.out.println(\"29 30 31\");\t}}일 월 화 수 목 금 토--------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 2829 30 31간격이 맞지 않음콘솔로 볼 때는 맞지 않았는데 블로그에 올리니 간격 맞음▶ 혼자 Mission 해보기 - 2▷ 간격을 아예 넓혀서 코딩package baek.calender;public class Calender {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"일\t월\t화\t수\t목\t금\t토\");\t\tSystem.out.println(\"---------------------------------------------------\");\t\tSystem.out.println(\"1\t2\t3\t4\t5\t6\t7\");\t\tSystem.out.println(\"8\t9\t10\t11\t12\t13\t14\");\t\tSystem.out.println(\"15\t16\t17\t18\t19\t20\t21\");\t\tSystem.out.println(\"22\t23\t24\t25\t26\t27\t28\");\t\tSystem.out.println(\"29\t30\t31\");\t}}일\t월\t화\t수\t목\t금\t토---------------------------------------------------1\t2\t3\t4\t5\t6\t78\t9\t10\t11\t12\t13\t1415\t16\t17\t18\t19\t20\t2122\t23\t24\t25\t26\t27\t2829\t30\t31  자동정렬Ctrl + Shift + F2. 두 수의 합 출력 - scanner 활용▶ Mission.▷ 키보드로 입력받은 두 숫자의 합을 구한다.두 수를 입력하세요.5 10 (엔터)두 수의 합은 15입니다.▶ 혼자 Mission 해보기package baek.calender;import java.util.Scanner;public class Calender {\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"두 수를 입력하세요.\");\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\tString inputValue = scanner.nextLine();\t\t\t\tString[] splitedValue = inputValue.split(\" \");\t\t\t\tint first = Integer.parseInt(splitedValue[0]);\t\tint second = Integer.parseInt(splitedValue[1]);\t\t\t\tSystem.out.println(\"두 수의 합은 \" + (first + second) + \" 입니다.\");\t}}두 수를 입력하세요.5 10두 수의 합은 15 입니다.▶ 해설 보고 Mission 해보기package baek.calender;import java.util.Scanner;public class Sum {\tpublic static void main(String[] args) {\t\t//입력\t\tint a, b;\t\tScanner scanner = new Scanner(System.in);\t\tString s1, s2;\t\t\t\tSystem.out.println(\"두 수를 입력하세요.\");\t\ts1 = scanner.next();\t\ts2 = scanner.next();\t\ta = Integer.parseInt(s1);\t\tb = Integer.parseInt(s2);\t\t\t\t//출력\t\tSystem.out.printf(\"두 수의 합은 %d 입니다.\", a + b);\t\tscanner.close();\t}}두 수를 입력하세요.5 10두 수의 합은 15 입니다.  자동 importCtrl + Shift + M[알게 된 점]  1. System.in  키보드로 입력을 받겠다  2. scanner.next  키보드로 입력받는 값 = scanner.next = String    1) s1, s2 = String 타입 변수 → s1, s2를 이용하여 키보드로 입력한 값을 담음    2) s1, s2 → int a, b에 담음       a = Integer.parseInt(s1);       b = Integer.parseInt(s2);  3. Integer  Integer는 정수형 클래스    int ≠ Integer  4. printf 이용하기  a = 1, b = 2 일 때   system.out.printf(“두 수의 합은 %d”, a + b); = 두 수의 합은 3   system.out.printf(“%d와 %d의 합은 %d”, a, b, a + b); = 1와 2의 합은 3  5. scanner.close();  다 썼으면 문 닫아줘야 경고안남3. 입력받은 월의 일수 출력 - 배열 활용▶ Mission.▷ 달 입력 시 그 달의 일수를 출력하는 프로그램 작성하기달을 입력하세요.3 (엔터)3월은 31일까지 있습니다.▶ 혼자 Mission 해보기 - 1package baek.calender;import java.util.Scanner;public class Calender {\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tint a = scanner.nextInt();\t\t\t\tint[] b = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tSystem.out.println(b[a]);\t}}달을 입력하세요.330▶ 해설 보고 Mission 해보기 - 1▷ 변수명, 배열package baek.calender;import java.util.Scanner;public class Calender {\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tint month = scanner.nextInt();\t\t\t\tint[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다. \\n\", month, maxDays[month - 1]);\t}}달을 입력하세요.33월은 31일까지 있습니다. [알게 된 점]  1. 배열에서 마이너스 쓰기 가능  배열에는 0이 있기 때문에 입력한 달에서 -1을 해 주어야 날짜가 맞음  2. 변수명은 무엇을 하는 변수인지 알기쉽게!  혼자 했을 때는 a, b라고 변수명을 만들었음달 입력을 받는 변수는 month최대 일수를 나타내는 변수는 maxDays라고 해 주니 가시성 up  3. \\n  printf로 할 때 줄바꿈 키 : \\n▶ 해설 보고 Mission 해보기 - 2▷ 메서드, 배열package baek.calender;import java.util.Scanner;public class Calendar {\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다. \\n\", month, cal.maxDaysOfMonth(month));\t}}달을 입력하세요.33월은 31일까지 있습니다. [알게 된 점]  1. static과 final      static메모리에 한번 입력된 건 그걸로 계속 씀A가 10을 입력했는데 좀 있다 B도 10입력A가 입력한 10, B가 입력한 10 이렇게 따로 저장 안함A가 입력했을 때 10 잘 보관B가 또 10 입력하면 또 새로운 10 저장하는게 아니라 있는 10 씀메모리 낭비안함    final한번 한 결정이 최종결정번복이란 없는 노빠꾸 친구    static과 final죽이 잘 맞는 친구예를들어 A는 10을 입력하기도 하고 마음 변하면 20을 입력하기도 함그럼 static은 장단맞춰 10 저장 20도 저장근데 final A가 10 입력했다?그럼 A랑 10은 그냥 결혼한거임 주구장창 10만 입력static은 처음 입력해 둔 10만 꺼내주면 됨그래서 static과 final은 찰떡궁합    maxDays는?public static final int[] maxDays배열에 넣어두고 애초에 설정해 둔대로 딱 부르는 수만 나와라!참고    2. maxDaysOfMonth 메서드를 사용하기 위해서는?  maxDaysOfMonth가 있는 Calender 클래스를 쓸 수 있게 만들어 줌Calender cal = new Calender(); 이걸 해 주고cal.maxDaysOfMonth()를 해 주면 불러서 쓸 수 있음▶ 해설 보고 Mission 해보기 - 3▷ if문package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\tif(month == 2) {\t\t\treturn 28;\t\t} else if(month == 4) {\t\t\treturn 30;\t\t} else if(month == 6) {\t\t\treturn 30;\t\t} else if(month == 9) {\t\t\treturn 30;\t\t} else if(month == 11) {\t\t\treturn 30;\t\t} else {\t\t\treturn 31;\t\t}\t\t\t}\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\tint month = scanner.nextInt();\t\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다. \\n\", month, cal.maxDaysOfMonth(month));\t}}달을 입력하세요.33월은 31일까지 있습니다. if문 보단 배열이 낫다▶ 해설 보고 Mission 해보기 - 4▷ switchpackage baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\tswitch(month) {\t\tcase 2 :\t\t\treturn 28;\t\tcase 4 :\t\t\treturn 30;\t\tcase 6 :\t\t\treturn 30;\t\tcase 9 :\t\t\treturn 30;\t\tcase 11 :\t\t\treturn 30;\t\tdefault :\t\t\treturn 31;\t\t\t}\t\t}\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다. \\n\", month, cal.maxDaysOfMonth(month));\t}}달을 입력하세요.33월은 31일까지 있습니다. switch 보단 배열이 낫다▶ 혼자 응용 해보기▷ 달력도 나오게 해 보기 package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic void printCalender(int month) {\t\tString b = \"\";\t\tString i = \"31\";\t\tString j = \"30 \";\t\tString t = \"29 \";\t\tString k = \" 28\";\t\t\t\tif(month == 1) {\t\t\tb = t + j + i;\t\t} else if(month == 2) {\t\t\tb = \"\";\t\t} else if(month == 3) {\t\t\tb = t + j + i;\t\t} else if(month == 5) {\t\t\tb = t + j + i;\t\t} else if(month == 7) {\t\t\tb = t + j + i;\t\t} else if(month == 8) {\t\t\tb = t + j + i;\t\t} else if(month == 10) {\t\t\tb = t + j + i;\t\t} else {\t\t\tb = t + j;\t\t}\t\t\t\tSystem.out.printf(\"\\n2021년 %d월\\n\", month);\t\tSystem.out.println(\"일 월 화 수 목 금 토\");\t\tSystem.out.println(\"---------------------\");\t\tSystem.out.println(\" 1  2  3  4  5  6  7\");\t\tSystem.out.println(\" 8  9 10 11 12 13 14\");\t\tSystem.out.println(\"15 16 17 18 19 20 21\");\t\tSystem.out.println(\"22 23 24 25 26 27\" + k);\t\tSystem.out.println(b);\t}\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"달을 입력하세요.\");\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다. \\n\", month, cal.maxDaysOfMonth(month));\t\t\t\tcal.printCalender(month);\t}}달을 입력하세요.22월은 28일까지 있습니다. 2021년 2월일 월 화 수 목 금 토--------------------- 1  2  3  4  5  6  7 8  9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 284. 반복입력 프로그램 설정 - 반복문 활용▶ Mission.▷ 달 입력 시 그 달의 일수를 출력하는 프로그램 작성하기▷ 입력한 만큼 반복가능반복횟수를 입력하세요.3 (엔터)월을 입력하세요.1231월은 31일까지 있습니다.2월은 28일까지 있습니다.3월은 31일까지 있습니다.▶ 혼자 Mission 해보기package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tSystem.out.printf(\"반복 횟수를 입력하세요. \\n\");\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\t\tint month = scanner.nextInt();\t\t\t\tSystem.out.printf(\"\\n월을 입력하세요.\\n\");\t\t\t\tfor(int j = 1; j &lt; month + 1; j++) {\t\t\tSystem.out.println(j);\t\t}\t\t\t\tfor(int i = 1; i &lt; month + 1; i++) {\t\t\tSystem.out.printf(\"\\n%d월은 %d일까지 있습니다.\", i, cal.maxDaysOfMonth(i));\t\t\t}\t\tscanner.close();\t}}반복 횟수를 입력하세요. 3월을 입력하세요.1231월은 31일까지 있습니다.2월은 28일까지 있습니다.3월은 31일까지 있습니다.▶ 해설보고 Mission 해보기package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\t\tSystem.out.printf(\"반복 횟수를 입력하세요. \\n\");\t\tint repeat = scanner.nextInt();\t\tfor(int i = 0; i &lt; repeat; i++) {\t\t\tSystem.out.printf(\"\\n월을 입력하세요.\\n\");\t\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"\\n%d월은 %d일까지 있습니다.\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\tSystem.out.println(\"repeat 종료\");\t\tscanner.close();\t}}반복 횟수를 입력하세요. 3월을 입력하세요.11월은 31일까지 있습니다.월을 입력하세요.22월은 28일까지 있습니다.월을 입력하세요.33월은 31일까지 있습니다.repeat 종료[알게 된 점]  for과 while      for반복되는 횟수가 정해져 있을 때 쓰면 좋음    while반복되는 횟수가 정해져 있지 않을 때 쓰면 좋음  5. 종료 조건을 이용해 반복하기▶ Mission.▷ 전 단계와 비슷하게 반복입력을 받을 수 있게 구현한다.▷ 입력하는 곳 앞에 프롬프트를 출력한다.▷ -1일 입력받을 경우 프로그램을 종료한다.월을 입력하세요.&gt; 33월은 31일까지 있습니다.월을 입력하세요.&gt; 22월은 28일까지 있습니다.월을 입력하세요.&gt; -1Have a nice day!▶ 혼자 Mission 해보기package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\tfor(int i = 0; i &lt; 12; i++) {\t\t\tSystem.out.printf(\"월을 입력하세요.\\n&gt; \");\t\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다.\\n\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\tscanner.close();\t}}월을 입력하세요.&gt; 33월은 31일까지 있습니다.월을 입력하세요.&gt; 22월은 28일까지 있습니다.월을 입력하세요.&gt; 11월은 31일까지 있습니다.월을 입력하세요.&gt;▶ 해설보고 Mission 해보기 - 1▷ 프롬프트 넣기package baek.calender;import java.util.Scanner;public class Calender {\t\tint month;\t\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tString PROMPT = \"cal&gt; \";\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\tfor(int i = 0; i &lt; 12; i++) {\t\t\tSystem.out.printf(\"월을 입력하세요.\\n\");\t\t\tSystem.out.print(PROMPT);\t\t\tint month = scanner.nextInt();\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다.\\n\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\tscanner.close();\t}}월을 입력하세요.cal&gt; 33월은 31일까지 있습니다.월을 입력하세요.cal&gt; 44월은 30일까지 있습니다.월을 입력하세요.cal&gt; 1111월은 30일까지 있습니다.월을 입력하세요.cal&gt; 1212월은 31일까지 있습니다.월을 입력하세요.cal&gt;[알게 된 점]  print / println / printf 차이?     package baek.calender;   public class PlayGround {          public static void main(String[] args) {           System.out.print(\"프린트 print\");           System.out.print(\"프린트 print\");           System.out.printf(\"프린트에프 printf\");           System.out.printf(\"프린트에프 printf\");           System.out.println(\"프린트엘엔 println\");           System.out.println(\"프린트엘엔 println\");       }   }    프린트 print프린트 print프린트에프 printf프린트에프 printf프린트엘엔 println프린트엘엔 println    println만 개행  package baek.calender;public class PlayGround {\tpublic static void main(String[] args) {\t\tSystem.out.print(\"프린트 print\\n\");\t\tSystem.out.print(\"프린트 print\\n\");\t\tSystem.out.printf(\"프린트에프 printf\\n\");\t\tSystem.out.printf(\"프린트에프 printf\\n\");\t\tSystem.out.println(\"프린트엘엔 println\");\t\tSystem.out.println(\"프린트엘엔 println\");\t}}    프린트 print프린트 print프린트에프 printf프린트에프 printf프린트엘엔 println프린트엘엔 println    print 개행  :\\nprintf 개행 :\\nprintln 개행:자동  package baek.calender;public class PlayGround {\tpublic static void main(String[] args) {\t\t\t\tint a = 100;\t\t      System.out.print(\"프린트 print\\n %d, a\");\t\tSystem.out.print(\"프린트 print\\n %d, a\");\t\tSystem.out.printf(\"프린트에프 printf\\n %d\", a);\t\tSystem.out.printf(\"프린트에프 printf\\n %d\", a);\t\tSystem.out.println(\"프린트엘엔 println %d, a\");\t\tSystem.out.println(\"프린트엘엔 println %d, a\");\t}}    프린트 print%d, a프린트 print%d, a프린트에프 printf100프린트에프 printf100프린트엘엔 println %d, a프린트엘엔 println %d, a    printf만 %d가 적용  package baek.calender;public class PlayGround {\tpublic static void main(String[] args) {\t\t\t\tint a = 100;\t\t\t\tSystem.out.print(\"프린트 print\" + a + \"\\n\");\t\tSystem.out.print(\"프린트 print\" + a + \"\\n\");\t\tSystem.out.printf(\"프린트에프 printf %d\\n\", a);\t\tSystem.out.printf(\"프린트에프 printf %d\\n\", a);\t\tSystem.out.println(\"프린트엘엔 println\" + a);\t\tSystem.out.println(\"프린트엘엔 println\" + a);\t}}    프린트 print100프린트 print100프린트에프 printf 100프린트에프 printf 100프린트엘엔 println100프린트엘엔 println100    print / printf / printf는 계속하면서 적절한 게 무엇인지 파악▶ 해설보고 Mission 해보기 - 2▷ while문, if문 사용package baek.calender;import java.util.Scanner;public class Calender {\tpublic static final int[] maxDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\t\tpublic int maxDaysOfMonth(int month) {\t\treturn maxDays[month - 1];\t}\t\tpublic static void main(String[] args) {\t\t\t\tString PROMPT = \"cal&gt; \";\t\tScanner scanner = new Scanner(System.in);\t\tCalender cal = new Calender();\t\t\t\twhile(true) {\t\t\tSystem.out.printf(\"월을 입력하세요.\\n\");\t\t\tSystem.out.print(PROMPT);\t\t\tint month = scanner.nextInt();\t\t\t\t\t\tif(month == -1) {\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\tif(month &gt; 12) {\t\t\t\tcontinue;\t\t\t}\t\t\t\t\t\tSystem.out.printf(\"%d월은 %d일까지 있습니다.\\n\\n\", month, cal.maxDaysOfMonth(month));\t\t}\t\t\t\tSystem.out.println(\"Have a nice day!\");\t\tscanner.close();\t}}월을 입력하세요.cal&gt; 13월을 입력하세요.cal&gt; 1212월은 31일까지 있습니다.월을 입력하세요.cal&gt; 1111월은 30일까지 있습니다.월을 입력하세요.cal&gt; 1010월은 31일까지 있습니다.월을 입력하세요.cal&gt; 99월은 30일까지 있습니다.월을 입력하세요.cal&gt; -1Have a nice day![알게 된 점]  1. while(true)  while문 무한루프로 돌기  2. if(month == -1) → break  -1치면 while문 빠져나오기  3. if(month &gt; 12) → continue  12이상으로 치면 while문의 맨 처음으로",
        "url": "/calender"
    }
    ,
    
    "gugudan2": {
        "title": "구구단 2",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습박재성님의 자바 플레이그라운드 - 20. 목차5. 배열로 구구단 구현6. 메서드로 구구단 구현7. 클래스로 구구단 구현8. 최종요구사항1. 배열로 구구단 구현public class Gugudan {\tpublic static void main(String[] arg) {\t\tint[] result = new int [9];\t\tfor (int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = 2 * (i + 1);\t\t\tSystem.out.println(result[i]);\t\t}\t}}▷ int[] result = new int[9];배열9개의 칸이 있다고 생각하면 이와 같은 모양예를 들어result[1]은1번 칸에 뭐가 있는지 묻는 것1번 칸에는 0이 있음[1]에는 1(X) 0(O)▷ for (int i = 0; i &lt; result.length; i++)int i = 0; 배열은 0 부터 시작하기 때문i &lt; result.length; 배열의 길이는 0~8까지 총 9▷ result[i] = 2 * (i + 1);배열은 ‘0’ 부터 시작그래서 ‘i + 1’▷ System.out.println(result[i]);//console246810121416182. 메서드로 구구단 구현▶ 9단을 메서드로 구현public class Gugudan {\t\tpublic static int[] calculate(int times) {\t\tint[] result = new int[9];\t\t\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = times * (i + 1);\t\t}\t\treturn result;\t}\t\tpublic static void main(String[] args) {\t\tint[] result = calculate(9);\t\t\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tSystem.out.println(result[i]);\t\t}\t}}▷ Main 메서드 부터 실행public static void main(String[] args) {  int[] result = calculate(9);    for(int i = 0; i &lt; result.length; i++) {  System.out.println(result[i]);  } } int배열(정수배열)로 되어있는 result라는 사물함에는9를 받는 calculate가 들어있음▷ calculatepublic static int[] calculate(int times) {  int[] result = new int[9];    for(int i = 0; i &lt; result.length; i++) {      result[i] = times * (i + 1);  }  return result;}calculate는 이렇게 생긴 메서드int[] result = calculate(9);↓public static int[] calculate(int times)int times에 9를 넣어 출력하라는 것calculate(9)를 호출 했고calculate 메서드에서return 값인 9단을 얻음다시 main으로 가자▷ 다시 mainpublic static void main(String[] args) {    int[] result = calculate(9);        for(int i = 0; i &lt; result.length; i++) {        System.out.println(result[i]);    }}int[] result에는 calculate에서 얻은 return 값인 9단이 배열로 들어있음이걸 반복문에 넣어서차례로 꺼내는 것(println)//console91827364554637281▶ 5단을 메서드로 구현public class Gugudan {\t\tpublic static int[] calculate(int times) {\t\tint[] result = new int[9];\t\t\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = times * (i + 1);\t\t}\t\treturn result;\t}\t\tpublic static void main(String[] args) {\t\tint[] times5 = calculate(5);\t\t\t\tfor(int i = 0; i &lt; times5.length; i++) {\t\t\tSystem.out.println(times5[i]);\t\t}\t}}//console51015202530354045▶ 메서드로 출력 구현 - 5단 출력출력하는 메서드를 만들어서for문 + System.out.println(); → 이 중복 없애기public class Gugudan {\t\tpublic static int[] calculate(int times) {\t\tint[] result = new int[9];\t\t\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = times * (i + 1);\t\t}\t\treturn result;\t}\t\tpublic static void print(int[] result) {\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tSystem.out.println(result[i]);\t\t}\t}\t\tpublic static void main(String[] args) {\t\tint[] baek = calculate(5);\t\tprint(baek);\t}}print라는 return 값이 없는 void 메서드를 생성public static void print(int[] result) {    for(int i = 0; i &lt; result.length; i++) {        System.out.println(result[i]);    }}calculate 메서드의 return 값인 result를 받는 메서드for문을 result의 배열길이만큼 돈 후값을 출력그래서 main 메서드 에서는출력문을 생략하고 print 메서드를 호출public static void main(String[] args) {    int[] baek = calculate(5);    print(baek);}//console51015202530354045▶ 2단부터 9단까지 자동으로 출력되는 메서드 구현▷ for문 사용public class Gugudan {\t\tpublic static int[] calculate(int times) {\t\tint[] result = new int[9];\t\t\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = times * (i + 1);\t\t}\t\treturn result;\t}\t\tpublic static void print(int[] result) {\t\tfor(int i = 0; i &lt; result.length; i++) {\t\t\tSystem.out.println(result[i]);\t\t}\t}\t\tpublic static void main(String[] args) {\t\tfor(int i = 2; i &lt; 10; i++) {\t\t\tint[] baek = calculate(i);\t\t\tprint(baek);\t\t}\t}}//console24681012141618369121518··· 9단까지 계속  main 메서드          for문 = i가 2~9까지 돌게 함      calculate(i); → i를 통해 2~9를 calculate 메서드에 뿌림      int[] baek = calculate(i) → 2단,3단,,, 차례로 baek 사물함에 보관      print 메서드를 통해 출력      3. 클래스로 구구단 구현  GugudanMain 클래스 생성  calculate 메서드는 Gugudan 클래스에 있기때문에Gugudan.calculate  print 메서드도 Gugudan 클래스에 있기때문에 Gugudan.print로 호출public class GugudanMain {\tpublic static void main(String[] args) {\t\tfor(int i = 2; i &lt; 10; i++) {\t\t\tint[] baek = Gugudan.calculate(i);\t\t\tGugudan.print(baek);\t\t}\t}}package baekGugudan;import java.util.Scanner;public class Gugudan {\tpublic static int[] calculate(int times) {\t\tint[] result = new int[9];\t\tfor (int i = 0; i &lt; result.length; i++) {\t\t\tresult[i] = times * (i + 1);\t\t}\t\treturn result;\t}\tpublic static void print(int[] result) {\t\tfor (int i = 0; i &lt; result.length; i++) {\t\t\tSystem.out.println(result[i]);\t\t}\t}\tpublic static void main(String[] args) {\t\tSystem.out.println(\"몇 단?\");\t\tScanner scanner = new Scanner(System.in);\t\tint number = scanner.nextInt();\t\tfor (int j = 1; j &lt; 10; j++) {\t\t\tSystem.out.println(number + \"X\" + j + \"=\" + number * j);\t\t}\t\tscanner.close();\t}}//console몇 단?55X1=55X2=105X3=155X4=205X5=255X6=305X7=355X8=405X9=454. 최종요구사항최종 요구사항 1  사용자가 입력한 값에 따라 크기가 다른 구구단을 계산해 출력한다.  예를 들어 사용자가 8을 입력하면 팔팔단,19를 입력하면 십구십구단(2 * 1에서 19 * 19)을 계산해 출력한다.▶ 혼자 해보기 - 힌트참고Ximport java.util.Scanner;public class Gugudan {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"몇 단?\");\t\tScanner scanner = new Scanner(System.in);\t\tint number = scanner.nextInt();\t\t\t\tfor(int i = 2; i &lt;= number; i++) {\t\t\tfor(int j = 1; j &lt;= number; j++) {\t\t\t\tSystem.out.println(i + \"X\" + j + \"=\" + i * j);\t\t\t}\t\t}\t}}//console몇 단?52X1=22X2=42X3=62X4=82X5=103X1=33X2=63X3=93X4=123X5=154X1=44X2=84X3=124X4=164X5=205X1=55X2=105X3=155X4=205X5=25최종 요구사항 2  사용자가 입력한 값에 따라 크기가 다른 구구단을 계산해 출력한다.  예를 들어 사용자가 “8,7”과 같은 문자열을 입력하면 팔칠단을 구현한다.  팔칠단은 2 * 1 … 2 * 7, 3 * 1 … 3 * 7, … , 8 * 1 … 8 * 7 까지 구현하는 것을 의미한다.▶ 혼자 해보기 - 힌트참고Ximport java.util.Scanner;public class Gugudan {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"2단부터 시작됩니다.\");\t\tScanner scanner = new Scanner(System.in);\t\tint i = scanner.nextInt();\t\tint j = scanner.nextInt();\t\t\t\tif(i &lt; 2) {\t\t\tSystem.out.println(\"2보다 큰 수를 입력하세요.\");\t\t} else {\t\t\tfor(int a = 2; a &lt;= i; a++) {\t\t\t\tfor(int b = 1; b &lt;= j; b++) {\t\t\t\t\tSystem.out.println(a + \"X\" + b + \"=\" + a * b);\t\t\t\t}\t\t\t}\t\t}\t}}//console2단부터 시작됩니다.8 72X1=22X2=42X3=62X4=82X5=102X6=122X7=143X1=33X2=63X3=93X4=123X5=153X6=183X7=214X1=44X2=84X3=124X4=164X5=204X6=244X7=285X1=55X2=105X3=155X4=205X5=255X6=305X7=356X1=66X2=126X3=186X4=246X5=306X6=366X7=427X1=77X2=147X3=217X4=287X5=357X6=427X7=498X1=88X2=168X3=248X4=328X5=408X6=488X7=56▶ 힌트참고import java.util.Scanner;public class Gugudan {\tpublic static void main(String[] args) {\t\t\t\tSystem.out.println(\"입력하세요. \" + \"a,b\");\t\t\t\tScanner scanner = new Scanner(System.in);\t\t\t\tString inputValue = scanner.nextLine();\t\t\t\tString[] splitedValue = inputValue.split(\",\");\t\t\t\tint first = Integer.parseInt(splitedValue[0]);\t\tint second = Integer.parseInt(splitedValue[1]);\t\tSystem.out.println(first + \"단까지 \" + second + \"만큼 곱하겠습니다!\");\t\t\t\tfor(int i = 2; i &lt;= first; i++) {\t\t\tfor (int j = 1; j &lt;= second; j++) {\t\t\t\tSystem.out.println(i + \"X\" + j + \"=\" + i * j);\t\t\t}\t\t}\t}}//console입력하세요. a,b4,54단까지 5만큼 곱하겠습니다!2X1=22X2=42X3=62X4=82X5=103X1=33X2=63X3=93X4=123X5=154X1=44X2=84X3=124X4=164X5=20▶ 알게 된 점      String inputValue = scanner.nextLine();String 타입은 문자열 타입입력한 숫자 2개를 문자열로 받음        String[] splitedValue = inputValue.split(“,”);사용자가 입력한 숫자 2개를 []배열에 넣어서,를 기준으로 분리        int first = Integer.parseInt(splitedValue[0]);int second = Integer.parseInt(splitedValue[1]);숫자 2개 중 첫째[0]는 first / 둘째[1]는 second에 넣어줌String → int정수타입으로 바꿔 줌  ",
        "url": "/gugudan2"
    }
    ,
    
    "gugudan": {
        "title": "구구단 1",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습박재성님의 자바 플레이그라운드 - 20. 목차1. 2단/3단 구현 - 계산 및 출력2. 4단/5단 구현 - 값 입력 및 변수3. 6단/7단 구현 - 반복문4. 8단/9단 구현 - 값 입력 및 조건문1. 2단/3단 구현 - 계산 및 출력▶ Gugudan 프로젝트 생성▶ 2단/3단 구현▷ System.out.println 사용// 2단System.out.println(\"2단\");System.out.println(2 * 1);System.out.println(2 * 2);System.out.println(2 * 3);System.out.println(2 * 4);System.out.println(2 * 5);System.out.println(2 * 6);System.out.println(2 * 7);System.out.println(2 * 8);System.out.println(2 * 9);// 3단System.out.println(\"3단\");System.out.println(3 * 1);System.out.println(3 * 2);System.out.println(3 * 3);System.out.println(3 * 4);System.out.println(3 * 5);System.out.println(3 * 6);System.out.println(3 * 7);System.out.println(3 * 8);//console2단24681012141618단축키 사용라인 복사 : Ctrl + Alt + 화살표아래콘솔 실행 : Ctrl + F112. 4단/5단 구현 - 값 입력 및 변수단축키 사용주석처리 : 드래그 + Ctrl + / ▶ 4단 구현 ▷ 변수 사용// 4단int result = 4 * 1;System.out.println(result);result = 4 * 2;System.out.println(result);result = 4 * 3;System.out.println(result);result = 4 * 4;System.out.println(result);result = 4 * 5;System.out.println(result);result = 4 * 6;System.out.println(result);result = 4 * 7;System.out.println(result);result = 4 * 8;System.out.println(result);result = 4 * 9;System.out.println(result);  //console4812162024283236▶ 변수? - 나만의정의  result에 ‘4’ ‘*’ ‘1’ 넣어주고result안에 뭐있냐? 물어보면‘4’ 있다 - console이 꺼내서 보여줌  resultresult는 사물함‘result’라는 이름은 사물함 이름표  intresult 앞에 ‘int’는 ‘반’ 같은 것(ex.피아노반,성악반,기타반,작곡반…)int는 숫자 정수 반‘4’가 들어있는 사물함이니까 int가 붙은 것  변수변수는 사물함데이터타입데이터타입은 끼리끼리 묶어놓은 반int는 정수타입변수는 필요하면 집어넣고 꺼내쓰고 하는 것데이터타입은 변수를 빠르고 쉽게 사용하기 위해 정리 해 둔 것▶ 5단 구현▷ 변수, scanner 사용import java.util.Scanner;// 5단System.out.println(\"원하는 구구단은? : \");Scanner scanner = new Scanner(System.in);int number = scanner.nextInt();System.out.println(number * 1);System.out.println(number * 2);System.out.println(number * 3);System.out.println(number * 4);System.out.println(number * 5);System.out.println(number * 6);System.out.println(number * 7);System.out.println(number * 8);System.out.println(number * 9);//console원하는 구구단은? : 551015202530354045원하는 단을 입력하면 구구단 출력여기서는 number가 변수number는 scanner의 ‘nextInt()’를 통해 입력받은 값을 넣어 둠3. 6단/7단 구현 - 반복문▶ 6단 구현▷ 변수, 반복문(while) 사용// 6단int i = 1;while (i &lt; 10) {    System.out.println(6 * i);    i = i + 1;}while (i &lt; 10)변수 i를 사용하여 1부터 9까지 돌면서 곱하기i의 초기값은 1마지막값은 9i가 돌면서 i + 1 되니까i는 1,2,3,4,5,6,7… 1씩 증가i가 10이 되면 while문 나옴▶ 7단 구현▷ 변수, 반복문(for)// 7단System.out.println(\"7단\");for (int j = 1; j &lt; 10; j++) {System.out.println(7 * j);}for (int j = 1; j &lt; 10; j++)변수 j를 사용하여 1부터 9까지 돌면서 곱하기j의 초기값은 1마지막값은 9j++은 후치연산자 : ‘7 * j’가 계산 된 후에 j에 1을 더하는 것j는 돌면서 1,2,3,4,5,6,7… 1씩 증가j가 10이 되면 for문 나옴4. 8단/9단 구현 - 값 입력 및 조건문▶ 구구단 구현▷ 변수, 조건문, 반복문, Scanner3가지 상황 만들기  1) 2단 부터 9단 까지만 실행  2) 2단 미만을 입력하면 “값을 잘못 입력했습니다.”라는 경고실행  3) 9단 초과를 입력하면 “값을 잘못 입력했습니다.”라는 경고실행// 8단, 9단System.out.println(\"원하는 구구단은? : \");Scanner scanner = new Scanner(System.in);int number = scanner.nextInt();System.out.println(\"사용자가 입력한 값 : \" + number);if (number &lt; 2) {    System.out.println(\"값을 잘못 입력했습니다.\");} else if (number &gt; 9) {    System.out.println(\"값을 잘못 입력했습니다.\");} else {    for (int i = 1; i &lt; 10; i++) {        System.out.println(number * i);    }}//console원하는 구구단은? : 8사용자가 입력한 값 : 881624324048566472      변수변수 number는 원하는 단으로변수 i는 1부터 9까지 곱하기        조건문 if (number &lt; 2)2 미만의 단 입력 시“값을 잘못 입력했습니다.” 경고실행        조건문 else if (number &gt; 9)조건문 if는 통과9 초과의 단 입력 시“값을 잘못 입력했습니다.” 경고실행        조건문 esle조건문 if/조건문 else if 통과 시반복문 실행        반복문 for (int i = 1; i &lt; 10; i++)i의 초기값은 1, 10미만 즉 9까지, 1씩 증가system.out.println(number * i)입력한 number에 1~9까지 곱  ",
        "url": "/gugudan"
    }
    ,
    
    "case": {
        "title": "eclips 프로젝트와 github 저장소 연결",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  실습박재성님의 자바 플레이그라운드 - 10.목차1.eclips 설치2.github와 연결 할 프로젝트 생성3.github 저장소 생성4.eclips 프로젝트와 github 저장소 연결1.eclips 설치1.java 설치      2.eclips 설치      eclips와 작업공간은 폴더 하나에 함께 생성3.eclips 기본설정  디폴트는 jre만 잡혀있는 상태  jre는 작기 때문에 조금 더 큰 jdk를 잡아주기    2.github와 연결 할 프로젝트 생성“Hello World” 출력 프로그램 구현 및 실행  3.github 저장소 생성“hello-world”라는 github 저장소 생성  4.eclips 프로젝트와 github 저장소 연결eclips 프로젝트가 github 저장소까지 가기위해서eclips 저장소도 생성eclips 저장소에 올리기 즉 commitpush 하면 eclips 저장소와 github 저장소 동기화eclips에서 github 도착eclips 프로젝트 수정하여 commit and pushgithub에 가서 확인해보기commit한 타임라인이 남아있음타임라인을 통해 원하는 타임의 상황으로 백업이 가능",
        "url": "/case"
    }
    ,
    
    "basic": {
        "title": "Before Learning Java",
            "author": "JungRan-Baek",
            "category": "",
            "content": "  학습내용 정리0.목차1.Programmer?2.기계어?3.Code?4.Compile?5.Interpreter?6.Java?7.JVM?8.JVM 원리  8.1 Compiler 이동  8.2 JVM 이동9.전자정부프레임워크?1.Programmer?  Programmer    : Program 을 만드는 사람  Program       : CPU(컴퓨터)에 작업을 지시하는 수단    Programmer는 CPU(컴퓨터)에 작업을 지시하는 수단을 만드는 사람    Source Program    : 문자열 프로그램  Programming       : Programmer가 CPU(컴퓨터)에 작업을 지시하는 수단을 만드는 행위2.기계어?  알파벳 : Programmer가 Programming을 할 때 사용CPU는 알파벳 해독불가능  기계어 : CPU가 읽는 언어    기계어: 0,1로 이루어진 수이진수: 0,1로 이루어진 수*bit: 0,1로 이루어진 수        *bit(binary digit): CPU가 표현할 수 있는 최소단위(0=false, 1=true)      3.Code?  bit의 의미전달 한계점bit는 0(false)과 1(true)로 표현‘사과는 맛있어?’ = 0과 1로 대답가능‘사과는 무슨 색이야?’ = 0과 1로??  bit를 조합한 부호사과가 무슨 색인지 ‘빨간색 = 0100, 파란색 = 1110’ 같은 bit를 조합한 부호로 대답가능즉 Code로 대답가능    Code는 bit를 조합한 부호,약속 된 부호    ASCII(American Standard Code for Information Interchange)          8비트(8비트=1바이트)      기호, 알파벳 대소문자, 숫자 표현가능      처음으로 표준을 적립한 문자열 인코딩 방식        unicode          16비트      기호, 알파벳대소문자, 숫자, 전세계 언어 표현가능      4.Compile?  Compile알파벳으로 작성 한 Code가 CPU에 전달 되기까지 어떤 과정을 거치는가?고급언어 = 알파벳낮은 수준의 언어 ≠ 기계어고급언어인 알파벳이 바로 기계어로 변환 안됨고급언어 - 낮은 수준의 언어 - 기계어 순으로 변환 됨Compile은 Compiler로 고급언어를 한 단계 낮춰주는 것Java로 예를 들어보자‘이클립스’라는 툴을 이용해서 자바 웹 개발자가 알파벳으로 코딩을 하고 저장하면,Java는 Compile과정을 거쳐 .java와 .class 파일 두 개를 생성.java는 고급언어 .class는 낮은 수준의 언어.class파일은 Compiler가 compile한 결과! 즉 낮은 수준의 언어  .class = 중간코드 = 바이트코드    5.Interpreter?            Interpretercompile한 .class가 CPU에 전달 되기까지 어떤 과정을 거치는가?interpreter는 compile한 .class를 한 줄 한 줄 기계어로 변환시켜 CPU에게 전달  Compile 후 Interpreter vs 바로 Interpreter  Java는 하이브리드 언어Java는 compile도 하고 interpreter도 하기 때문에 하이브리드 언어6.Java?  .class는 왜 만드는가? Interpreter로만 만들어도 되지 않나?Java는 Platform의 영향을 받지 않을 순 없을까? 하는 취지에서 나온 것    Platform = OS = windows, linux…프로그램을 실행      7.JVM?  JVM(Java Virtual Machine)Java가 OS에 종속되지 않는 이유는 JVM 때문Java는 JVM이 OS별로 존재그래서 JVM이 노트북에 설치되면 .class파일을 어떤 OS에서든 실행가능JVM은 Java의 Interpreter8.JVM 원리8.1 Compiler 이동8.2 JVM 이동  Class loaderJVM안에 있는 class loader가 .class를 읽어들임Class loader가 .class파일을 읽어들이는 행위 ‘class load’  Runtime Data AreasOS가 Java에게 할당해 준 메모리OS:java너 프로그램 만들 때 이만큼만 써!!  Execution EngineInterpreter이게 Java의 핵심JIT란 기술이 이 안에 있음          JIT(Just In time)A,B 해석 완료근데 또 A가 나옴이를 또 해석하지 않고 이미 해석 한 A를 가져옴이게 바로 JIT      9.전자정부프레임워크?  전자정부프레임워크          행정안정부에서 개발자들이 개발을 편하게 할 수 있도록 만든 Framework                  Framework→ 여러가지 기능을 설계 해 두어 개발을 할 수 있게 하는 곳                    Spring 기반                  Spring→ Java로 만든 Framework                      라이브러리          개발에 필요한 도구들        전자정부프레임워크는 Spring이라는 틀을 라이브러리로 장식한 것              전자정부프레임워크의 장단점          장점라이브러리는 하나하나 버전이 있음무조건 최신버전이 아님여러가지 버전 중에서 최대한 안정성이 있는 것으로만 만듦굉장히 안정성있음      단점톱니바퀴처럼 딱딱 맞춰놓은 것이기 때문에입맛대로 최신버전을 끼워넣을 수 없음      ",
        "url": "/basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://100jran.github.io/">100'Log</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email search modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search 100'Log</h1>
                <p class="subscribe-overlay-description">
                    lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
